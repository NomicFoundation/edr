use std::sync::OnceLock;

use alloy_rlp::{RlpDecodable, RlpEncodable};
use k256::SecretKey;

use crate::{
    eips::eip2930,
    keccak256,
    signature::{self, public_key_to_address, Fakeable, SignatureError},
    transaction::{self, TxKind},
    utils::envelop_bytes,
    Address, Bytes, B256, U256,
};

#[derive(Clone, Debug, PartialEq, Eq, RlpDecodable, RlpEncodable)]
pub struct Eip1559 {
    // The order of these fields determines encoding order.
    pub chain_id: u64,
    pub nonce: u64,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub gas_limit: u64,
    pub kind: TxKind,
    pub value: U256,
    pub input: Bytes,
    pub access_list: Vec<eip2930::AccessListItem>,
}

impl Eip1559 {
    /// The type identifier for an EIP-1559 transaction.
    pub const TYPE: u8 = 2;

    /// Computes the hash of the transaction.
    pub fn hash(&self) -> B256 {
        let encoded = alloy_rlp::encode(self);

        keccak256(envelop_bytes(2, &encoded))
    }

    /// Signs the transaction with the provided secret key.
    pub fn sign(
        self,
        secret_key: &SecretKey,
    ) -> Result<transaction::signed::Eip1559, SignatureError> {
        let caller = public_key_to_address(secret_key.public_key());

        // SAFETY: The caller is derived from the secret key.
        unsafe { self.sign_for_sender_unchecked(secret_key, caller) }
    }

    /// Signs the transaction with the provided secret key, belonging to the
    /// provided caller's address.
    ///
    /// # Safety
    ///
    /// The `caller` and `secret_key` must correspond to the same account.
    pub unsafe fn sign_for_sender_unchecked(
        self,
        secret_key: &SecretKey,
        caller: Address,
    ) -> Result<transaction::signed::Eip1559, SignatureError> {
        let hash = self.hash();
        let signature = signature::SignatureWithYParity::new(hash, secret_key)?;

        Ok(transaction::signed::Eip1559 {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee_per_gas: self.max_priority_fee_per_gas,
            max_fee_per_gas: self.max_fee_per_gas,
            gas_limit: self.gas_limit,
            kind: self.kind,
            value: self.value,
            input: self.input,
            access_list: self.access_list.into(),
            signature: Fakeable::with_address_unchecked(signature, caller),
            hash: OnceLock::new(),
            rlp_encoding: OnceLock::new(),
        })
    }

    /// Creates a fake signature for an impersonated account.
    pub fn fake_sign(self, sender: Address) -> transaction::signed::Eip1559 {
        transaction::signed::Eip1559 {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee_per_gas: self.max_priority_fee_per_gas,
            max_fee_per_gas: self.max_fee_per_gas,
            gas_limit: self.gas_limit,
            kind: self.kind,
            value: self.value,
            input: self.input,
            access_list: self.access_list.into(),
            signature: signature::Fakeable::fake(sender, None),
            hash: OnceLock::new(),
            rlp_encoding: OnceLock::new(),
        }
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use std::str::FromStr;

    use transaction::ExecutableTransaction as _;

    use super::*;
    use crate::transaction::fake_signature::tests::test_fake_sign_properties;

    fn dummy_request() -> Eip1559 {
        let to = Address::from_str("0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e").unwrap();
        let input = hex::decode("1234").unwrap();
        Eip1559 {
            chain_id: 1,
            nonce: 1,
            max_priority_fee_per_gas: U256::from(2),
            max_fee_per_gas: U256::from(5),
            gas_limit: 3,
            kind: TxKind::Call(to),
            value: U256::from(4),
            input: Bytes::from(input),
            access_list: vec![eip2930::AccessListItem {
                address: Address::ZERO,
                storage_keys: vec![B256::ZERO, B256::from(U256::from(1))],
            }],
        }
    }

    #[test]
    fn test_eip1559_transaction_request_encoding() {
        // Generated by Hardhat
        // QUESTION: What is considered a valid RLP-encoding? With the prepending type?
        // or without?
        let expected =
            hex::decode("f87b010102050394c014ba5ec014ba5ec014ba5ec014ba5ec014ba5e04821234f85bf859940000000000000000000000000000000000000000f842a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001")
                .unwrap();

        let request = dummy_request();

        let encoded = alloy_rlp::encode(&request);
        assert_eq!(expected, encoded);
    }

    #[test]
    fn test_eip1559_transaction_request_encoding_empty() {
        // Generated by Hardhat
        let expected = hex::decode("c90180808080808080c0").unwrap();

        let empty = Eip1559 {
            chain_id: 1,
            nonce: 0,
            max_priority_fee_per_gas: U256::ZERO,
            max_fee_per_gas: U256::ZERO,
            gas_limit: 0,
            kind: TxKind::Create,
            value: U256::ZERO,
            input: Bytes::new(),
            access_list: vec![],
        };

        let encoded = alloy_rlp::encode(&empty);
        assert_eq!(expected, encoded);
    }

    #[test]
    fn test_eip1559_transaction_request_hash() {
        // Generated by hardhat
        let expected = B256::from_slice(
            &hex::decode("1d21c520c93f0f8e07c2466361b22a8bb9906cdbf4670e53a701c075bbe69ecf")
                .unwrap(),
        );

        let request = dummy_request();
        assert_eq!(expected, request.hash());
    }

    test_fake_sign_properties!();

    #[test]
    fn test_fake_sign_test_vector() -> anyhow::Result<()> {
        let transaction = Eip1559 {
            chain_id: 123,
            nonce: 0,
            max_priority_fee_per_gas: U256::from(2),
            max_fee_per_gas: U256::from(12),
            gas_limit: 30_000,
            kind: TxKind::Call("0xb5bc06d4548a3ac17d72b372ae1e416bf65b8ead".parse()?),
            value: U256::from(1),
            input: Bytes::default(),
            access_list: vec![],
        };

        let fake_sender: Address = "0xa5bc06d4548a3ac17d72b372ae1e416bf65b8ead".parse()?;

        let signed = transaction.fake_sign(fake_sender);

        // Generated by Hardhat
        let expected_hash: B256 =
            "ee788ad79d536e2e5146e26b3be0bd12ee4de921c22b3295de3ee16395a015e0".parse()?;
        assert_eq!(signed.transaction_hash(), &expected_hash);

        Ok(())
    }
}
