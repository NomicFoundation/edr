// WARNING: This file is auto-generated. Do not edit manually.
// source: https://github.com/microsoft/debug-adapter-protocol/tree/c586d88de577caee962da186022c4bb79b1103e7/debugAdapterProtocol.json
//
// To update, run `cargo run -p dap-generator` from the workspace root.

#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "`AttachRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `attach` request is sent from the client to the debug adapter to attach to a debuggee that is already running.\\nSince attaching is debugger/runtime specific, the arguments for this request are not part of this specification.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/AttachRequestArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"attach\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AttachRequest {
    pub arguments: AttachRequestArguments,
    pub command: AttachRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: AttachRequestType,
}
impl ::std::convert::From<&AttachRequest> for AttachRequest {
    fn from(value: &AttachRequest) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `attach` request. Additional attributes are implementation specific."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `attach` request. Additional attributes are implementation specific.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"__restart\": {"]
#[doc = "      \"description\": \"Arbitrary data from the previous, restarted session.\\nThe data is sent as the `restart` attribute of the `terminated` event.\\nThe client should leave the data intact.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"boolean\","]
#[doc = "        \"integer\","]
#[doc = "        \"null\","]
#[doc = "        \"number\","]
#[doc = "        \"object\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AttachRequestArguments {
    #[doc = "Arbitrary data from the previous, restarted session.\nThe data is sent as the `restart` attribute of the `terminated` event.\nThe client should leave the data intact."]
    #[serde(
        rename = "__restart",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub restart: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&AttachRequestArguments> for AttachRequestArguments {
    fn from(value: &AttachRequestArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AttachRequestArguments {
    fn default() -> Self {
        Self {
            restart: Default::default(),
        }
    }
}
#[doc = "`AttachRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"attach\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AttachRequestCommand {
    #[serde(rename = "attach")]
    Attach,
}
impl ::std::convert::From<&Self> for AttachRequestCommand {
    fn from(value: &AttachRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AttachRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Attach => f.write_str("attach"),
        }
    }
}
impl ::std::str::FromStr for AttachRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "attach" => Ok(Self::Attach),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AttachRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AttachRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AttachRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AttachRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AttachRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for AttachRequestType {
    fn from(value: &AttachRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AttachRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for AttachRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AttachRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AttachRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AttachRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AttachResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `attach` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AttachResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: AttachResponseType,
}
impl ::std::convert::From<&AttachResponse> for AttachResponse {
    fn from(value: &AttachResponse) -> Self {
        value.clone()
    }
}
#[doc = "`AttachResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AttachResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for AttachResponseType {
    fn from(value: &AttachResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AttachResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for AttachResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AttachResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AttachResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AttachResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Information about a breakpoint created in `setBreakpoints`, `setFunctionBreakpoints`, `setInstructionBreakpoints`, or `setDataBreakpoints` requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Information about a breakpoint created in `setBreakpoints`, `setFunctionBreakpoints`, `setInstructionBreakpoints`, or `setDataBreakpoints` requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verified\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\\nIf no end line is given, then the end column is assumed to be in the start line.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the actual range covered by the breakpoint.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The identifier for the breakpoint. It is needed if breakpoint events are used to update or remove breakpoints.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"instructionReference\": {"]
#[doc = "      \"description\": \"A memory reference to where the breakpoint is set.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The start line of the actual range covered by the breakpoint.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"A message about the state of the breakpoint.\\nThis is shown to the user and can be used to explain why a breakpoint could not be verified.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"The offset from the instruction reference.\\nThis can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"A machine-readable explanation of why a breakpoint may not be verified. If a breakpoint is verified or a specific reason is not known, the adapter should omit this property. Possible values include:\\n\\n- `pending`: Indicates a breakpoint might be verified in the future, but the adapter cannot verify it in the current state.\\n - `failed`: Indicates a breakpoint was not able to be verified, and the adapter does not believe it can be verified without intervention.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending\","]
#[doc = "        \"failed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source where the breakpoint is located.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"verified\": {"]
#[doc = "      \"description\": \"If true, the breakpoint could be set (but not necessarily at the desired location).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Breakpoint {
    #[doc = "Start position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "End position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\nIf no end line is given, then the end column is assumed to be in the start line."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the actual range covered by the breakpoint."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "The identifier for the breakpoint. It is needed if breakpoint events are used to update or remove breakpoints."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[doc = "A memory reference to where the breakpoint is set."]
    #[serde(
        rename = "instructionReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub instruction_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The start line of the actual range covered by the breakpoint."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "A message about the state of the breakpoint.\nThis is shown to the user and can be used to explain why a breakpoint could not be verified."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "The offset from the instruction reference.\nThis can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
    #[doc = "A machine-readable explanation of why a breakpoint may not be verified. If a breakpoint is verified or a specific reason is not known, the adapter should omit this property. Possible values include:\n\n- `pending`: Indicates a breakpoint might be verified in the future, but the adapter cannot verify it in the current state.\n - `failed`: Indicates a breakpoint was not able to be verified, and the adapter does not believe it can be verified without intervention."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub reason: ::std::option::Option<BreakpointReason>,
    #[doc = "The source where the breakpoint is located."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
    #[doc = "If true, the breakpoint could be set (but not necessarily at the desired location)."]
    pub verified: bool,
}
impl ::std::convert::From<&Breakpoint> for Breakpoint {
    fn from(value: &Breakpoint) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that some information about a breakpoint has changed. While debug adapters may notify the clients of `changed` breakpoints using this event, clients should continue to use the breakpoint's original properties when updating a source's breakpoints in the `breakpoint` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoint\","]
#[doc = "            \"reason\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoint\": {"]
#[doc = "              \"description\": \"The `id` attribute is used to find the target breakpoint, the other attributes are used as the new values.\","]
#[doc = "              \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "            },"]
#[doc = "            \"reason\": {"]
#[doc = "              \"description\": \"The reason for the event.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"_enum\": ["]
#[doc = "                \"changed\","]
#[doc = "                \"new\","]
#[doc = "                \"removed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"breakpoint\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointEvent {
    pub body: BreakpointEventBody,
    pub event: BreakpointEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: BreakpointEventType,
}
impl ::std::convert::From<&BreakpointEvent> for BreakpointEvent {
    fn from(value: &BreakpointEvent) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoint\","]
#[doc = "    \"reason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoint\": {"]
#[doc = "      \"description\": \"The `id` attribute is used to find the target breakpoint, the other attributes are used as the new values.\","]
#[doc = "      \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"The reason for the event.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"changed\","]
#[doc = "        \"new\","]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointEventBody {
    #[doc = "The `id` attribute is used to find the target breakpoint, the other attributes are used as the new values."]
    pub breakpoint: Breakpoint,
    #[doc = "The reason for the event."]
    pub reason: ::std::string::String,
}
impl ::std::convert::From<&BreakpointEventBody> for BreakpointEventBody {
    fn from(value: &BreakpointEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"breakpoint\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointEventEvent {
    #[serde(rename = "breakpoint")]
    Breakpoint,
}
impl ::std::convert::From<&Self> for BreakpointEventEvent {
    fn from(value: &BreakpointEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Breakpoint => f.write_str("breakpoint"),
        }
    }
}
impl ::std::str::FromStr for BreakpointEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "breakpoint" => Ok(Self::Breakpoint),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BreakpointEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for BreakpointEventType {
    fn from(value: &BreakpointEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for BreakpointEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Properties of a breakpoint location returned from the `breakpointLocations` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a breakpoint location returned from the `breakpointLocations` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"line\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The start position of a breakpoint location. Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"The end position of a breakpoint location (if the location covers a range). Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of breakpoint location if the location covers a range.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"Start line of breakpoint location.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointLocation {
    #[doc = "The start position of a breakpoint location. Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The end position of a breakpoint location (if the location covers a range). Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of breakpoint location if the location covers a range."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "Start line of breakpoint location."]
    pub line: i64,
}
impl ::std::convert::From<&BreakpointLocation> for BreakpointLocation {
    fn from(value: &BreakpointLocation) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `breakpointLocations` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `breakpointLocations` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"line\","]
#[doc = "    \"source\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position within `line` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position within `endLine` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no end column is given, the last position in the end line is assumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"End line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointLocationsArguments {
    #[doc = "Start position within `line` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "End position within `endLine` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no end column is given, the last position in the end line is assumed."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "End line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line."]
    pub line: i64,
    #[doc = "The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified."]
    pub source: Source,
}
impl ::std::convert::From<&BreakpointLocationsArguments> for BreakpointLocationsArguments {
    fn from(value: &BreakpointLocationsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointLocationsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `breakpointLocations` request returns all possible locations for source breakpoints in a given range.\\nClients should only call this request if the corresponding capability `supportsBreakpointLocationsRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/BreakpointLocationsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"breakpointLocations\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointLocationsRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<BreakpointLocationsArguments>,
    pub command: BreakpointLocationsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: BreakpointLocationsRequestType,
}
impl ::std::convert::From<&BreakpointLocationsRequest> for BreakpointLocationsRequest {
    fn from(value: &BreakpointLocationsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointLocationsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"breakpointLocations\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointLocationsRequestCommand {
    #[serde(rename = "breakpointLocations")]
    BreakpointLocations,
}
impl ::std::convert::From<&Self> for BreakpointLocationsRequestCommand {
    fn from(value: &BreakpointLocationsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointLocationsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::BreakpointLocations => f.write_str("breakpointLocations"),
        }
    }
}
impl ::std::str::FromStr for BreakpointLocationsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "breakpointLocations" => Ok(Self::BreakpointLocations),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointLocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointLocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointLocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BreakpointLocationsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointLocationsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for BreakpointLocationsRequestType {
    fn from(value: &BreakpointLocationsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointLocationsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for BreakpointLocationsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointLocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointLocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointLocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BreakpointLocationsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `breakpointLocations` request.\\nContains possible locations for source breakpoints.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoints\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Sorted set of possible breakpoint locations.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/BreakpointLocation\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointLocationsResponse {
    pub body: BreakpointLocationsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: BreakpointLocationsResponseType,
}
impl ::std::convert::From<&BreakpointLocationsResponse> for BreakpointLocationsResponse {
    fn from(value: &BreakpointLocationsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointLocationsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Sorted set of possible breakpoint locations.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/BreakpointLocation\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointLocationsResponseBody {
    #[doc = "Sorted set of possible breakpoint locations."]
    pub breakpoints: ::std::vec::Vec<BreakpointLocation>,
}
impl ::std::convert::From<&BreakpointLocationsResponseBody> for BreakpointLocationsResponseBody {
    fn from(value: &BreakpointLocationsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`BreakpointLocationsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointLocationsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for BreakpointLocationsResponseType {
    fn from(value: &BreakpointLocationsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointLocationsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for BreakpointLocationsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointLocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointLocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointLocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `BreakpointMode` is provided as a option when setting breakpoints on sources or instructions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `BreakpointMode` is provided as a option when setting breakpoints on sources or instructions.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"appliesTo\","]
#[doc = "    \"label\","]
#[doc = "    \"mode\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"appliesTo\": {"]
#[doc = "      \"description\": \"Describes one or more type of breakpoint this mode applies to.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/BreakpointModeApplicability\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A help text providing additional information about the breakpoint mode. This string is typically shown as a hover and can be translated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The name of the breakpoint mode. This is shown in the UI.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The internal ID of the mode. This value is passed to the `setBreakpoints` request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BreakpointMode {
    #[doc = "Describes one or more type of breakpoint this mode applies to."]
    #[serde(rename = "appliesTo")]
    pub applies_to: ::std::vec::Vec<BreakpointModeApplicability>,
    #[doc = "A help text providing additional information about the breakpoint mode. This string is typically shown as a hover and can be translated."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the breakpoint mode. This is shown in the UI."]
    pub label: ::std::string::String,
    #[doc = "The internal ID of the mode. This value is passed to the `setBreakpoints` request."]
    pub mode: ::std::string::String,
}
impl ::std::convert::From<&BreakpointMode> for BreakpointMode {
    fn from(value: &BreakpointMode) -> Self {
        value.clone()
    }
}
#[doc = "Describes one or more type of breakpoint a `BreakpointMode` applies to. This is a non-exhaustive enumeration and may expand as future breakpoint types are added."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes one or more type of breakpoint a `BreakpointMode` applies to. This is a non-exhaustive enumeration and may expand as future breakpoint types are added.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"_enum\": ["]
#[doc = "    \"source\","]
#[doc = "    \"exception\","]
#[doc = "    \"data\","]
#[doc = "    \"instruction\""]
#[doc = "  ],"]
#[doc = "  \"enumDescriptions\": ["]
#[doc = "    \"In `SourceBreakpoint`s\","]
#[doc = "    \"In exception breakpoints applied in the `ExceptionFilterOptions`\","]
#[doc = "    \"In data breakpoints requested in the `DataBreakpointInfo` request\","]
#[doc = "    \"In `InstructionBreakpoint`s\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct BreakpointModeApplicability(pub ::std::string::String);
impl ::std::ops::Deref for BreakpointModeApplicability {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<BreakpointModeApplicability> for ::std::string::String {
    fn from(value: BreakpointModeApplicability) -> Self {
        value.0
    }
}
impl ::std::convert::From<&BreakpointModeApplicability> for BreakpointModeApplicability {
    fn from(value: &BreakpointModeApplicability) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for BreakpointModeApplicability {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for BreakpointModeApplicability {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for BreakpointModeApplicability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "A machine-readable explanation of why a breakpoint may not be verified. If a breakpoint is verified or a specific reason is not known, the adapter should omit this property. Possible values include:\n\n- `pending`: Indicates a breakpoint might be verified in the future, but the adapter cannot verify it in the current state.\n - `failed`: Indicates a breakpoint was not able to be verified, and the adapter does not believe it can be verified without intervention."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A machine-readable explanation of why a breakpoint may not be verified. If a breakpoint is verified or a specific reason is not known, the adapter should omit this property. Possible values include:\\n\\n- `pending`: Indicates a breakpoint might be verified in the future, but the adapter cannot verify it in the current state.\\n - `failed`: Indicates a breakpoint was not able to be verified, and the adapter does not believe it can be verified without intervention.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending\","]
#[doc = "    \"failed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BreakpointReason {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "failed")]
    Failed,
}
impl ::std::convert::From<&Self> for BreakpointReason {
    fn from(value: &BreakpointReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BreakpointReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pending => f.write_str("pending"),
            Self::Failed => f.write_str("failed"),
        }
    }
}
impl ::std::str::FromStr for BreakpointReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending" => Ok(Self::Pending),
            "failed" => Ok(Self::Failed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BreakpointReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BreakpointReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BreakpointReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `cancel` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `cancel` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressId\": {"]
#[doc = "      \"description\": \"The ID (attribute `progressId`) of the progress to cancel. If missing no progress is cancelled.\\nBoth a `requestId` and a `progressId` can be specified in one request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"requestId\": {"]
#[doc = "      \"description\": \"The ID (attribute `seq`) of the request to cancel. If missing no request is cancelled.\\nBoth a `requestId` and a `progressId` can be specified in one request.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelArguments {
    #[doc = "The ID (attribute `progressId`) of the progress to cancel. If missing no progress is cancelled.\nBoth a `requestId` and a `progressId` can be specified in one request."]
    #[serde(
        rename = "progressId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_id: ::std::option::Option<::std::string::String>,
    #[doc = "The ID (attribute `seq`) of the request to cancel. If missing no request is cancelled.\nBoth a `requestId` and a `progressId` can be specified in one request."]
    #[serde(
        rename = "requestId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub request_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CancelArguments> for CancelArguments {
    fn from(value: &CancelArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CancelArguments {
    fn default() -> Self {
        Self {
            progress_id: Default::default(),
            request_id: Default::default(),
        }
    }
}
#[doc = "`CancelRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `cancel` request is used by the client in two situations:\\n- to indicate that it is no longer interested in the result produced by a specific request issued earlier\\n- to cancel a progress sequence.\\nClients should only call this request if the corresponding capability `supportsCancelRequest` is true.\\nThis request has a hint characteristic: a debug adapter can only be expected to make a 'best effort' in honoring this request but there are no guarantees.\\nThe `cancel` request may return an error if it could not cancel an operation but a client should refrain from presenting this error to end users.\\nThe request that got cancelled still needs to send a response back. This can either be a normal result (`success` attribute true) or an error response (`success` attribute false and the `message` set to `cancelled`).\\nReturning partial results from a cancelled request is possible but please note that a client has no generic way for detecting that a response is partial or not.\\nThe progress that got cancelled still needs to send a `progressEnd` event back.\\n A client should not assume that progress just got cancelled after sending the `cancel` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/CancelArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"cancel\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<CancelArguments>,
    pub command: CancelRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: CancelRequestType,
}
impl ::std::convert::From<&CancelRequest> for CancelRequest {
    fn from(value: &CancelRequest) -> Self {
        value.clone()
    }
}
#[doc = "`CancelRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"cancel\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CancelRequestCommand {
    #[serde(rename = "cancel")]
    Cancel,
}
impl ::std::convert::From<&Self> for CancelRequestCommand {
    fn from(value: &CancelRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CancelRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Cancel => f.write_str("cancel"),
        }
    }
}
impl ::std::str::FromStr for CancelRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "cancel" => Ok(Self::Cancel),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CancelRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CancelRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CancelRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CancelRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CancelRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for CancelRequestType {
    fn from(value: &CancelRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CancelRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for CancelRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CancelRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CancelRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CancelRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CancelResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `cancel` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: CancelResponseType,
}
impl ::std::convert::From<&CancelResponse> for CancelResponse {
    fn from(value: &CancelResponse) -> Self {
        value.clone()
    }
}
#[doc = "`CancelResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CancelResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for CancelResponseType {
    fn from(value: &CancelResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CancelResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for CancelResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CancelResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CancelResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CancelResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Information about the capabilities of a debug adapter."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Types\","]
#[doc = "  \"description\": \"Information about the capabilities of a debug adapter.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"additionalModuleColumns\": {"]
#[doc = "      \"description\": \"The set of additional module information exposed by the debug adapter.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ColumnDescriptor\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"breakpointModes\": {"]
#[doc = "      \"description\": \"Modes of breakpoints supported by the debug adapter, such as 'hardware' or 'software'. If present, the client may allow the user to select a mode and include it in its `setBreakpoints` request.\\n\\nClients may present the first applicable mode in this array as the 'default' mode in gestures that set breakpoints.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/BreakpointMode\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"completionTriggerCharacters\": {"]
#[doc = "      \"description\": \"The set of characters that should automatically trigger a completion request in a REPL. If not specified, the client should assume the `.` character. The client may trigger additional completion requests on characters such as ones that make up common identifiers, or as otherwise requested by a user.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"exceptionBreakpointFilters\": {"]
#[doc = "      \"description\": \"Available exception filter options for the `setExceptionBreakpoints` request.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ExceptionBreakpointsFilter\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"supportSuspendDebuggee\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `suspendDebuggee` attribute on the `disconnect` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportTerminateDebuggee\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `terminateDebuggee` attribute on the `disconnect` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportedChecksumAlgorithms\": {"]
#[doc = "      \"description\": \"Checksum algorithms supported by the debug adapter.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ChecksumAlgorithm\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"supportsANSIStyling\": {"]
#[doc = "      \"description\": \"The debug adapter supports ANSI escape sequences in styling of `OutputEvent.output` and `Variable.value` fields.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsBreakpointLocationsRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `breakpointLocations` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsCancelRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `cancel` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsClipboardContext\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `clipboard` context value in the `evaluate` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsCompletionsRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `completions` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsConditionalBreakpoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports conditional breakpoints.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsConfigurationDoneRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `configurationDone` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsDataBreakpointBytes\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `asAddress` and `bytes` fields in the `dataBreakpointInfo` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsDataBreakpoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports data breakpoints.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsDelayedStackTraceLoading\": {"]
#[doc = "      \"description\": \"The debug adapter supports the delayed loading of parts of the stack, which requires that both the `startFrame` and `levels` arguments and the `totalFrames` result of the `stackTrace` request are supported.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsDisassembleRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `disassemble` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsEvaluateForHovers\": {"]
#[doc = "      \"description\": \"The debug adapter supports a (side effect free) `evaluate` request for data hovers.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsExceptionFilterOptions\": {"]
#[doc = "      \"description\": \"The debug adapter supports `filterOptions` as an argument on the `setExceptionBreakpoints` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsExceptionInfoRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `exceptionInfo` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsExceptionOptions\": {"]
#[doc = "      \"description\": \"The debug adapter supports `exceptionOptions` on the `setExceptionBreakpoints` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsFunctionBreakpoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports function breakpoints.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsGotoTargetsRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `gotoTargets` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsHitConditionalBreakpoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports breakpoints that break execution after a specified number of hits.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsInstructionBreakpoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports adding breakpoints based on instruction references.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsLoadedSourcesRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `loadedSources` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsLogPoints\": {"]
#[doc = "      \"description\": \"The debug adapter supports log points by interpreting the `logMessage` attribute of the `SourceBreakpoint`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsModulesRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `modules` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsReadMemoryRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `readMemory` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsRestartFrame\": {"]
#[doc = "      \"description\": \"The debug adapter supports restarting a frame.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsRestartRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `restart` request. In this case a client should not implement `restart` by terminating and relaunching the adapter but by calling the `restart` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsSetExpression\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `setExpression` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsSetVariable\": {"]
#[doc = "      \"description\": \"The debug adapter supports setting a variable to a value.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsSingleThreadExecutionRequests\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `singleThread` property on the execution requests (`continue`, `next`, `stepIn`, `stepOut`, `reverseContinue`, `stepBack`).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsStepBack\": {"]
#[doc = "      \"description\": \"The debug adapter supports stepping back via the `stepBack` and `reverseContinue` requests.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsStepInTargetsRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `stepInTargets` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsSteppingGranularity\": {"]
#[doc = "      \"description\": \"The debug adapter supports stepping granularities (argument `granularity`) for the stepping requests.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsTerminateRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `terminate` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsTerminateThreadsRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `terminateThreads` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsValueFormattingOptions\": {"]
#[doc = "      \"description\": \"The debug adapter supports a `format` attribute on the `stackTrace`, `variables`, and `evaluate` requests.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsWriteMemoryRequest\": {"]
#[doc = "      \"description\": \"The debug adapter supports the `writeMemory` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Capabilities {
    #[doc = "The set of additional module information exposed by the debug adapter."]
    #[serde(
        rename = "additionalModuleColumns",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub additional_module_columns: ::std::vec::Vec<ColumnDescriptor>,
    #[doc = "Modes of breakpoints supported by the debug adapter, such as 'hardware' or 'software'. If present, the client may allow the user to select a mode and include it in its `setBreakpoints` request.\n\nClients may present the first applicable mode in this array as the 'default' mode in gestures that set breakpoints."]
    #[serde(
        rename = "breakpointModes",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub breakpoint_modes: ::std::vec::Vec<BreakpointMode>,
    #[doc = "The set of characters that should automatically trigger a completion request in a REPL. If not specified, the client should assume the `.` character. The client may trigger additional completion requests on characters such as ones that make up common identifiers, or as otherwise requested by a user."]
    #[serde(
        rename = "completionTriggerCharacters",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub completion_trigger_characters: ::std::vec::Vec<::std::string::String>,
    #[doc = "Available exception filter options for the `setExceptionBreakpoints` request."]
    #[serde(
        rename = "exceptionBreakpointFilters",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub exception_breakpoint_filters: ::std::vec::Vec<ExceptionBreakpointsFilter>,
    #[doc = "The debug adapter supports the `suspendDebuggee` attribute on the `disconnect` request."]
    #[serde(
        rename = "supportSuspendDebuggee",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub support_suspend_debuggee: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `terminateDebuggee` attribute on the `disconnect` request."]
    #[serde(
        rename = "supportTerminateDebuggee",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub support_terminate_debuggee: ::std::option::Option<bool>,
    #[doc = "Checksum algorithms supported by the debug adapter."]
    #[serde(
        rename = "supportedChecksumAlgorithms",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub supported_checksum_algorithms: ::std::vec::Vec<ChecksumAlgorithm>,
    #[doc = "The debug adapter supports ANSI escape sequences in styling of `OutputEvent.output` and `Variable.value` fields."]
    #[serde(
        rename = "supportsANSIStyling",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_ansi_styling: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `breakpointLocations` request."]
    #[serde(
        rename = "supportsBreakpointLocationsRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_breakpoint_locations_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `cancel` request."]
    #[serde(
        rename = "supportsCancelRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_cancel_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `clipboard` context value in the `evaluate` request."]
    #[serde(
        rename = "supportsClipboardContext",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_clipboard_context: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `completions` request."]
    #[serde(
        rename = "supportsCompletionsRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_completions_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports conditional breakpoints."]
    #[serde(
        rename = "supportsConditionalBreakpoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_conditional_breakpoints: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `configurationDone` request."]
    #[serde(
        rename = "supportsConfigurationDoneRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_configuration_done_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `asAddress` and `bytes` fields in the `dataBreakpointInfo` request."]
    #[serde(
        rename = "supportsDataBreakpointBytes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_data_breakpoint_bytes: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports data breakpoints."]
    #[serde(
        rename = "supportsDataBreakpoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_data_breakpoints: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the delayed loading of parts of the stack, which requires that both the `startFrame` and `levels` arguments and the `totalFrames` result of the `stackTrace` request are supported."]
    #[serde(
        rename = "supportsDelayedStackTraceLoading",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_delayed_stack_trace_loading: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `disassemble` request."]
    #[serde(
        rename = "supportsDisassembleRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_disassemble_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports a (side effect free) `evaluate` request for data hovers."]
    #[serde(
        rename = "supportsEvaluateForHovers",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_evaluate_for_hovers: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports `filterOptions` as an argument on the `setExceptionBreakpoints` request."]
    #[serde(
        rename = "supportsExceptionFilterOptions",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_exception_filter_options: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `exceptionInfo` request."]
    #[serde(
        rename = "supportsExceptionInfoRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_exception_info_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports `exceptionOptions` on the `setExceptionBreakpoints` request."]
    #[serde(
        rename = "supportsExceptionOptions",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_exception_options: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports function breakpoints."]
    #[serde(
        rename = "supportsFunctionBreakpoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_function_breakpoints: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `gotoTargets` request."]
    #[serde(
        rename = "supportsGotoTargetsRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_goto_targets_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports breakpoints that break execution after a specified number of hits."]
    #[serde(
        rename = "supportsHitConditionalBreakpoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_hit_conditional_breakpoints: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports adding breakpoints based on instruction references."]
    #[serde(
        rename = "supportsInstructionBreakpoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_instruction_breakpoints: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `loadedSources` request."]
    #[serde(
        rename = "supportsLoadedSourcesRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_loaded_sources_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports log points by interpreting the `logMessage` attribute of the `SourceBreakpoint`."]
    #[serde(
        rename = "supportsLogPoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_log_points: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `modules` request."]
    #[serde(
        rename = "supportsModulesRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_modules_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `readMemory` request."]
    #[serde(
        rename = "supportsReadMemoryRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_read_memory_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports restarting a frame."]
    #[serde(
        rename = "supportsRestartFrame",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_restart_frame: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `restart` request. In this case a client should not implement `restart` by terminating and relaunching the adapter but by calling the `restart` request."]
    #[serde(
        rename = "supportsRestartRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_restart_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `setExpression` request."]
    #[serde(
        rename = "supportsSetExpression",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_set_expression: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports setting a variable to a value."]
    #[serde(
        rename = "supportsSetVariable",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_set_variable: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `singleThread` property on the execution requests (`continue`, `next`, `stepIn`, `stepOut`, `reverseContinue`, `stepBack`)."]
    #[serde(
        rename = "supportsSingleThreadExecutionRequests",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_single_thread_execution_requests: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports stepping back via the `stepBack` and `reverseContinue` requests."]
    #[serde(
        rename = "supportsStepBack",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_step_back: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `stepInTargets` request."]
    #[serde(
        rename = "supportsStepInTargetsRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_step_in_targets_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports stepping granularities (argument `granularity`) for the stepping requests."]
    #[serde(
        rename = "supportsSteppingGranularity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_stepping_granularity: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `terminate` request."]
    #[serde(
        rename = "supportsTerminateRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_terminate_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `terminateThreads` request."]
    #[serde(
        rename = "supportsTerminateThreadsRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_terminate_threads_request: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports a `format` attribute on the `stackTrace`, `variables`, and `evaluate` requests."]
    #[serde(
        rename = "supportsValueFormattingOptions",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_value_formatting_options: ::std::option::Option<bool>,
    #[doc = "The debug adapter supports the `writeMemory` request."]
    #[serde(
        rename = "supportsWriteMemoryRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_write_memory_request: ::std::option::Option<bool>,
}
impl ::std::convert::From<&Capabilities> for Capabilities {
    fn from(value: &Capabilities) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Capabilities {
    fn default() -> Self {
        Self {
            additional_module_columns: Default::default(),
            breakpoint_modes: Default::default(),
            completion_trigger_characters: Default::default(),
            exception_breakpoint_filters: Default::default(),
            support_suspend_debuggee: Default::default(),
            support_terminate_debuggee: Default::default(),
            supported_checksum_algorithms: Default::default(),
            supports_ansi_styling: Default::default(),
            supports_breakpoint_locations_request: Default::default(),
            supports_cancel_request: Default::default(),
            supports_clipboard_context: Default::default(),
            supports_completions_request: Default::default(),
            supports_conditional_breakpoints: Default::default(),
            supports_configuration_done_request: Default::default(),
            supports_data_breakpoint_bytes: Default::default(),
            supports_data_breakpoints: Default::default(),
            supports_delayed_stack_trace_loading: Default::default(),
            supports_disassemble_request: Default::default(),
            supports_evaluate_for_hovers: Default::default(),
            supports_exception_filter_options: Default::default(),
            supports_exception_info_request: Default::default(),
            supports_exception_options: Default::default(),
            supports_function_breakpoints: Default::default(),
            supports_goto_targets_request: Default::default(),
            supports_hit_conditional_breakpoints: Default::default(),
            supports_instruction_breakpoints: Default::default(),
            supports_loaded_sources_request: Default::default(),
            supports_log_points: Default::default(),
            supports_modules_request: Default::default(),
            supports_read_memory_request: Default::default(),
            supports_restart_frame: Default::default(),
            supports_restart_request: Default::default(),
            supports_set_expression: Default::default(),
            supports_set_variable: Default::default(),
            supports_single_thread_execution_requests: Default::default(),
            supports_step_back: Default::default(),
            supports_step_in_targets_request: Default::default(),
            supports_stepping_granularity: Default::default(),
            supports_terminate_request: Default::default(),
            supports_terminate_threads_request: Default::default(),
            supports_value_formatting_options: Default::default(),
            supports_write_memory_request: Default::default(),
        }
    }
}
#[doc = "`CapabilitiesEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that one or more capabilities have changed.\\nSince the capabilities are dependent on the client and its UI, it might not be possible to change that at random times (or too late).\\nConsequently this event has a hint characteristic: a client can only be expected to make a 'best effort' in honoring individual capabilities but there are no guarantees.\\nOnly changed capabilities need to be included, all other capabilities keep their values.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"capabilities\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"capabilities\": {"]
#[doc = "              \"description\": \"The set of updated capabilities.\","]
#[doc = "              \"$ref\": \"#/definitions/Capabilities\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"capabilities\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CapabilitiesEvent {
    pub body: CapabilitiesEventBody,
    pub event: CapabilitiesEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: CapabilitiesEventType,
}
impl ::std::convert::From<&CapabilitiesEvent> for CapabilitiesEvent {
    fn from(value: &CapabilitiesEvent) -> Self {
        value.clone()
    }
}
#[doc = "`CapabilitiesEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"capabilities\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"capabilities\": {"]
#[doc = "      \"description\": \"The set of updated capabilities.\","]
#[doc = "      \"$ref\": \"#/definitions/Capabilities\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CapabilitiesEventBody {
    #[doc = "The set of updated capabilities."]
    pub capabilities: Capabilities,
}
impl ::std::convert::From<&CapabilitiesEventBody> for CapabilitiesEventBody {
    fn from(value: &CapabilitiesEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`CapabilitiesEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"capabilities\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CapabilitiesEventEvent {
    #[serde(rename = "capabilities")]
    Capabilities,
}
impl ::std::convert::From<&Self> for CapabilitiesEventEvent {
    fn from(value: &CapabilitiesEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CapabilitiesEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Capabilities => f.write_str("capabilities"),
        }
    }
}
impl ::std::str::FromStr for CapabilitiesEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "capabilities" => Ok(Self::Capabilities),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CapabilitiesEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CapabilitiesEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CapabilitiesEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CapabilitiesEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CapabilitiesEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for CapabilitiesEventType {
    fn from(value: &CapabilitiesEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CapabilitiesEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for CapabilitiesEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CapabilitiesEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CapabilitiesEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CapabilitiesEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The checksum of an item calculated by the specified algorithm."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The checksum of an item calculated by the specified algorithm.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"algorithm\","]
#[doc = "    \"checksum\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"algorithm\": {"]
#[doc = "      \"description\": \"The algorithm used to calculate this checksum.\","]
#[doc = "      \"$ref\": \"#/definitions/ChecksumAlgorithm\""]
#[doc = "    },"]
#[doc = "    \"checksum\": {"]
#[doc = "      \"description\": \"Value of the checksum, encoded as a hexadecimal value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Checksum {
    #[doc = "The algorithm used to calculate this checksum."]
    pub algorithm: ChecksumAlgorithm,
    #[doc = "Value of the checksum, encoded as a hexadecimal value."]
    pub checksum: ::std::string::String,
}
impl ::std::convert::From<&Checksum> for Checksum {
    fn from(value: &Checksum) -> Self {
        value.clone()
    }
}
#[doc = "Names of checksum algorithms that may be supported by a debug adapter."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Names of checksum algorithms that may be supported by a debug adapter.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"MD5\","]
#[doc = "    \"SHA1\","]
#[doc = "    \"SHA256\","]
#[doc = "    \"timestamp\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ChecksumAlgorithm {
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "timestamp")]
    Timestamp,
}
impl ::std::convert::From<&Self> for ChecksumAlgorithm {
    fn from(value: &ChecksumAlgorithm) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ChecksumAlgorithm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Md5 => f.write_str("MD5"),
            Self::Sha1 => f.write_str("SHA1"),
            Self::Sha256 => f.write_str("SHA256"),
            Self::Timestamp => f.write_str("timestamp"),
        }
    }
}
impl ::std::str::FromStr for ChecksumAlgorithm {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "MD5" => Ok(Self::Md5),
            "SHA1" => Ok(Self::Sha1),
            "SHA256" => Ok(Self::Sha256),
            "timestamp" => Ok(Self::Timestamp),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ChecksumAlgorithm {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ChecksumAlgorithm {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ChecksumAlgorithm {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `ColumnDescriptor` specifies what module attribute to show in a column of the modules view, how to format it,\nand what the column's label should be.\nIt is only used if the underlying UI actually supports this level of customization."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `ColumnDescriptor` specifies what module attribute to show in a column of the modules view, how to format it,\\nand what the column's label should be.\\nIt is only used if the underlying UI actually supports this level of customization.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"attributeName\","]
#[doc = "    \"label\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"attributeName\": {"]
#[doc = "      \"description\": \"Name of the attribute rendered in this column.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Format to use for the rendered values in this column. TBD how the format strings looks like.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"Header UI label of column.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"Datatype of values in this column. Defaults to `string` if not specified.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"string\","]
#[doc = "        \"number\","]
#[doc = "        \"boolean\","]
#[doc = "        \"unixTimestampUTC\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"width\": {"]
#[doc = "      \"description\": \"Width of this column in characters (hint only).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ColumnDescriptor {
    #[doc = "Name of the attribute rendered in this column."]
    #[serde(rename = "attributeName")]
    pub attribute_name: ::std::string::String,
    #[doc = "Format to use for the rendered values in this column. TBD how the format strings looks like."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<::std::string::String>,
    #[doc = "Header UI label of column."]
    pub label: ::std::string::String,
    #[doc = "Datatype of values in this column. Defaults to `string` if not specified."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<ColumnDescriptorType>,
    #[doc = "Width of this column in characters (hint only)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub width: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ColumnDescriptor> for ColumnDescriptor {
    fn from(value: &ColumnDescriptor) -> Self {
        value.clone()
    }
}
#[doc = "Datatype of values in this column. Defaults to `string` if not specified."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Datatype of values in this column. Defaults to `string` if not specified.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"string\","]
#[doc = "    \"number\","]
#[doc = "    \"boolean\","]
#[doc = "    \"unixTimestampUTC\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ColumnDescriptorType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "unixTimestampUTC")]
    UnixTimestampUtc,
}
impl ::std::convert::From<&Self> for ColumnDescriptorType {
    fn from(value: &ColumnDescriptorType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ColumnDescriptorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::String => f.write_str("string"),
            Self::Number => f.write_str("number"),
            Self::Boolean => f.write_str("boolean"),
            Self::UnixTimestampUtc => f.write_str("unixTimestampUTC"),
        }
    }
}
impl ::std::str::FromStr for ColumnDescriptorType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "string" => Ok(Self::String),
            "number" => Ok(Self::Number),
            "boolean" => Ok(Self::Boolean),
            "unixTimestampUTC" => Ok(Self::UnixTimestampUtc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ColumnDescriptorType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ColumnDescriptorType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ColumnDescriptorType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CompletionItems` are the suggestions returned from the `completions` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"`CompletionItems` are the suggestions returned from the `completions` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"detail\": {"]
#[doc = "      \"description\": \"A human-readable string with additional information about this item, like type or symbol information.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label of this completion item. By default this is also the text that is inserted when selecting this completion.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"length\": {"]
#[doc = "      \"description\": \"Length determines how many characters are overwritten by the completion text and it is measured in UTF-16 code units. If missing the value 0 is assumed which results in the completion text being inserted.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"selectionLength\": {"]
#[doc = "      \"description\": \"Determines the length of the new selection after the text has been inserted (or replaced) and it is measured in UTF-16 code units. The selection can not extend beyond the bounds of the completion text. If omitted the length is assumed to be 0.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"selectionStart\": {"]
#[doc = "      \"description\": \"Determines the start of the new selection after the text has been inserted (or replaced). `selectionStart` is measured in UTF-16 code units and must be in the range 0 and length of the completion text. If omitted the selection starts at the end of the completion text.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"sortText\": {"]
#[doc = "      \"description\": \"A string that should be used when comparing this item with other items. If not returned or an empty string, the `label` is used instead.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"description\": \"Start position (within the `text` attribute of the `completions` request) where the completion text is added. The position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If the start position is omitted the text is added at the location specified by the `column` attribute of the `completions` request.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"description\": \"If text is returned and not an empty string, then it is inserted instead of the label.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"The item's type. Typically the client uses this information to render the item in the UI with an icon.\","]
#[doc = "      \"$ref\": \"#/definitions/CompletionItemType\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompletionItem {
    #[doc = "A human-readable string with additional information about this item, like type or symbol information."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub detail: ::std::option::Option<::std::string::String>,
    #[doc = "The label of this completion item. By default this is also the text that is inserted when selecting this completion."]
    pub label: ::std::string::String,
    #[doc = "Length determines how many characters are overwritten by the completion text and it is measured in UTF-16 code units. If missing the value 0 is assumed which results in the completion text being inserted."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length: ::std::option::Option<i64>,
    #[doc = "Determines the length of the new selection after the text has been inserted (or replaced) and it is measured in UTF-16 code units. The selection can not extend beyond the bounds of the completion text. If omitted the length is assumed to be 0."]
    #[serde(
        rename = "selectionLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub selection_length: ::std::option::Option<i64>,
    #[doc = "Determines the start of the new selection after the text has been inserted (or replaced). `selectionStart` is measured in UTF-16 code units and must be in the range 0 and length of the completion text. If omitted the selection starts at the end of the completion text."]
    #[serde(
        rename = "selectionStart",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub selection_start: ::std::option::Option<i64>,
    #[doc = "A string that should be used when comparing this item with other items. If not returned or an empty string, the `label` is used instead."]
    #[serde(
        rename = "sortText",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sort_text: ::std::option::Option<::std::string::String>,
    #[doc = "Start position (within the `text` attribute of the `completions` request) where the completion text is added. The position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If the start position is omitted the text is added at the location specified by the `column` attribute of the `completions` request."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start: ::std::option::Option<i64>,
    #[doc = "If text is returned and not an empty string, then it is inserted instead of the label."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
    #[doc = "The item's type. Typically the client uses this information to render the item in the UI with an icon."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<CompletionItemType>,
}
impl ::std::convert::From<&CompletionItem> for CompletionItem {
    fn from(value: &CompletionItem) -> Self {
        value.clone()
    }
}
#[doc = "Some predefined types for the CompletionItem. Please note that not all clients have specific icons for all of them."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Some predefined types for the CompletionItem. Please note that not all clients have specific icons for all of them.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"method\","]
#[doc = "    \"function\","]
#[doc = "    \"constructor\","]
#[doc = "    \"field\","]
#[doc = "    \"variable\","]
#[doc = "    \"class\","]
#[doc = "    \"interface\","]
#[doc = "    \"module\","]
#[doc = "    \"property\","]
#[doc = "    \"unit\","]
#[doc = "    \"value\","]
#[doc = "    \"enum\","]
#[doc = "    \"keyword\","]
#[doc = "    \"snippet\","]
#[doc = "    \"text\","]
#[doc = "    \"color\","]
#[doc = "    \"file\","]
#[doc = "    \"reference\","]
#[doc = "    \"customcolor\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CompletionItemType {
    #[serde(rename = "method")]
    Method,
    #[serde(rename = "function")]
    Function,
    #[serde(rename = "constructor")]
    Constructor,
    #[serde(rename = "field")]
    Field,
    #[serde(rename = "variable")]
    Variable,
    #[serde(rename = "class")]
    Class,
    #[serde(rename = "interface")]
    Interface,
    #[serde(rename = "module")]
    Module,
    #[serde(rename = "property")]
    Property,
    #[serde(rename = "unit")]
    Unit,
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "enum")]
    Enum,
    #[serde(rename = "keyword")]
    Keyword,
    #[serde(rename = "snippet")]
    Snippet,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "file")]
    File,
    #[serde(rename = "reference")]
    Reference,
    #[serde(rename = "customcolor")]
    Customcolor,
}
impl ::std::convert::From<&Self> for CompletionItemType {
    fn from(value: &CompletionItemType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CompletionItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Method => f.write_str("method"),
            Self::Function => f.write_str("function"),
            Self::Constructor => f.write_str("constructor"),
            Self::Field => f.write_str("field"),
            Self::Variable => f.write_str("variable"),
            Self::Class => f.write_str("class"),
            Self::Interface => f.write_str("interface"),
            Self::Module => f.write_str("module"),
            Self::Property => f.write_str("property"),
            Self::Unit => f.write_str("unit"),
            Self::Value => f.write_str("value"),
            Self::Enum => f.write_str("enum"),
            Self::Keyword => f.write_str("keyword"),
            Self::Snippet => f.write_str("snippet"),
            Self::Text => f.write_str("text"),
            Self::Color => f.write_str("color"),
            Self::File => f.write_str("file"),
            Self::Reference => f.write_str("reference"),
            Self::Customcolor => f.write_str("customcolor"),
        }
    }
}
impl ::std::str::FromStr for CompletionItemType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "method" => Ok(Self::Method),
            "function" => Ok(Self::Function),
            "constructor" => Ok(Self::Constructor),
            "field" => Ok(Self::Field),
            "variable" => Ok(Self::Variable),
            "class" => Ok(Self::Class),
            "interface" => Ok(Self::Interface),
            "module" => Ok(Self::Module),
            "property" => Ok(Self::Property),
            "unit" => Ok(Self::Unit),
            "value" => Ok(Self::Value),
            "enum" => Ok(Self::Enum),
            "keyword" => Ok(Self::Keyword),
            "snippet" => Ok(Self::Snippet),
            "text" => Ok(Self::Text),
            "color" => Ok(Self::Color),
            "file" => Ok(Self::File),
            "reference" => Ok(Self::Reference),
            "customcolor" => Ok(Self::Customcolor),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CompletionItemType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CompletionItemType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CompletionItemType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `completions` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `completions` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"column\","]
#[doc = "    \"text\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The position within `text` for which to determine the completion proposals. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"Returns completions in the scope of this stack frame. If not specified, the completions are returned for the global scope.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"A line for which to determine the completion proposals. If missing the first line of the text is assumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"description\": \"One or more source lines. Typically this is the text users have typed into the debug console before they asked for completion.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompletionsArguments {
    #[doc = "The position within `text` for which to determine the completion proposals. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    pub column: i64,
    #[doc = "Returns completions in the scope of this stack frame. If not specified, the completions are returned for the global scope."]
    #[serde(
        rename = "frameId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub frame_id: ::std::option::Option<i64>,
    #[doc = "A line for which to determine the completion proposals. If missing the first line of the text is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "One or more source lines. Typically this is the text users have typed into the debug console before they asked for completion."]
    pub text: ::std::string::String,
}
impl ::std::convert::From<&CompletionsArguments> for CompletionsArguments {
    fn from(value: &CompletionsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`CompletionsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Returns a list of possible completions for a given caret position and text.\\nClients should only call this request if the corresponding capability `supportsCompletionsRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/CompletionsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"completions\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompletionsRequest {
    pub arguments: CompletionsArguments,
    pub command: CompletionsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: CompletionsRequestType,
}
impl ::std::convert::From<&CompletionsRequest> for CompletionsRequest {
    fn from(value: &CompletionsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`CompletionsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completions\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CompletionsRequestCommand {
    #[serde(rename = "completions")]
    Completions,
}
impl ::std::convert::From<&Self> for CompletionsRequestCommand {
    fn from(value: &CompletionsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CompletionsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completions => f.write_str("completions"),
        }
    }
}
impl ::std::str::FromStr for CompletionsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completions" => Ok(Self::Completions),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CompletionsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CompletionsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CompletionsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CompletionsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CompletionsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for CompletionsRequestType {
    fn from(value: &CompletionsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CompletionsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for CompletionsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CompletionsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CompletionsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CompletionsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CompletionsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `completions` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"targets\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"targets\": {"]
#[doc = "              \"description\": \"The possible completions for .\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/CompletionItem\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompletionsResponse {
    pub body: CompletionsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: CompletionsResponseType,
}
impl ::std::convert::From<&CompletionsResponse> for CompletionsResponse {
    fn from(value: &CompletionsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`CompletionsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"targets\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"targets\": {"]
#[doc = "      \"description\": \"The possible completions for .\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/CompletionItem\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompletionsResponseBody {
    #[doc = "The possible completions for ."]
    pub targets: ::std::vec::Vec<CompletionItem>,
}
impl ::std::convert::From<&CompletionsResponseBody> for CompletionsResponseBody {
    fn from(value: &CompletionsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`CompletionsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CompletionsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for CompletionsResponseType {
    fn from(value: &CompletionsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CompletionsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for CompletionsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CompletionsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CompletionsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CompletionsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `configurationDone` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `configurationDone` request.\","]
#[doc = "  \"type\": \"object\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ConfigurationDoneArguments(
    pub ::serde_json::Map<::std::string::String, ::serde_json::Value>,
);
impl ::std::ops::Deref for ConfigurationDoneArguments {
    type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
    fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
        &self.0
    }
}
impl ::std::convert::From<ConfigurationDoneArguments>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn from(value: ConfigurationDoneArguments) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ConfigurationDoneArguments> for ConfigurationDoneArguments {
    fn from(value: &ConfigurationDoneArguments) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for ConfigurationDoneArguments
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self(value)
    }
}
#[doc = "`ConfigurationDoneRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This request indicates that the client has finished initialization of the debug adapter.\\nSo it is the last request in the sequence of configuration requests (which was started by the `initialized` event).\\nClients should only call this request if the corresponding capability `supportsConfigurationDoneRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ConfigurationDoneArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"configurationDone\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ConfigurationDoneRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<ConfigurationDoneArguments>,
    pub command: ConfigurationDoneRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ConfigurationDoneRequestType,
}
impl ::std::convert::From<&ConfigurationDoneRequest> for ConfigurationDoneRequest {
    fn from(value: &ConfigurationDoneRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ConfigurationDoneRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"configurationDone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ConfigurationDoneRequestCommand {
    #[serde(rename = "configurationDone")]
    ConfigurationDone,
}
impl ::std::convert::From<&Self> for ConfigurationDoneRequestCommand {
    fn from(value: &ConfigurationDoneRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ConfigurationDoneRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ConfigurationDone => f.write_str("configurationDone"),
        }
    }
}
impl ::std::str::FromStr for ConfigurationDoneRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "configurationDone" => Ok(Self::ConfigurationDone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ConfigurationDoneRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ConfigurationDoneRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ConfigurationDoneRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ConfigurationDoneRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ConfigurationDoneRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ConfigurationDoneRequestType {
    fn from(value: &ConfigurationDoneRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ConfigurationDoneRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ConfigurationDoneRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ConfigurationDoneRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ConfigurationDoneRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ConfigurationDoneRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ConfigurationDoneResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `configurationDone` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ConfigurationDoneResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ConfigurationDoneResponseType,
}
impl ::std::convert::From<&ConfigurationDoneResponse> for ConfigurationDoneResponse {
    fn from(value: &ConfigurationDoneResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ConfigurationDoneResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ConfigurationDoneResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ConfigurationDoneResponseType {
    fn from(value: &ConfigurationDoneResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ConfigurationDoneResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ConfigurationDoneResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ConfigurationDoneResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ConfigurationDoneResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ConfigurationDoneResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `continue` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `continue` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, execution is resumed only for the thread with given `threadId`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the argument `singleThread` is true, only the thread with this ID is resumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinueArguments {
    #[doc = "If this flag is true, execution is resumed only for the thread with given `threadId`."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the argument `singleThread` is true, only the thread with this ID is resumed."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&ContinueArguments> for ContinueArguments {
    fn from(value: &ContinueArguments) -> Self {
        value.clone()
    }
}
#[doc = "`ContinueRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request resumes execution of all threads. If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true resumes only the specified thread. If not all threads were resumed, the `allThreadsContinued` attribute of the response should be set to false.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ContinueArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"continue\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinueRequest {
    pub arguments: ContinueArguments,
    pub command: ContinueRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ContinueRequestType,
}
impl ::std::convert::From<&ContinueRequest> for ContinueRequest {
    fn from(value: &ContinueRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ContinueRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"continue\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContinueRequestCommand {
    #[serde(rename = "continue")]
    Continue,
}
impl ::std::convert::From<&Self> for ContinueRequestCommand {
    fn from(value: &ContinueRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContinueRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Continue => f.write_str("continue"),
        }
    }
}
impl ::std::str::FromStr for ContinueRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "continue" => Ok(Self::Continue),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContinueRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContinueRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ContinueRequestType {
    fn from(value: &ContinueRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContinueRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ContinueRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContinueResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `continue` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"allThreadsContinued\": {"]
#[doc = "              \"description\": \"If omitted or set to `true`, this response signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinueResponse {
    pub body: ContinueResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ContinueResponseType,
}
impl ::std::convert::From<&ContinueResponse> for ContinueResponse {
    fn from(value: &ContinueResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ContinueResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"allThreadsContinued\": {"]
#[doc = "      \"description\": \"If omitted or set to `true`, this response signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinueResponseBody {
    #[doc = "If omitted or set to `true`, this response signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed."]
    #[serde(
        rename = "allThreadsContinued",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub all_threads_continued: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ContinueResponseBody> for ContinueResponseBody {
    fn from(value: &ContinueResponseBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ContinueResponseBody {
    fn default() -> Self {
        Self {
            all_threads_continued: Default::default(),
        }
    }
}
#[doc = "`ContinueResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContinueResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ContinueResponseType {
    fn from(value: &ContinueResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContinueResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ContinueResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContinuedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that the execution of the debuggee has continued.\\nPlease note: a debug adapter is not expected to send this event in response to a request that implies that execution continues, e.g. `launch` or `continue`.\\nIt is only necessary to send a `continued` event if there was no previous request that implied this.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"threadId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"allThreadsContinued\": {"]
#[doc = "              \"description\": \"If omitted or set to `true`, this event signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"threadId\": {"]
#[doc = "              \"description\": \"The thread which was continued.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"continued\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinuedEvent {
    pub body: ContinuedEventBody,
    pub event: ContinuedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ContinuedEventType,
}
impl ::std::convert::From<&ContinuedEvent> for ContinuedEvent {
    fn from(value: &ContinuedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ContinuedEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allThreadsContinued\": {"]
#[doc = "      \"description\": \"If omitted or set to `true`, this event signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"The thread which was continued.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContinuedEventBody {
    #[doc = "If omitted or set to `true`, this event signals to the client that all threads have been resumed. The value `false` indicates that not all threads were resumed."]
    #[serde(
        rename = "allThreadsContinued",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub all_threads_continued: ::std::option::Option<bool>,
    #[doc = "The thread which was continued."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&ContinuedEventBody> for ContinuedEventBody {
    fn from(value: &ContinuedEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ContinuedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"continued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContinuedEventEvent {
    #[serde(rename = "continued")]
    Continued,
}
impl ::std::convert::From<&Self> for ContinuedEventEvent {
    fn from(value: &ContinuedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContinuedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Continued => f.write_str("continued"),
        }
    }
}
impl ::std::str::FromStr for ContinuedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "continued" => Ok(Self::Continued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContinuedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContinuedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContinuedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContinuedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContinuedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ContinuedEventType {
    fn from(value: &ContinuedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContinuedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ContinuedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContinuedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContinuedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContinuedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Properties of a data breakpoint passed to the `setDataBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a data breakpoint passed to the `setDataBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"dataId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"accessType\": {"]
#[doc = "      \"description\": \"The access type of the data.\","]
#[doc = "      \"$ref\": \"#/definitions/DataBreakpointAccessType\""]
#[doc = "    },"]
#[doc = "    \"condition\": {"]
#[doc = "      \"description\": \"An expression for conditional breakpoints.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dataId\": {"]
#[doc = "      \"description\": \"An id representing the data. This id is returned from the `dataBreakpointInfo` request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hitCondition\": {"]
#[doc = "      \"description\": \"An expression that controls how many hits of the breakpoint are ignored.\\nThe debug adapter is expected to interpret the expression as needed.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataBreakpoint {
    #[doc = "The access type of the data."]
    #[serde(
        rename = "accessType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub access_type: ::std::option::Option<DataBreakpointAccessType>,
    #[doc = "An expression for conditional breakpoints."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<::std::string::String>,
    #[doc = "An id representing the data. This id is returned from the `dataBreakpointInfo` request."]
    #[serde(rename = "dataId")]
    pub data_id: ::std::string::String,
    #[doc = "An expression that controls how many hits of the breakpoint are ignored.\nThe debug adapter is expected to interpret the expression as needed."]
    #[serde(
        rename = "hitCondition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub hit_condition: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&DataBreakpoint> for DataBreakpoint {
    fn from(value: &DataBreakpoint) -> Self {
        value.clone()
    }
}
#[doc = "This enumeration defines all possible access types for data breakpoints."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This enumeration defines all possible access types for data breakpoints.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\","]
#[doc = "    \"readWrite\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataBreakpointAccessType {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
    #[serde(rename = "readWrite")]
    ReadWrite,
}
impl ::std::convert::From<&Self> for DataBreakpointAccessType {
    fn from(value: &DataBreakpointAccessType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataBreakpointAccessType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => f.write_str("read"),
            Self::Write => f.write_str("write"),
            Self::ReadWrite => f.write_str("readWrite"),
        }
    }
}
impl ::std::str::FromStr for DataBreakpointAccessType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            "readWrite" => Ok(Self::ReadWrite),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataBreakpointAccessType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataBreakpointAccessType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataBreakpointAccessType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `dataBreakpointInfo` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `dataBreakpointInfo` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"asAddress\": {"]
#[doc = "      \"description\": \"If `true`, the `name` is a memory address and the debugger should interpret it as a decimal value, or hex value if it is prefixed with `0x`.\\n\\nClients may set this property only if the `supportsDataBreakpointBytes`\\ncapability is true.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"bytes\": {"]
#[doc = "      \"description\": \"If specified, a debug adapter should return information for the range of memory extending `bytes` number of bytes from the address or variable specified by `name`. Breakpoints set using the resulting data ID should pause on data access anywhere within that range.\\n\\nClients may set this property only if the `supportsDataBreakpointBytes` capability is true.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"When `name` is an expression, evaluate it in the scope of this stack frame. If not specified, the expression is evaluated in the global scope. When `variablesReference` is specified, this property has no effect.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The mode of the desired breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the variable's child to obtain data breakpoint information for.\\nIf `variablesReference` isn't specified, this can be an expression, or an address if `asAddress` is also true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"Reference to the variable container if the data breakpoint is requested for a child of the container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataBreakpointInfoArguments {
    #[doc = "If `true`, the `name` is a memory address and the debugger should interpret it as a decimal value, or hex value if it is prefixed with `0x`.\n\nClients may set this property only if the `supportsDataBreakpointBytes`\ncapability is true."]
    #[serde(
        rename = "asAddress",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_address: ::std::option::Option<bool>,
    #[doc = "If specified, a debug adapter should return information for the range of memory extending `bytes` number of bytes from the address or variable specified by `name`. Breakpoints set using the resulting data ID should pause on data access anywhere within that range.\n\nClients may set this property only if the `supportsDataBreakpointBytes` capability is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bytes: ::std::option::Option<i64>,
    #[doc = "When `name` is an expression, evaluate it in the scope of this stack frame. If not specified, the expression is evaluated in the global scope. When `variablesReference` is specified, this property has no effect."]
    #[serde(
        rename = "frameId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub frame_id: ::std::option::Option<i64>,
    #[doc = "The mode of the desired breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the variable's child to obtain data breakpoint information for.\nIf `variablesReference` isn't specified, this can be an expression, or an address if `asAddress` is also true."]
    pub name: ::std::string::String,
    #[doc = "Reference to the variable container if the data breakpoint is requested for a child of the container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "variablesReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub variables_reference: ::std::option::Option<i64>,
}
impl ::std::convert::From<&DataBreakpointInfoArguments> for DataBreakpointInfoArguments {
    fn from(value: &DataBreakpointInfoArguments) -> Self {
        value.clone()
    }
}
#[doc = "`DataBreakpointInfoRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Obtains information on a possible data breakpoint that could be set on an expression or variable.\\nClients should only call this request if the corresponding capability `supportsDataBreakpoints` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/DataBreakpointInfoArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"dataBreakpointInfo\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataBreakpointInfoRequest {
    pub arguments: DataBreakpointInfoArguments,
    pub command: DataBreakpointInfoRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: DataBreakpointInfoRequestType,
}
impl ::std::convert::From<&DataBreakpointInfoRequest> for DataBreakpointInfoRequest {
    fn from(value: &DataBreakpointInfoRequest) -> Self {
        value.clone()
    }
}
#[doc = "`DataBreakpointInfoRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dataBreakpointInfo\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataBreakpointInfoRequestCommand {
    #[serde(rename = "dataBreakpointInfo")]
    DataBreakpointInfo,
}
impl ::std::convert::From<&Self> for DataBreakpointInfoRequestCommand {
    fn from(value: &DataBreakpointInfoRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataBreakpointInfoRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataBreakpointInfo => f.write_str("dataBreakpointInfo"),
        }
    }
}
impl ::std::str::FromStr for DataBreakpointInfoRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dataBreakpointInfo" => Ok(Self::DataBreakpointInfo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataBreakpointInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataBreakpointInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataBreakpointInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataBreakpointInfoRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataBreakpointInfoRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for DataBreakpointInfoRequestType {
    fn from(value: &DataBreakpointInfoRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataBreakpointInfoRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for DataBreakpointInfoRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataBreakpointInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataBreakpointInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataBreakpointInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataBreakpointInfoResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `dataBreakpointInfo` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"dataId\","]
#[doc = "            \"description\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"accessTypes\": {"]
#[doc = "              \"description\": \"Attribute lists the available access types for a potential data breakpoint. A UI client could surface this information.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/DataBreakpointAccessType\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"canPersist\": {"]
#[doc = "              \"description\": \"Attribute indicates that a potential data breakpoint could be persisted across sessions.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"dataId\": {"]
#[doc = "              \"description\": \"An identifier for the data on which a data breakpoint can be registered with the `setDataBreakpoints` request or null if no data breakpoint is available. If a `variablesReference` or `frameId` is passed, the `dataId` is valid in the current suspended state, otherwise it's valid indefinitely. See 'Lifetime of Object References' in the Overview section for details. Breakpoints set using the `dataId` in the `setDataBreakpoints` request may outlive the lifetime of the associated `dataId`.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataBreakpointInfoResponse {
    pub body: DataBreakpointInfoResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: DataBreakpointInfoResponseType,
}
impl ::std::convert::From<&DataBreakpointInfoResponse> for DataBreakpointInfoResponse {
    fn from(value: &DataBreakpointInfoResponse) -> Self {
        value.clone()
    }
}
#[doc = "`DataBreakpointInfoResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"dataId\","]
#[doc = "    \"description\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"accessTypes\": {"]
#[doc = "      \"description\": \"Attribute lists the available access types for a potential data breakpoint. A UI client could surface this information.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/DataBreakpointAccessType\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"canPersist\": {"]
#[doc = "      \"description\": \"Attribute indicates that a potential data breakpoint could be persisted across sessions.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"dataId\": {"]
#[doc = "      \"description\": \"An identifier for the data on which a data breakpoint can be registered with the `setDataBreakpoints` request or null if no data breakpoint is available. If a `variablesReference` or `frameId` is passed, the `dataId` is valid in the current suspended state, otherwise it's valid indefinitely. See 'Lifetime of Object References' in the Overview section for details. Breakpoints set using the `dataId` in the `setDataBreakpoints` request may outlive the lifetime of the associated `dataId`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataBreakpointInfoResponseBody {
    #[doc = "Attribute lists the available access types for a potential data breakpoint. A UI client could surface this information."]
    #[serde(
        rename = "accessTypes",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub access_types: ::std::vec::Vec<DataBreakpointAccessType>,
    #[doc = "Attribute indicates that a potential data breakpoint could be persisted across sessions."]
    #[serde(
        rename = "canPersist",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub can_persist: ::std::option::Option<bool>,
    #[doc = "An identifier for the data on which a data breakpoint can be registered with the `setDataBreakpoints` request or null if no data breakpoint is available. If a `variablesReference` or `frameId` is passed, the `dataId` is valid in the current suspended state, otherwise it's valid indefinitely. See 'Lifetime of Object References' in the Overview section for details. Breakpoints set using the `dataId` in the `setDataBreakpoints` request may outlive the lifetime of the associated `dataId`."]
    #[serde(rename = "dataId")]
    pub data_id: ::std::option::Option<::std::string::String>,
    #[doc = "UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available."]
    pub description: ::std::string::String,
}
impl ::std::convert::From<&DataBreakpointInfoResponseBody> for DataBreakpointInfoResponseBody {
    fn from(value: &DataBreakpointInfoResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`DataBreakpointInfoResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataBreakpointInfoResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for DataBreakpointInfoResponseType {
    fn from(value: &DataBreakpointInfoResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataBreakpointInfoResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for DataBreakpointInfoResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataBreakpointInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataBreakpointInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataBreakpointInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The Debug Adapter Protocol defines the protocol used between an editor or IDE and a debugger or runtime."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Debug Adapter Protocol\","]
#[doc = "  \"description\": \"The Debug Adapter Protocol defines the protocol used between an editor or IDE and a debugger or runtime.\","]
#[doc = "  \"type\": \"object\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct DebugAdapterProtocol(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
impl ::std::ops::Deref for DebugAdapterProtocol {
    type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
    fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
        &self.0
    }
}
impl ::std::convert::From<DebugAdapterProtocol>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn from(value: DebugAdapterProtocol) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DebugAdapterProtocol> for DebugAdapterProtocol {
    fn from(value: &DebugAdapterProtocol) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for DebugAdapterProtocol
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self(value)
    }
}
#[doc = "Arguments for `disassemble` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `disassemble` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"instructionCount\","]
#[doc = "    \"memoryReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"instructionCount\": {"]
#[doc = "      \"description\": \"Number of instructions to disassemble starting at the specified location and offset.\\nAn adapter must return exactly this number of instructions - any unavailable instructions should be replaced with an implementation-defined 'invalid instruction' value.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"instructionOffset\": {"]
#[doc = "      \"description\": \"Offset (in instructions) to be applied after the byte offset (if any) before disassembling. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"Memory reference to the base location containing the instructions to disassemble.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"Offset (in bytes) to be applied to the reference location before disassembling. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"resolveSymbols\": {"]
#[doc = "      \"description\": \"If true, the adapter should attempt to resolve memory addresses and other values to symbolic names.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisassembleArguments {
    #[doc = "Number of instructions to disassemble starting at the specified location and offset.\nAn adapter must return exactly this number of instructions - any unavailable instructions should be replaced with an implementation-defined 'invalid instruction' value."]
    #[serde(rename = "instructionCount")]
    pub instruction_count: i64,
    #[doc = "Offset (in instructions) to be applied after the byte offset (if any) before disassembling. Can be negative."]
    #[serde(
        rename = "instructionOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub instruction_offset: ::std::option::Option<i64>,
    #[doc = "Memory reference to the base location containing the instructions to disassemble."]
    #[serde(rename = "memoryReference")]
    pub memory_reference: ::std::string::String,
    #[doc = "Offset (in bytes) to be applied to the reference location before disassembling. Can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
    #[doc = "If true, the adapter should attempt to resolve memory addresses and other values to symbolic names."]
    #[serde(
        rename = "resolveSymbols",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub resolve_symbols: ::std::option::Option<bool>,
}
impl ::std::convert::From<&DisassembleArguments> for DisassembleArguments {
    fn from(value: &DisassembleArguments) -> Self {
        value.clone()
    }
}
#[doc = "`DisassembleRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Disassembles code stored at the provided location.\\nClients should only call this request if the corresponding capability `supportsDisassembleRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/DisassembleArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"disassemble\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisassembleRequest {
    pub arguments: DisassembleArguments,
    pub command: DisassembleRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: DisassembleRequestType,
}
impl ::std::convert::From<&DisassembleRequest> for DisassembleRequest {
    fn from(value: &DisassembleRequest) -> Self {
        value.clone()
    }
}
#[doc = "`DisassembleRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"disassemble\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisassembleRequestCommand {
    #[serde(rename = "disassemble")]
    Disassemble,
}
impl ::std::convert::From<&Self> for DisassembleRequestCommand {
    fn from(value: &DisassembleRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisassembleRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Disassemble => f.write_str("disassemble"),
        }
    }
}
impl ::std::str::FromStr for DisassembleRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "disassemble" => Ok(Self::Disassemble),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisassembleRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisassembleRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisassembleRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DisassembleRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisassembleRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for DisassembleRequestType {
    fn from(value: &DisassembleRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisassembleRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for DisassembleRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisassembleRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisassembleRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisassembleRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DisassembleResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `disassemble` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"instructions\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"instructions\": {"]
#[doc = "              \"description\": \"The list of disassembled instructions.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/DisassembledInstruction\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisassembleResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<DisassembleResponseBody>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: DisassembleResponseType,
}
impl ::std::convert::From<&DisassembleResponse> for DisassembleResponse {
    fn from(value: &DisassembleResponse) -> Self {
        value.clone()
    }
}
#[doc = "`DisassembleResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"instructions\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"instructions\": {"]
#[doc = "      \"description\": \"The list of disassembled instructions.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/DisassembledInstruction\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisassembleResponseBody {
    #[doc = "The list of disassembled instructions."]
    pub instructions: ::std::vec::Vec<DisassembledInstruction>,
}
impl ::std::convert::From<&DisassembleResponseBody> for DisassembleResponseBody {
    fn from(value: &DisassembleResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`DisassembleResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisassembleResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for DisassembleResponseType {
    fn from(value: &DisassembleResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisassembleResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for DisassembleResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisassembleResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisassembleResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisassembleResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Represents a single disassembled instruction."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Represents a single disassembled instruction.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"address\","]
#[doc = "    \"instruction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"address\": {"]
#[doc = "      \"description\": \"The address of the instruction. Treated as a hex value if prefixed with `0x`, or as a decimal value otherwise.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The column within the line that corresponds to this instruction, if any.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"The end column of the range that corresponds to this instruction, if any.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the range that corresponds to this instruction, if any.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"instruction\": {"]
#[doc = "      \"description\": \"Text representing the instruction and its operands, in an implementation-defined format.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"instructionBytes\": {"]
#[doc = "      \"description\": \"Raw bytes representing the instruction and its operands, in an implementation-defined format.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line within the source location that corresponds to this instruction, if any.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"location\": {"]
#[doc = "      \"description\": \"Source location that corresponds to this instruction, if any.\\nShould always be set (if available) on the first instruction returned,\\nbut can be omitted afterwards if this instruction maps to the same source file as the previous instruction.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"A hint for how to present the instruction in the UI.\\n\\nA value of `invalid` may be used to indicate this instruction is 'filler' and cannot be reached by the program. For example, unreadable memory addresses may be presented is 'invalid.'\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"normal\","]
#[doc = "        \"invalid\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"symbol\": {"]
#[doc = "      \"description\": \"Name of the symbol that corresponds with the location of this instruction, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisassembledInstruction {
    #[doc = "The address of the instruction. Treated as a hex value if prefixed with `0x`, or as a decimal value otherwise."]
    pub address: ::std::string::String,
    #[doc = "The column within the line that corresponds to this instruction, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The end column of the range that corresponds to this instruction, if any."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the range that corresponds to this instruction, if any."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "Text representing the instruction and its operands, in an implementation-defined format."]
    pub instruction: ::std::string::String,
    #[doc = "Raw bytes representing the instruction and its operands, in an implementation-defined format."]
    #[serde(
        rename = "instructionBytes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub instruction_bytes: ::std::option::Option<::std::string::String>,
    #[doc = "The line within the source location that corresponds to this instruction, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "Source location that corresponds to this instruction, if any.\nShould always be set (if available) on the first instruction returned,\nbut can be omitted afterwards if this instruction maps to the same source file as the previous instruction."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<Source>,
    #[doc = "A hint for how to present the instruction in the UI.\n\nA value of `invalid` may be used to indicate this instruction is 'filler' and cannot be reached by the program. For example, unreadable memory addresses may be presented is 'invalid.'"]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<DisassembledInstructionPresentationHint>,
    #[doc = "Name of the symbol that corresponds with the location of this instruction, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbol: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&DisassembledInstruction> for DisassembledInstruction {
    fn from(value: &DisassembledInstruction) -> Self {
        value.clone()
    }
}
#[doc = "A hint for how to present the instruction in the UI.\n\nA value of `invalid` may be used to indicate this instruction is 'filler' and cannot be reached by the program. For example, unreadable memory addresses may be presented is 'invalid.'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A hint for how to present the instruction in the UI.\\n\\nA value of `invalid` may be used to indicate this instruction is 'filler' and cannot be reached by the program. For example, unreadable memory addresses may be presented is 'invalid.'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"normal\","]
#[doc = "    \"invalid\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisassembledInstructionPresentationHint {
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "invalid")]
    Invalid,
}
impl ::std::convert::From<&Self> for DisassembledInstructionPresentationHint {
    fn from(value: &DisassembledInstructionPresentationHint) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisassembledInstructionPresentationHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Normal => f.write_str("normal"),
            Self::Invalid => f.write_str("invalid"),
        }
    }
}
impl ::std::str::FromStr for DisassembledInstructionPresentationHint {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "normal" => Ok(Self::Normal),
            "invalid" => Ok(Self::Invalid),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisassembledInstructionPresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisassembledInstructionPresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisassembledInstructionPresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `disconnect` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `disconnect` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"restart\": {"]
#[doc = "      \"description\": \"A value of true indicates that this `disconnect` request is part of a restart sequence.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"suspendDebuggee\": {"]
#[doc = "      \"description\": \"Indicates whether the debuggee should stay suspended when the debugger is disconnected.\\nIf unspecified, the debuggee should resume execution.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportSuspendDebuggee` is true.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"terminateDebuggee\": {"]
#[doc = "      \"description\": \"Indicates whether the debuggee should be terminated when the debugger is disconnected.\\nIf unspecified, the debug adapter is free to do whatever it thinks is best.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportTerminateDebuggee` is true.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisconnectArguments {
    #[doc = "A value of true indicates that this `disconnect` request is part of a restart sequence."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub restart: ::std::option::Option<bool>,
    #[doc = "Indicates whether the debuggee should stay suspended when the debugger is disconnected.\nIf unspecified, the debuggee should resume execution.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportSuspendDebuggee` is true."]
    #[serde(
        rename = "suspendDebuggee",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub suspend_debuggee: ::std::option::Option<bool>,
    #[doc = "Indicates whether the debuggee should be terminated when the debugger is disconnected.\nIf unspecified, the debug adapter is free to do whatever it thinks is best.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportTerminateDebuggee` is true."]
    #[serde(
        rename = "terminateDebuggee",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub terminate_debuggee: ::std::option::Option<bool>,
}
impl ::std::convert::From<&DisconnectArguments> for DisconnectArguments {
    fn from(value: &DisconnectArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DisconnectArguments {
    fn default() -> Self {
        Self {
            restart: Default::default(),
            suspend_debuggee: Default::default(),
            terminate_debuggee: Default::default(),
        }
    }
}
#[doc = "`DisconnectRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `disconnect` request asks the debug adapter to disconnect from the debuggee (thus ending the debug session) and then to shut down itself (the debug adapter).\\nIn addition, the debug adapter must terminate the debuggee if it was started with the `launch` request. If an `attach` request was used to connect to the debuggee, then the debug adapter must not terminate the debuggee.\\nThis implicit behavior of when to terminate the debuggee can be overridden with the `terminateDebuggee` argument (which is only supported by a debug adapter if the corresponding capability `supportTerminateDebuggee` is true).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/DisconnectArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"disconnect\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisconnectRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<DisconnectArguments>,
    pub command: DisconnectRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: DisconnectRequestType,
}
impl ::std::convert::From<&DisconnectRequest> for DisconnectRequest {
    fn from(value: &DisconnectRequest) -> Self {
        value.clone()
    }
}
#[doc = "`DisconnectRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"disconnect\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisconnectRequestCommand {
    #[serde(rename = "disconnect")]
    Disconnect,
}
impl ::std::convert::From<&Self> for DisconnectRequestCommand {
    fn from(value: &DisconnectRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisconnectRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Disconnect => f.write_str("disconnect"),
        }
    }
}
impl ::std::str::FromStr for DisconnectRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "disconnect" => Ok(Self::Disconnect),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisconnectRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisconnectRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisconnectRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DisconnectRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisconnectRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for DisconnectRequestType {
    fn from(value: &DisconnectRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisconnectRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for DisconnectRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisconnectRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisconnectRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisconnectRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DisconnectResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `disconnect` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DisconnectResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: DisconnectResponseType,
}
impl ::std::convert::From<&DisconnectResponse> for DisconnectResponse {
    fn from(value: &DisconnectResponse) -> Self {
        value.clone()
    }
}
#[doc = "`DisconnectResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DisconnectResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for DisconnectResponseType {
    fn from(value: &DisconnectResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DisconnectResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for DisconnectResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DisconnectResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DisconnectResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DisconnectResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ErrorResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"On error (whenever `success` is false), the body can provide more details.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"description\": \"A structured error message.\","]
#[doc = "              \"$ref\": \"#/definitions/Message\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ErrorResponse {
    pub body: ErrorResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ErrorResponseType,
}
impl ::std::convert::From<&ErrorResponse> for ErrorResponse {
    fn from(value: &ErrorResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ErrorResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"A structured error message.\","]
#[doc = "      \"$ref\": \"#/definitions/Message\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ErrorResponseBody {
    #[doc = "A structured error message."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub error: ::std::option::Option<Message>,
}
impl ::std::convert::From<&ErrorResponseBody> for ErrorResponseBody {
    fn from(value: &ErrorResponseBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ErrorResponseBody {
    fn default() -> Self {
        Self {
            error: Default::default(),
        }
    }
}
#[doc = "`ErrorResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ErrorResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ErrorResponseType {
    fn from(value: &ErrorResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ErrorResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ErrorResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ErrorResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ErrorResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ErrorResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `evaluate` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `evaluate` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expression\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The contextual column where the expression should be evaluated. This may be provided if `line` is also provided.\\n\\nIt is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"context\": {"]
#[doc = "      \"description\": \"The context in which the evaluate request is used.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"watch\","]
#[doc = "        \"repl\","]
#[doc = "        \"hover\","]
#[doc = "        \"clipboard\","]
#[doc = "        \"variables\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"evaluate is called from a watch view context.\","]
#[doc = "        \"evaluate is called from a REPL context.\","]
#[doc = "        \"evaluate is called to generate the debug hover contents.\\nThis value should only be used if the corresponding capability `supportsEvaluateForHovers` is true.\","]
#[doc = "        \"evaluate is called to generate clipboard contents.\\nThis value should only be used if the corresponding capability `supportsClipboardContext` is true.\","]
#[doc = "        \"evaluate is called from a variables view context.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"expression\": {"]
#[doc = "      \"description\": \"The expression to evaluate.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Specifies details on how to format the result.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.\","]
#[doc = "      \"$ref\": \"#/definitions/ValueFormat\""]
#[doc = "    },"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"Evaluate the expression in the scope of this stack frame. If not specified, the expression is evaluated in the global scope.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The contextual line where the expression should be evaluated. In the 'hover' context, this should be set to the start of the expression being hovered.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The contextual source in which the `line` is found. This must be provided if `line` is provided.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EvaluateArguments {
    #[doc = "The contextual column where the expression should be evaluated. This may be provided if `line` is also provided.\n\nIt is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The context in which the evaluate request is used."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub context: ::std::option::Option<::std::string::String>,
    #[doc = "The expression to evaluate."]
    pub expression: ::std::string::String,
    #[doc = "Specifies details on how to format the result.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<ValueFormat>,
    #[doc = "Evaluate the expression in the scope of this stack frame. If not specified, the expression is evaluated in the global scope."]
    #[serde(
        rename = "frameId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub frame_id: ::std::option::Option<i64>,
    #[doc = "The contextual line where the expression should be evaluated. In the 'hover' context, this should be set to the start of the expression being hovered."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "The contextual source in which the `line` is found. This must be provided if `line` is provided."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
}
impl ::std::convert::From<&EvaluateArguments> for EvaluateArguments {
    fn from(value: &EvaluateArguments) -> Self {
        value.clone()
    }
}
#[doc = "`EvaluateRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Evaluates the given expression in the context of a stack frame.\\nThe expression has access to any variables and arguments that are in scope.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/EvaluateArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"evaluate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EvaluateRequest {
    pub arguments: EvaluateArguments,
    pub command: EvaluateRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: EvaluateRequestType,
}
impl ::std::convert::From<&EvaluateRequest> for EvaluateRequest {
    fn from(value: &EvaluateRequest) -> Self {
        value.clone()
    }
}
#[doc = "`EvaluateRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"evaluate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateRequestCommand {
    #[serde(rename = "evaluate")]
    Evaluate,
}
impl ::std::convert::From<&Self> for EvaluateRequestCommand {
    fn from(value: &EvaluateRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Evaluate => f.write_str("evaluate"),
        }
    }
}
impl ::std::str::FromStr for EvaluateRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "evaluate" => Ok(Self::Evaluate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`EvaluateRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for EvaluateRequestType {
    fn from(value: &EvaluateRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for EvaluateRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`EvaluateResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `evaluate` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"result\","]
#[doc = "            \"variablesReference\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"indexedVariables\": {"]
#[doc = "              \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"memoryReference\": {"]
#[doc = "              \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"namedVariables\": {"]
#[doc = "              \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"presentationHint\": {"]
#[doc = "              \"description\": \"Properties of an evaluate result that can be used to determine how to render the result in the UI.\","]
#[doc = "              \"$ref\": \"#/definitions/VariablePresentationHint\""]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"description\": \"The result of the evaluate request.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"description\": \"The type of the evaluate result.\\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"valueLocationReference\": {"]
#[doc = "              \"description\": \"A reference that allows the client to request the location where the returned value is declared. For example, if a function pointer is returned, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"variablesReference\": {"]
#[doc = "              \"description\": \"If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EvaluateResponse {
    pub body: EvaluateResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: EvaluateResponseType,
}
impl ::std::convert::From<&EvaluateResponse> for EvaluateResponse {
    fn from(value: &EvaluateResponse) -> Self {
        value.clone()
    }
}
#[doc = "`EvaluateResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"result\","]
#[doc = "    \"variablesReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"indexedVariables\": {"]
#[doc = "      \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namedVariables\": {"]
#[doc = "      \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"Properties of an evaluate result that can be used to determine how to render the result in the UI.\","]
#[doc = "      \"$ref\": \"#/definitions/VariablePresentationHint\""]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"description\": \"The result of the evaluate request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"The type of the evaluate result.\\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"valueLocationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the returned value is declared. For example, if a function pointer is returned, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EvaluateResponseBody {
    #[doc = "The number of indexed child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "indexedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub indexed_variables: ::std::option::Option<i64>,
    #[doc = "A memory reference to a location appropriate for this result.\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true."]
    #[serde(
        rename = "memoryReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub memory_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The number of named child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "namedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub named_variables: ::std::option::Option<i64>,
    #[doc = "Properties of an evaluate result that can be used to determine how to render the result in the UI."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<VariablePresentationHint>,
    #[doc = "The result of the evaluate request."]
    pub result: ::std::string::String,
    #[doc = "The type of the evaluate result.\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[doc = "A reference that allows the client to request the location where the returned value is declared. For example, if a function pointer is returned, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "valueLocationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub value_location_reference: ::std::option::Option<i64>,
    #[doc = "If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
impl ::std::convert::From<&EvaluateResponseBody> for EvaluateResponseBody {
    fn from(value: &EvaluateResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`EvaluateResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for EvaluateResponseType {
    fn from(value: &EvaluateResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for EvaluateResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Event`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolMessage\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"A debug adapter initiated event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"event\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"Event-specific information.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"array\","]
#[doc = "            \"boolean\","]
#[doc = "            \"integer\","]
#[doc = "            \"null\","]
#[doc = "            \"number\","]
#[doc = "            \"object\","]
#[doc = "            \"string\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"description\": \"Type of event.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"event\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Event {
    #[doc = "Event-specific information."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "Type of event."]
    pub event: ::std::string::String,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: EventType,
}
impl ::std::convert::From<&Event> for Event {
    fn from(value: &Event) -> Self {
        value.clone()
    }
}
#[doc = "`EventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for EventType {
    fn from(value: &EventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for EventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "This enumeration defines all possible conditions when a thrown exception should result in a break.\nnever: never breaks,\nalways: always breaks,\nunhandled: breaks when exception unhandled,\nuserUnhandled: breaks if the exception is not handled by user code."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This enumeration defines all possible conditions when a thrown exception should result in a break.\\nnever: never breaks,\\nalways: always breaks,\\nunhandled: breaks when exception unhandled,\\nuserUnhandled: breaks if the exception is not handled by user code.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"never\","]
#[doc = "    \"always\","]
#[doc = "    \"unhandled\","]
#[doc = "    \"userUnhandled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExceptionBreakMode {
    #[serde(rename = "never")]
    Never,
    #[serde(rename = "always")]
    Always,
    #[serde(rename = "unhandled")]
    Unhandled,
    #[serde(rename = "userUnhandled")]
    UserUnhandled,
}
impl ::std::convert::From<&Self> for ExceptionBreakMode {
    fn from(value: &ExceptionBreakMode) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExceptionBreakMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Never => f.write_str("never"),
            Self::Always => f.write_str("always"),
            Self::Unhandled => f.write_str("unhandled"),
            Self::UserUnhandled => f.write_str("userUnhandled"),
        }
    }
}
impl ::std::str::FromStr for ExceptionBreakMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "never" => Ok(Self::Never),
            "always" => Ok(Self::Always),
            "unhandled" => Ok(Self::Unhandled),
            "userUnhandled" => Ok(Self::UserUnhandled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExceptionBreakMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExceptionBreakMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExceptionBreakMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "An `ExceptionBreakpointsFilter` is shown in the UI as an filter option for configuring how exceptions are dealt with."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An `ExceptionBreakpointsFilter` is shown in the UI as an filter option for configuring how exceptions are dealt with.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"filter\","]
#[doc = "    \"label\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"conditionDescription\": {"]
#[doc = "      \"description\": \"A help text providing information about the condition. This string is shown as the placeholder text for a text box and can be translated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"default\": {"]
#[doc = "      \"description\": \"Initial value of the filter option. If not specified a value false is assumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A help text providing additional information about the exception filter. This string is typically shown as a hover and can be translated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"filter\": {"]
#[doc = "      \"description\": \"The internal ID of the filter option. This value is passed to the `setExceptionBreakpoints` request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The name of the filter option. This is shown in the UI.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"supportsCondition\": {"]
#[doc = "      \"description\": \"Controls whether a condition can be specified for this filter option. If false or missing, a condition can not be set.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionBreakpointsFilter {
    #[doc = "A help text providing information about the condition. This string is shown as the placeholder text for a text box and can be translated."]
    #[serde(
        rename = "conditionDescription",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub condition_description: ::std::option::Option<::std::string::String>,
    #[doc = "Initial value of the filter option. If not specified a value false is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<bool>,
    #[doc = "A help text providing additional information about the exception filter. This string is typically shown as a hover and can be translated."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "The internal ID of the filter option. This value is passed to the `setExceptionBreakpoints` request."]
    pub filter: ::std::string::String,
    #[doc = "The name of the filter option. This is shown in the UI."]
    pub label: ::std::string::String,
    #[doc = "Controls whether a condition can be specified for this filter option. If false or missing, a condition can not be set."]
    #[serde(
        rename = "supportsCondition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_condition: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ExceptionBreakpointsFilter> for ExceptionBreakpointsFilter {
    fn from(value: &ExceptionBreakpointsFilter) -> Self {
        value.clone()
    }
}
#[doc = "Detailed information about an exception that has occurred."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Detailed information about an exception that has occurred.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"evaluateName\": {"]
#[doc = "      \"description\": \"An expression that can be evaluated in the current scope to obtain the exception object.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"fullTypeName\": {"]
#[doc = "      \"description\": \"Fully-qualified type name of the exception object.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"innerException\": {"]
#[doc = "      \"description\": \"Details of the exception contained by this exception, if any.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ExceptionDetails\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"Message contained in the exception.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stackTrace\": {"]
#[doc = "      \"description\": \"Stack trace at the time the exception was thrown.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"typeName\": {"]
#[doc = "      \"description\": \"Short type name of the exception object.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionDetails {
    #[doc = "An expression that can be evaluated in the current scope to obtain the exception object."]
    #[serde(
        rename = "evaluateName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub evaluate_name: ::std::option::Option<::std::string::String>,
    #[doc = "Fully-qualified type name of the exception object."]
    #[serde(
        rename = "fullTypeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub full_type_name: ::std::option::Option<::std::string::String>,
    #[doc = "Details of the exception contained by this exception, if any."]
    #[serde(
        rename = "innerException",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub inner_exception: ::std::vec::Vec<ExceptionDetails>,
    #[doc = "Message contained in the exception."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Stack trace at the time the exception was thrown."]
    #[serde(
        rename = "stackTrace",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stack_trace: ::std::option::Option<::std::string::String>,
    #[doc = "Short type name of the exception object."]
    #[serde(
        rename = "typeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ExceptionDetails> for ExceptionDetails {
    fn from(value: &ExceptionDetails) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ExceptionDetails {
    fn default() -> Self {
        Self {
            evaluate_name: Default::default(),
            full_type_name: Default::default(),
            inner_exception: Default::default(),
            message: Default::default(),
            stack_trace: Default::default(),
            type_name: Default::default(),
        }
    }
}
#[doc = "An `ExceptionFilterOptions` is used to specify an exception filter together with a condition for the `setExceptionBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An `ExceptionFilterOptions` is used to specify an exception filter together with a condition for the `setExceptionBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"filterId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"condition\": {"]
#[doc = "      \"description\": \"An expression for conditional exceptions.\\nThe exception breaks into the debugger if the result of the condition is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"filterId\": {"]
#[doc = "      \"description\": \"ID of an exception filter returned by the `exceptionBreakpointFilters` capability.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The mode of this exception breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionFilterOptions {
    #[doc = "An expression for conditional exceptions.\nThe exception breaks into the debugger if the result of the condition is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<::std::string::String>,
    #[doc = "ID of an exception filter returned by the `exceptionBreakpointFilters` capability."]
    #[serde(rename = "filterId")]
    pub filter_id: ::std::string::String,
    #[doc = "The mode of this exception breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ExceptionFilterOptions> for ExceptionFilterOptions {
    fn from(value: &ExceptionFilterOptions) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `exceptionInfo` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `exceptionInfo` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Thread for which exception information should be retrieved.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionInfoArguments {
    #[doc = "Thread for which exception information should be retrieved."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&ExceptionInfoArguments> for ExceptionInfoArguments {
    fn from(value: &ExceptionInfoArguments) -> Self {
        value.clone()
    }
}
#[doc = "`ExceptionInfoRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Retrieves the details of the exception that caused this event to be raised.\\nClients should only call this request if the corresponding capability `supportsExceptionInfoRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExceptionInfoArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"exceptionInfo\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionInfoRequest {
    pub arguments: ExceptionInfoArguments,
    pub command: ExceptionInfoRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ExceptionInfoRequestType,
}
impl ::std::convert::From<&ExceptionInfoRequest> for ExceptionInfoRequest {
    fn from(value: &ExceptionInfoRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ExceptionInfoRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"exceptionInfo\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExceptionInfoRequestCommand {
    #[serde(rename = "exceptionInfo")]
    ExceptionInfo,
}
impl ::std::convert::From<&Self> for ExceptionInfoRequestCommand {
    fn from(value: &ExceptionInfoRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExceptionInfoRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExceptionInfo => f.write_str("exceptionInfo"),
        }
    }
}
impl ::std::str::FromStr for ExceptionInfoRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "exceptionInfo" => Ok(Self::ExceptionInfo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExceptionInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExceptionInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExceptionInfoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ExceptionInfoRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExceptionInfoRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ExceptionInfoRequestType {
    fn from(value: &ExceptionInfoRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExceptionInfoRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ExceptionInfoRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExceptionInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExceptionInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExceptionInfoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ExceptionInfoResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `exceptionInfo` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakMode\","]
#[doc = "            \"exceptionId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakMode\": {"]
#[doc = "              \"description\": \"Mode that caused the exception notification to be raised.\","]
#[doc = "              \"$ref\": \"#/definitions/ExceptionBreakMode\""]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"Descriptive text for the exception.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"details\": {"]
#[doc = "              \"description\": \"Detailed information about the exception.\","]
#[doc = "              \"$ref\": \"#/definitions/ExceptionDetails\""]
#[doc = "            },"]
#[doc = "            \"exceptionId\": {"]
#[doc = "              \"description\": \"ID of the exception that was thrown.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionInfoResponse {
    pub body: ExceptionInfoResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ExceptionInfoResponseType,
}
impl ::std::convert::From<&ExceptionInfoResponse> for ExceptionInfoResponse {
    fn from(value: &ExceptionInfoResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ExceptionInfoResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakMode\","]
#[doc = "    \"exceptionId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakMode\": {"]
#[doc = "      \"description\": \"Mode that caused the exception notification to be raised.\","]
#[doc = "      \"$ref\": \"#/definitions/ExceptionBreakMode\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Descriptive text for the exception.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"details\": {"]
#[doc = "      \"description\": \"Detailed information about the exception.\","]
#[doc = "      \"$ref\": \"#/definitions/ExceptionDetails\""]
#[doc = "    },"]
#[doc = "    \"exceptionId\": {"]
#[doc = "      \"description\": \"ID of the exception that was thrown.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionInfoResponseBody {
    #[doc = "Mode that caused the exception notification to be raised."]
    #[serde(rename = "breakMode")]
    pub break_mode: ExceptionBreakMode,
    #[doc = "Descriptive text for the exception."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Detailed information about the exception."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub details: ::std::option::Option<ExceptionDetails>,
    #[doc = "ID of the exception that was thrown."]
    #[serde(rename = "exceptionId")]
    pub exception_id: ::std::string::String,
}
impl ::std::convert::From<&ExceptionInfoResponseBody> for ExceptionInfoResponseBody {
    fn from(value: &ExceptionInfoResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`ExceptionInfoResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExceptionInfoResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ExceptionInfoResponseType {
    fn from(value: &ExceptionInfoResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExceptionInfoResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ExceptionInfoResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExceptionInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExceptionInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExceptionInfoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "An `ExceptionOptions` assigns configuration options to a set of exceptions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An `ExceptionOptions` assigns configuration options to a set of exceptions.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakMode\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakMode\": {"]
#[doc = "      \"description\": \"Condition when a thrown exception should result in a break.\","]
#[doc = "      \"$ref\": \"#/definitions/ExceptionBreakMode\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"description\": \"A path that selects a single or multiple exceptions in a tree. If `path` is missing, the whole tree is selected.\\nBy convention the first segment of the path is a category that is used to group exceptions in the UI.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ExceptionPathSegment\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionOptions {
    #[doc = "Condition when a thrown exception should result in a break."]
    #[serde(rename = "breakMode")]
    pub break_mode: ExceptionBreakMode,
    #[doc = "A path that selects a single or multiple exceptions in a tree. If `path` is missing, the whole tree is selected.\nBy convention the first segment of the path is a category that is used to group exceptions in the UI."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub path: ::std::vec::Vec<ExceptionPathSegment>,
}
impl ::std::convert::From<&ExceptionOptions> for ExceptionOptions {
    fn from(value: &ExceptionOptions) -> Self {
        value.clone()
    }
}
#[doc = "An `ExceptionPathSegment` represents a segment in a path that is used to match leafs or nodes in a tree of exceptions.\nIf a segment consists of more than one name, it matches the names provided if `negate` is false or missing, or it matches anything except the names provided if `negate` is true."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An `ExceptionPathSegment` represents a segment in a path that is used to match leafs or nodes in a tree of exceptions.\\nIf a segment consists of more than one name, it matches the names provided if `negate` is false or missing, or it matches anything except the names provided if `negate` is true.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"names\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"names\": {"]
#[doc = "      \"description\": \"Depending on the value of `negate` the names that should match or not match.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"negate\": {"]
#[doc = "      \"description\": \"If false or missing this segment matches the names provided, otherwise it matches anything except the names provided.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExceptionPathSegment {
    #[doc = "Depending on the value of `negate` the names that should match or not match."]
    pub names: ::std::vec::Vec<::std::string::String>,
    #[doc = "If false or missing this segment matches the names provided, otherwise it matches anything except the names provided."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub negate: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ExceptionPathSegment> for ExceptionPathSegment {
    fn from(value: &ExceptionPathSegment) -> Self {
        value.clone()
    }
}
#[doc = "`ExitedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that the debuggee has exited and returns its exit code.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"exitCode\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"exitCode\": {"]
#[doc = "              \"description\": \"The exit code returned from the debuggee.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"exited\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExitedEvent {
    pub body: ExitedEventBody,
    pub event: ExitedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ExitedEventType,
}
impl ::std::convert::From<&ExitedEvent> for ExitedEvent {
    fn from(value: &ExitedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ExitedEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"exitCode\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"exitCode\": {"]
#[doc = "      \"description\": \"The exit code returned from the debuggee.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExitedEventBody {
    #[doc = "The exit code returned from the debuggee."]
    #[serde(rename = "exitCode")]
    pub exit_code: i64,
}
impl ::std::convert::From<&ExitedEventBody> for ExitedEventBody {
    fn from(value: &ExitedEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ExitedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"exited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExitedEventEvent {
    #[serde(rename = "exited")]
    Exited,
}
impl ::std::convert::From<&Self> for ExitedEventEvent {
    fn from(value: &ExitedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExitedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Exited => f.write_str("exited"),
        }
    }
}
impl ::std::str::FromStr for ExitedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "exited" => Ok(Self::Exited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExitedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExitedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExitedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ExitedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExitedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ExitedEventType {
    fn from(value: &ExitedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExitedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ExitedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExitedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExitedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExitedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Properties of a breakpoint passed to the `setFunctionBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a breakpoint passed to the `setFunctionBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"condition\": {"]
#[doc = "      \"description\": \"An expression for conditional breakpoints.\\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hitCondition\": {"]
#[doc = "      \"description\": \"An expression that controls how many hits of the breakpoint are ignored.\\nThe debug adapter is expected to interpret the expression as needed.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the function.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FunctionBreakpoint {
    #[doc = "An expression for conditional breakpoints.\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<::std::string::String>,
    #[doc = "An expression that controls how many hits of the breakpoint are ignored.\nThe debug adapter is expected to interpret the expression as needed.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true."]
    #[serde(
        rename = "hitCondition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub hit_condition: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the function."]
    pub name: ::std::string::String,
}
impl ::std::convert::From<&FunctionBreakpoint> for FunctionBreakpoint {
    fn from(value: &FunctionBreakpoint) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `goto` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `goto` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"targetId\","]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"targetId\": {"]
#[doc = "      \"description\": \"The location where the debuggee will continue to run.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Set the goto target for this thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoArguments {
    #[doc = "The location where the debuggee will continue to run."]
    #[serde(rename = "targetId")]
    pub target_id: i64,
    #[doc = "Set the goto target for this thread."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&GotoArguments> for GotoArguments {
    fn from(value: &GotoArguments) -> Self {
        value.clone()
    }
}
#[doc = "`GotoRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request sets the location where the debuggee will continue to run.\\nThis makes it possible to skip the execution of code or to execute code again.\\nThe code between the current location and the goto target is not executed but skipped.\\nThe debug adapter first sends the response and then a `stopped` event with reason `goto`.\\nClients should only call this request if the corresponding capability `supportsGotoTargetsRequest` is true (because only then goto targets exist that can be passed as arguments).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/GotoArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"goto\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoRequest {
    pub arguments: GotoArguments,
    pub command: GotoRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: GotoRequestType,
}
impl ::std::convert::From<&GotoRequest> for GotoRequest {
    fn from(value: &GotoRequest) -> Self {
        value.clone()
    }
}
#[doc = "`GotoRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"goto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoRequestCommand {
    #[serde(rename = "goto")]
    Goto,
}
impl ::std::convert::From<&Self> for GotoRequestCommand {
    fn from(value: &GotoRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Goto => f.write_str("goto"),
        }
    }
}
impl ::std::str::FromStr for GotoRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "goto" => Ok(Self::Goto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GotoRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for GotoRequestType {
    fn from(value: &GotoRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for GotoRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GotoResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `goto` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: GotoResponseType,
}
impl ::std::convert::From<&GotoResponse> for GotoResponse {
    fn from(value: &GotoResponse) -> Self {
        value.clone()
    }
}
#[doc = "`GotoResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for GotoResponseType {
    fn from(value: &GotoResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for GotoResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `GotoTarget` describes a code location that can be used as a target in the `goto` request.\nThe possible goto targets can be determined via the `gotoTargets` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `GotoTarget` describes a code location that can be used as a target in the `goto` request.\\nThe possible goto targets can be determined via the `gotoTargets` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"label\","]
#[doc = "    \"line\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The column of the goto target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"The end column of the range covered by the goto target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the range covered by the goto target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier for a goto target. This is used in the `goto` request.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"instructionPointerReference\": {"]
#[doc = "      \"description\": \"A memory reference for the instruction pointer value represented by this target.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The name of the goto target (shown in the UI).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line of the goto target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoTarget {
    #[doc = "The column of the goto target."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The end column of the range covered by the goto target."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the range covered by the goto target."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "Unique identifier for a goto target. This is used in the `goto` request."]
    pub id: i64,
    #[doc = "A memory reference for the instruction pointer value represented by this target."]
    #[serde(
        rename = "instructionPointerReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub instruction_pointer_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the goto target (shown in the UI)."]
    pub label: ::std::string::String,
    #[doc = "The line of the goto target."]
    pub line: i64,
}
impl ::std::convert::From<&GotoTarget> for GotoTarget {
    fn from(value: &GotoTarget) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `gotoTargets` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `gotoTargets` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"line\","]
#[doc = "    \"source\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The position within `line` for which the goto targets are determined. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line location for which the goto targets are determined.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source location for which the goto targets are determined.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoTargetsArguments {
    #[doc = "The position within `line` for which the goto targets are determined. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The line location for which the goto targets are determined."]
    pub line: i64,
    #[doc = "The source location for which the goto targets are determined."]
    pub source: Source,
}
impl ::std::convert::From<&GotoTargetsArguments> for GotoTargetsArguments {
    fn from(value: &GotoTargetsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`GotoTargetsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This request retrieves the possible goto targets for the specified source location.\\nThese targets can be used in the `goto` request.\\nClients should only call this request if the corresponding capability `supportsGotoTargetsRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/GotoTargetsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"gotoTargets\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoTargetsRequest {
    pub arguments: GotoTargetsArguments,
    pub command: GotoTargetsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: GotoTargetsRequestType,
}
impl ::std::convert::From<&GotoTargetsRequest> for GotoTargetsRequest {
    fn from(value: &GotoTargetsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`GotoTargetsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"gotoTargets\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoTargetsRequestCommand {
    #[serde(rename = "gotoTargets")]
    GotoTargets,
}
impl ::std::convert::From<&Self> for GotoTargetsRequestCommand {
    fn from(value: &GotoTargetsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoTargetsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GotoTargets => f.write_str("gotoTargets"),
        }
    }
}
impl ::std::str::FromStr for GotoTargetsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gotoTargets" => Ok(Self::GotoTargets),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GotoTargetsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoTargetsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for GotoTargetsRequestType {
    fn from(value: &GotoTargetsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoTargetsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for GotoTargetsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GotoTargetsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `gotoTargets` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"targets\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"targets\": {"]
#[doc = "              \"description\": \"The possible goto targets of the specified location.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/GotoTarget\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoTargetsResponse {
    pub body: GotoTargetsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: GotoTargetsResponseType,
}
impl ::std::convert::From<&GotoTargetsResponse> for GotoTargetsResponse {
    fn from(value: &GotoTargetsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`GotoTargetsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"targets\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"targets\": {"]
#[doc = "      \"description\": \"The possible goto targets of the specified location.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GotoTarget\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GotoTargetsResponseBody {
    #[doc = "The possible goto targets of the specified location."]
    pub targets: ::std::vec::Vec<GotoTarget>,
}
impl ::std::convert::From<&GotoTargetsResponseBody> for GotoTargetsResponseBody {
    fn from(value: &GotoTargetsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`GotoTargetsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GotoTargetsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for GotoTargetsResponseType {
    fn from(value: &GotoTargetsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GotoTargetsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for GotoTargetsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GotoTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GotoTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GotoTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InitializeRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Requests\","]
#[doc = "      \"description\": \"The `initialize` request is sent as the first request from the client to the debug adapter in order to configure it with client capabilities and to retrieve capabilities from the debug adapter.\\nUntil the debug adapter has responded with an `initialize` response, the client must not send any additional requests or events to the debug adapter.\\nIn addition the debug adapter is not allowed to send any requests or events to the client until it has responded with an `initialize` response.\\nThe `initialize` request may only be sent once.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/InitializeRequestArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"initialize\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeRequest {
    pub arguments: InitializeRequestArguments,
    pub command: InitializeRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: InitializeRequestType,
}
impl ::std::convert::From<&InitializeRequest> for InitializeRequest {
    fn from(value: &InitializeRequest) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `initialize` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `initialize` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"adapterID\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"adapterID\": {"]
#[doc = "      \"description\": \"The ID of the debug adapter.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"clientID\": {"]
#[doc = "      \"description\": \"The ID of the client using this adapter.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"clientName\": {"]
#[doc = "      \"description\": \"The human-readable name of the client using this adapter.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"columnsStartAt1\": {"]
#[doc = "      \"description\": \"If true all column numbers are 1-based (default).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"linesStartAt1\": {"]
#[doc = "      \"description\": \"If true all line numbers are 1-based (default).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"locale\": {"]
#[doc = "      \"description\": \"The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pathFormat\": {"]
#[doc = "      \"description\": \"Determines in what format paths are specified. The default is `path`, which is the native format.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"path\","]
#[doc = "        \"uri\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"supportsANSIStyling\": {"]
#[doc = "      \"description\": \"The client will interpret ANSI escape sequences in the display of `OutputEvent.output` and `Variable.value` fields when `Capabilities.supportsANSIStyling` is also enabled.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsArgsCanBeInterpretedByShell\": {"]
#[doc = "      \"description\": \"Client supports the `argsCanBeInterpretedByShell` attribute on the `runInTerminal` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsInvalidatedEvent\": {"]
#[doc = "      \"description\": \"Client supports the `invalidated` event.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsMemoryEvent\": {"]
#[doc = "      \"description\": \"Client supports the `memory` event.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsMemoryReferences\": {"]
#[doc = "      \"description\": \"Client supports memory references.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsProgressReporting\": {"]
#[doc = "      \"description\": \"Client supports progress reporting.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsRunInTerminalRequest\": {"]
#[doc = "      \"description\": \"Client supports the `runInTerminal` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsStartDebuggingRequest\": {"]
#[doc = "      \"description\": \"Client supports the `startDebugging` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsVariablePaging\": {"]
#[doc = "      \"description\": \"Client supports the paging of variables.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"supportsVariableType\": {"]
#[doc = "      \"description\": \"Client supports the `type` attribute for variables.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeRequestArguments {
    #[doc = "The ID of the debug adapter."]
    #[serde(rename = "adapterID")]
    pub adapter_id: ::std::string::String,
    #[doc = "The ID of the client using this adapter."]
    #[serde(
        rename = "clientID",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub client_id: ::std::option::Option<::std::string::String>,
    #[doc = "The human-readable name of the client using this adapter."]
    #[serde(
        rename = "clientName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub client_name: ::std::option::Option<::std::string::String>,
    #[doc = "If true all column numbers are 1-based (default)."]
    #[serde(
        rename = "columnsStartAt1",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub columns_start_at1: ::std::option::Option<bool>,
    #[doc = "If true all line numbers are 1-based (default)."]
    #[serde(
        rename = "linesStartAt1",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub lines_start_at1: ::std::option::Option<bool>,
    #[doc = "The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locale: ::std::option::Option<::std::string::String>,
    #[doc = "Determines in what format paths are specified. The default is `path`, which is the native format."]
    #[serde(
        rename = "pathFormat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub path_format: ::std::option::Option<::std::string::String>,
    #[doc = "The client will interpret ANSI escape sequences in the display of `OutputEvent.output` and `Variable.value` fields when `Capabilities.supportsANSIStyling` is also enabled."]
    #[serde(
        rename = "supportsANSIStyling",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_ansi_styling: ::std::option::Option<bool>,
    #[doc = "Client supports the `argsCanBeInterpretedByShell` attribute on the `runInTerminal` request."]
    #[serde(
        rename = "supportsArgsCanBeInterpretedByShell",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_args_can_be_interpreted_by_shell: ::std::option::Option<bool>,
    #[doc = "Client supports the `invalidated` event."]
    #[serde(
        rename = "supportsInvalidatedEvent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_invalidated_event: ::std::option::Option<bool>,
    #[doc = "Client supports the `memory` event."]
    #[serde(
        rename = "supportsMemoryEvent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_memory_event: ::std::option::Option<bool>,
    #[doc = "Client supports memory references."]
    #[serde(
        rename = "supportsMemoryReferences",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_memory_references: ::std::option::Option<bool>,
    #[doc = "Client supports progress reporting."]
    #[serde(
        rename = "supportsProgressReporting",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_progress_reporting: ::std::option::Option<bool>,
    #[doc = "Client supports the `runInTerminal` request."]
    #[serde(
        rename = "supportsRunInTerminalRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_run_in_terminal_request: ::std::option::Option<bool>,
    #[doc = "Client supports the `startDebugging` request."]
    #[serde(
        rename = "supportsStartDebuggingRequest",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_start_debugging_request: ::std::option::Option<bool>,
    #[doc = "Client supports the paging of variables."]
    #[serde(
        rename = "supportsVariablePaging",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_variable_paging: ::std::option::Option<bool>,
    #[doc = "Client supports the `type` attribute for variables."]
    #[serde(
        rename = "supportsVariableType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub supports_variable_type: ::std::option::Option<bool>,
}
impl ::std::convert::From<&InitializeRequestArguments> for InitializeRequestArguments {
    fn from(value: &InitializeRequestArguments) -> Self {
        value.clone()
    }
}
#[doc = "`InitializeRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"initialize\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InitializeRequestCommand {
    #[serde(rename = "initialize")]
    Initialize,
}
impl ::std::convert::From<&Self> for InitializeRequestCommand {
    fn from(value: &InitializeRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InitializeRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Initialize => f.write_str("initialize"),
        }
    }
}
impl ::std::str::FromStr for InitializeRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "initialize" => Ok(Self::Initialize),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InitializeRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InitializeRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InitializeRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InitializeRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InitializeRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for InitializeRequestType {
    fn from(value: &InitializeRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InitializeRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for InitializeRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InitializeRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InitializeRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InitializeRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InitializeResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `initialize` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"The capabilities of this debug adapter.\","]
#[doc = "          \"$ref\": \"#/definitions/Capabilities\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeResponse {
    #[doc = "The capabilities of this debug adapter."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<Capabilities>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: InitializeResponseType,
}
impl ::std::convert::From<&InitializeResponse> for InitializeResponse {
    fn from(value: &InitializeResponse) -> Self {
        value.clone()
    }
}
#[doc = "`InitializeResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InitializeResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for InitializeResponseType {
    fn from(value: &InitializeResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InitializeResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for InitializeResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InitializeResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InitializeResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InitializeResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InitializedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Events\","]
#[doc = "      \"description\": \"This event indicates that the debug adapter is ready to accept configuration requests (e.g. `setBreakpoints`, `setExceptionBreakpoints`).\\nA debug adapter is expected to send this event when it is ready to accept configuration requests (but not before the `initialize` request has finished).\\nThe sequence of events/requests is as follows:\\n- adapters sends `initialized` event (after the `initialize` request has returned)\\n- client sends zero or more `setBreakpoints` requests\\n- client sends one `setFunctionBreakpoints` request (if corresponding capability `supportsFunctionBreakpoints` is true)\\n- client sends a `setExceptionBreakpoints` request if one or more `exceptionBreakpointFilters` have been defined (or if `supportsConfigurationDoneRequest` is not true)\\n- client sends other future configuration requests\\n- client sends one `configurationDone` request to indicate the end of the configuration.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"initialized\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializedEvent {
    #[doc = "Event-specific information."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    pub event: InitializedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: InitializedEventType,
}
impl ::std::convert::From<&InitializedEvent> for InitializedEvent {
    fn from(value: &InitializedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`InitializedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"initialized\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InitializedEventEvent {
    #[serde(rename = "initialized")]
    Initialized,
}
impl ::std::convert::From<&Self> for InitializedEventEvent {
    fn from(value: &InitializedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InitializedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Initialized => f.write_str("initialized"),
        }
    }
}
impl ::std::str::FromStr for InitializedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "initialized" => Ok(Self::Initialized),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InitializedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InitializedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InitializedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InitializedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InitializedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for InitializedEventType {
    fn from(value: &InitializedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InitializedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for InitializedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InitializedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InitializedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InitializedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Properties of a breakpoint passed to the `setInstructionBreakpoints` request"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a breakpoint passed to the `setInstructionBreakpoints` request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"instructionReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"condition\": {"]
#[doc = "      \"description\": \"An expression for conditional breakpoints.\\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hitCondition\": {"]
#[doc = "      \"description\": \"An expression that controls how many hits of the breakpoint are ignored.\\nThe debug adapter is expected to interpret the expression as needed.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"instructionReference\": {"]
#[doc = "      \"description\": \"The instruction reference of the breakpoint.\\nThis should be a memory or instruction pointer reference from an `EvaluateResponse`, `Variable`, `StackFrame`, `GotoTarget`, or `Breakpoint`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The mode of this breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"The offset from the instruction reference in bytes.\\nThis can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InstructionBreakpoint {
    #[doc = "An expression for conditional breakpoints.\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<::std::string::String>,
    #[doc = "An expression that controls how many hits of the breakpoint are ignored.\nThe debug adapter is expected to interpret the expression as needed.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true."]
    #[serde(
        rename = "hitCondition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub hit_condition: ::std::option::Option<::std::string::String>,
    #[doc = "The instruction reference of the breakpoint.\nThis should be a memory or instruction pointer reference from an `EvaluateResponse`, `Variable`, `StackFrame`, `GotoTarget`, or `Breakpoint`."]
    #[serde(rename = "instructionReference")]
    pub instruction_reference: ::std::string::String,
    #[doc = "The mode of this breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<::std::string::String>,
    #[doc = "The offset from the instruction reference in bytes.\nThis can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
}
impl ::std::convert::From<&InstructionBreakpoint> for InstructionBreakpoint {
    fn from(value: &InstructionBreakpoint) -> Self {
        value.clone()
    }
}
#[doc = "Logical areas that can be invalidated by the `invalidated` event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Logical areas that can be invalidated by the `invalidated` event.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"_enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"stacks\","]
#[doc = "    \"threads\","]
#[doc = "    \"variables\""]
#[doc = "  ],"]
#[doc = "  \"enumDescriptions\": ["]
#[doc = "    \"All previously fetched data has become invalid and needs to be refetched.\","]
#[doc = "    \"Previously fetched stack related data has become invalid and needs to be refetched.\","]
#[doc = "    \"Previously fetched thread related data has become invalid and needs to be refetched.\","]
#[doc = "    \"Previously fetched variable data has become invalid and needs to be refetched.\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct InvalidatedAreas(pub ::std::string::String);
impl ::std::ops::Deref for InvalidatedAreas {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<InvalidatedAreas> for ::std::string::String {
    fn from(value: InvalidatedAreas) -> Self {
        value.0
    }
}
impl ::std::convert::From<&InvalidatedAreas> for InvalidatedAreas {
    fn from(value: &InvalidatedAreas) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for InvalidatedAreas {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for InvalidatedAreas {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for InvalidatedAreas {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`InvalidatedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This event signals that some state in the debug adapter has changed and requires that the client needs to re-render the data snapshot previously requested.\\nDebug adapters do not have to emit this event for runtime changes like stopped or thread events because in that case the client refetches the new state anyway. But the event can be used for example to refresh the UI after rendering formatting has changed in the debug adapter.\\nThis event should only be sent if the corresponding capability `supportsInvalidatedEvent` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"areas\": {"]
#[doc = "              \"description\": \"Set of logical areas that got invalidated. This property has a hint characteristic: a client can only be expected to make a 'best effort' in honoring the areas but there are no guarantees. If this property is missing, empty, or if values are not understood, the client should assume a single value `all`.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/InvalidatedAreas\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"stackFrameId\": {"]
#[doc = "              \"description\": \"If specified, the client only needs to refetch data related to this stack frame (and the `threadId` is ignored).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"threadId\": {"]
#[doc = "              \"description\": \"If specified, the client only needs to refetch data related to this thread.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"invalidated\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InvalidatedEvent {
    pub body: InvalidatedEventBody,
    pub event: InvalidatedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: InvalidatedEventType,
}
impl ::std::convert::From<&InvalidatedEvent> for InvalidatedEvent {
    fn from(value: &InvalidatedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`InvalidatedEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"areas\": {"]
#[doc = "      \"description\": \"Set of logical areas that got invalidated. This property has a hint characteristic: a client can only be expected to make a 'best effort' in honoring the areas but there are no guarantees. If this property is missing, empty, or if values are not understood, the client should assume a single value `all`.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/InvalidatedAreas\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"stackFrameId\": {"]
#[doc = "      \"description\": \"If specified, the client only needs to refetch data related to this stack frame (and the `threadId` is ignored).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"If specified, the client only needs to refetch data related to this thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InvalidatedEventBody {
    #[doc = "Set of logical areas that got invalidated. This property has a hint characteristic: a client can only be expected to make a 'best effort' in honoring the areas but there are no guarantees. If this property is missing, empty, or if values are not understood, the client should assume a single value `all`."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub areas: ::std::vec::Vec<InvalidatedAreas>,
    #[doc = "If specified, the client only needs to refetch data related to this stack frame (and the `threadId` is ignored)."]
    #[serde(
        rename = "stackFrameId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stack_frame_id: ::std::option::Option<i64>,
    #[doc = "If specified, the client only needs to refetch data related to this thread."]
    #[serde(
        rename = "threadId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub thread_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&InvalidatedEventBody> for InvalidatedEventBody {
    fn from(value: &InvalidatedEventBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InvalidatedEventBody {
    fn default() -> Self {
        Self {
            areas: Default::default(),
            stack_frame_id: Default::default(),
            thread_id: Default::default(),
        }
    }
}
#[doc = "`InvalidatedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"invalidated\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InvalidatedEventEvent {
    #[serde(rename = "invalidated")]
    Invalidated,
}
impl ::std::convert::From<&Self> for InvalidatedEventEvent {
    fn from(value: &InvalidatedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InvalidatedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Invalidated => f.write_str("invalidated"),
        }
    }
}
impl ::std::str::FromStr for InvalidatedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "invalidated" => Ok(Self::Invalidated),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InvalidatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InvalidatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InvalidatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InvalidatedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InvalidatedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for InvalidatedEventType {
    fn from(value: &InvalidatedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InvalidatedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for InvalidatedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InvalidatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InvalidatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InvalidatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LaunchRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This launch request is sent from the client to the debug adapter to start the debuggee with or without debugging (if `noDebug` is true).\\nSince launching is debugger/runtime specific, the arguments for this request are not part of this specification.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/LaunchRequestArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"launch\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LaunchRequest {
    pub arguments: LaunchRequestArguments,
    pub command: LaunchRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: LaunchRequestType,
}
impl ::std::convert::From<&LaunchRequest> for LaunchRequest {
    fn from(value: &LaunchRequest) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `launch` request. Additional attributes are implementation specific."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `launch` request. Additional attributes are implementation specific.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"__restart\": {"]
#[doc = "      \"description\": \"Arbitrary data from the previous, restarted session.\\nThe data is sent as the `restart` attribute of the `terminated` event.\\nThe client should leave the data intact.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"boolean\","]
#[doc = "        \"integer\","]
#[doc = "        \"null\","]
#[doc = "        \"number\","]
#[doc = "        \"object\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"noDebug\": {"]
#[doc = "      \"description\": \"If true, the launch request should launch the program without enabling debugging.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LaunchRequestArguments {
    #[doc = "If true, the launch request should launch the program without enabling debugging."]
    #[serde(
        rename = "noDebug",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub no_debug: ::std::option::Option<bool>,
    #[doc = "Arbitrary data from the previous, restarted session.\nThe data is sent as the `restart` attribute of the `terminated` event.\nThe client should leave the data intact."]
    #[serde(
        rename = "__restart",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub restart: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&LaunchRequestArguments> for LaunchRequestArguments {
    fn from(value: &LaunchRequestArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LaunchRequestArguments {
    fn default() -> Self {
        Self {
            no_debug: Default::default(),
            restart: Default::default(),
        }
    }
}
#[doc = "`LaunchRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"launch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LaunchRequestCommand {
    #[serde(rename = "launch")]
    Launch,
}
impl ::std::convert::From<&Self> for LaunchRequestCommand {
    fn from(value: &LaunchRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LaunchRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Launch => f.write_str("launch"),
        }
    }
}
impl ::std::str::FromStr for LaunchRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "launch" => Ok(Self::Launch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LaunchRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LaunchRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LaunchRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LaunchRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LaunchRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for LaunchRequestType {
    fn from(value: &LaunchRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LaunchRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for LaunchRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LaunchRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LaunchRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LaunchRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LaunchResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `launch` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LaunchResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: LaunchResponseType,
}
impl ::std::convert::From<&LaunchResponse> for LaunchResponse {
    fn from(value: &LaunchResponse) -> Self {
        value.clone()
    }
}
#[doc = "`LaunchResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LaunchResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for LaunchResponseType {
    fn from(value: &LaunchResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LaunchResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for LaunchResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LaunchResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LaunchResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LaunchResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoadedSourceEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that some source has been added, changed, or removed from the set of all loaded sources.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"reason\","]
#[doc = "            \"source\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"reason\": {"]
#[doc = "              \"description\": \"The reason for the event.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"new\","]
#[doc = "                \"changed\","]
#[doc = "                \"removed\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"source\": {"]
#[doc = "              \"description\": \"The new, changed, or removed source.\","]
#[doc = "              \"$ref\": \"#/definitions/Source\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"loadedSource\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoadedSourceEvent {
    pub body: LoadedSourceEventBody,
    pub event: LoadedSourceEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: LoadedSourceEventType,
}
impl ::std::convert::From<&LoadedSourceEvent> for LoadedSourceEvent {
    fn from(value: &LoadedSourceEvent) -> Self {
        value.clone()
    }
}
#[doc = "`LoadedSourceEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"reason\","]
#[doc = "    \"source\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"The reason for the event.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"new\","]
#[doc = "        \"changed\","]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The new, changed, or removed source.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoadedSourceEventBody {
    #[doc = "The reason for the event."]
    pub reason: LoadedSourceEventBodyReason,
    #[doc = "The new, changed, or removed source."]
    pub source: Source,
}
impl ::std::convert::From<&LoadedSourceEventBody> for LoadedSourceEventBody {
    fn from(value: &LoadedSourceEventBody) -> Self {
        value.clone()
    }
}
#[doc = "The reason for the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The reason for the event.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"new\","]
#[doc = "    \"changed\","]
#[doc = "    \"removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourceEventBodyReason {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "changed")]
    Changed,
    #[serde(rename = "removed")]
    Removed,
}
impl ::std::convert::From<&Self> for LoadedSourceEventBodyReason {
    fn from(value: &LoadedSourceEventBodyReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourceEventBodyReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::New => f.write_str("new"),
            Self::Changed => f.write_str("changed"),
            Self::Removed => f.write_str("removed"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourceEventBodyReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "new" => Ok(Self::New),
            "changed" => Ok(Self::Changed),
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourceEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourceEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourceEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoadedSourceEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"loadedSource\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourceEventEvent {
    #[serde(rename = "loadedSource")]
    LoadedSource,
}
impl ::std::convert::From<&Self> for LoadedSourceEventEvent {
    fn from(value: &LoadedSourceEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourceEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::LoadedSource => f.write_str("loadedSource"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourceEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "loadedSource" => Ok(Self::LoadedSource),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourceEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourceEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourceEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoadedSourceEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourceEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for LoadedSourceEventType {
    fn from(value: &LoadedSourceEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourceEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourceEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourceEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourceEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourceEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `loadedSources` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `loadedSources` request.\","]
#[doc = "  \"type\": \"object\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct LoadedSourcesArguments(
    pub ::serde_json::Map<::std::string::String, ::serde_json::Value>,
);
impl ::std::ops::Deref for LoadedSourcesArguments {
    type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
    fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
        &self.0
    }
}
impl ::std::convert::From<LoadedSourcesArguments>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn from(value: LoadedSourcesArguments) -> Self {
        value.0
    }
}
impl ::std::convert::From<&LoadedSourcesArguments> for LoadedSourcesArguments {
    fn from(value: &LoadedSourcesArguments) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for LoadedSourcesArguments
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self(value)
    }
}
#[doc = "`LoadedSourcesRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Retrieves the set of all sources currently loaded by the debugged process.\\nClients should only call this request if the corresponding capability `supportsLoadedSourcesRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/LoadedSourcesArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"loadedSources\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoadedSourcesRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<LoadedSourcesArguments>,
    pub command: LoadedSourcesRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: LoadedSourcesRequestType,
}
impl ::std::convert::From<&LoadedSourcesRequest> for LoadedSourcesRequest {
    fn from(value: &LoadedSourcesRequest) -> Self {
        value.clone()
    }
}
#[doc = "`LoadedSourcesRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"loadedSources\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourcesRequestCommand {
    #[serde(rename = "loadedSources")]
    LoadedSources,
}
impl ::std::convert::From<&Self> for LoadedSourcesRequestCommand {
    fn from(value: &LoadedSourcesRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourcesRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::LoadedSources => f.write_str("loadedSources"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourcesRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "loadedSources" => Ok(Self::LoadedSources),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourcesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourcesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourcesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoadedSourcesRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourcesRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for LoadedSourcesRequestType {
    fn from(value: &LoadedSourcesRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourcesRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourcesRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourcesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourcesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourcesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoadedSourcesResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `loadedSources` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sources\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sources\": {"]
#[doc = "              \"description\": \"Set of loaded sources.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Source\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoadedSourcesResponse {
    pub body: LoadedSourcesResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: LoadedSourcesResponseType,
}
impl ::std::convert::From<&LoadedSourcesResponse> for LoadedSourcesResponse {
    fn from(value: &LoadedSourcesResponse) -> Self {
        value.clone()
    }
}
#[doc = "`LoadedSourcesResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"sources\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"sources\": {"]
#[doc = "      \"description\": \"Set of loaded sources.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Source\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoadedSourcesResponseBody {
    #[doc = "Set of loaded sources."]
    pub sources: ::std::vec::Vec<Source>,
}
impl ::std::convert::From<&LoadedSourcesResponseBody> for LoadedSourcesResponseBody {
    fn from(value: &LoadedSourcesResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`LoadedSourcesResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoadedSourcesResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for LoadedSourcesResponseType {
    fn from(value: &LoadedSourcesResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoadedSourcesResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for LoadedSourcesResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoadedSourcesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoadedSourcesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoadedSourcesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `locations` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `locations` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"locationReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"locationReference\": {"]
#[doc = "      \"description\": \"Location reference to resolve.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LocationsArguments {
    #[doc = "Location reference to resolve."]
    #[serde(rename = "locationReference")]
    pub location_reference: i64,
}
impl ::std::convert::From<&LocationsArguments> for LocationsArguments {
    fn from(value: &LocationsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`LocationsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Looks up information about a location reference previously returned by the debug adapter.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/LocationsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"locations\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LocationsRequest {
    pub arguments: LocationsArguments,
    pub command: LocationsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: LocationsRequestType,
}
impl ::std::convert::From<&LocationsRequest> for LocationsRequest {
    fn from(value: &LocationsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`LocationsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"locations\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LocationsRequestCommand {
    #[serde(rename = "locations")]
    Locations,
}
impl ::std::convert::From<&Self> for LocationsRequestCommand {
    fn from(value: &LocationsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LocationsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Locations => f.write_str("locations"),
        }
    }
}
impl ::std::str::FromStr for LocationsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "locations" => Ok(Self::Locations),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LocationsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LocationsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LocationsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for LocationsRequestType {
    fn from(value: &LocationsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LocationsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for LocationsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LocationsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LocationsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `locations` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"line\","]
#[doc = "            \"source\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"column\": {"]
#[doc = "              \"description\": \"Position of the location within the `line`. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"endColumn\": {"]
#[doc = "              \"description\": \"End position of the location within `endLine`, present if the location refers to a range. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"endLine\": {"]
#[doc = "              \"description\": \"End line of the location, present if the location refers to a range.  The client capability `linesStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"line\": {"]
#[doc = "              \"description\": \"The line number of the location. The client capability `linesStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"source\": {"]
#[doc = "              \"description\": \"The source containing the location; either `source.path` or `source.sourceReference` must be specified.\","]
#[doc = "              \"$ref\": \"#/definitions/Source\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LocationsResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<LocationsResponseBody>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: LocationsResponseType,
}
impl ::std::convert::From<&LocationsResponse> for LocationsResponse {
    fn from(value: &LocationsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`LocationsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"line\","]
#[doc = "    \"source\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Position of the location within the `line`. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position of the location within `endLine`, present if the location refers to a range. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"End line of the location, present if the location refers to a range.  The client capability `linesStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line number of the location. The client capability `linesStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source containing the location; either `source.path` or `source.sourceReference` must be specified.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LocationsResponseBody {
    #[doc = "Position of the location within the `line`. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "End position of the location within `endLine`, present if the location refers to a range. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "End line of the location, present if the location refers to a range.  The client capability `linesStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "The line number of the location. The client capability `linesStartAt1` determines whether it is 0- or 1-based."]
    pub line: i64,
    #[doc = "The source containing the location; either `source.path` or `source.sourceReference` must be specified."]
    pub source: Source,
}
impl ::std::convert::From<&LocationsResponseBody> for LocationsResponseBody {
    fn from(value: &LocationsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`LocationsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LocationsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for LocationsResponseType {
    fn from(value: &LocationsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LocationsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for LocationsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LocationsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MemoryEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This event indicates that some memory range has been updated. It should only be sent if the corresponding capability `supportsMemoryEvent` is true.\\nClients typically react to the event by re-issuing a `readMemory` request if they show the memory identified by the `memoryReference` and if the updated memory range overlaps the displayed range. Clients should not make assumptions how individual memory references relate to each other, so they should not assume that they are part of a single continuous address range and might overlap.\\nDebug adapters can use this event to indicate that the contents of a memory range has changed due to some other request like `setVariable` or `setExpression`. Debug adapters are not expected to emit this event for each and every memory change of a running program, because that information is typically not available from debuggers and it would flood clients with too many events.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"count\","]
#[doc = "            \"memoryReference\","]
#[doc = "            \"offset\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"count\": {"]
#[doc = "              \"description\": \"Number of bytes updated.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"memoryReference\": {"]
#[doc = "              \"description\": \"Memory reference of a memory range that has been updated.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"offset\": {"]
#[doc = "              \"description\": \"Starting offset in bytes where memory has been updated. Can be negative.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"memory\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MemoryEvent {
    pub body: MemoryEventBody,
    pub event: MemoryEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: MemoryEventType,
}
impl ::std::convert::From<&MemoryEvent> for MemoryEvent {
    fn from(value: &MemoryEvent) -> Self {
        value.clone()
    }
}
#[doc = "`MemoryEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"count\","]
#[doc = "    \"memoryReference\","]
#[doc = "    \"offset\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"description\": \"Number of bytes updated.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"Memory reference of a memory range that has been updated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"Starting offset in bytes where memory has been updated. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MemoryEventBody {
    #[doc = "Number of bytes updated."]
    pub count: i64,
    #[doc = "Memory reference of a memory range that has been updated."]
    #[serde(rename = "memoryReference")]
    pub memory_reference: ::std::string::String,
    #[doc = "Starting offset in bytes where memory has been updated. Can be negative."]
    pub offset: i64,
}
impl ::std::convert::From<&MemoryEventBody> for MemoryEventBody {
    fn from(value: &MemoryEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`MemoryEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"memory\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemoryEventEvent {
    #[serde(rename = "memory")]
    Memory,
}
impl ::std::convert::From<&Self> for MemoryEventEvent {
    fn from(value: &MemoryEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemoryEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Memory => f.write_str("memory"),
        }
    }
}
impl ::std::str::FromStr for MemoryEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "memory" => Ok(Self::Memory),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemoryEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemoryEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemoryEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MemoryEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemoryEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for MemoryEventType {
    fn from(value: &MemoryEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemoryEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for MemoryEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemoryEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemoryEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemoryEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A structured message object. Used to return errors from requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A structured message object. Used to return errors from requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"format\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"A format string for the message. Embedded variables have the form `{name}`.\\nIf variable name starts with an underscore character, the variable does not contain user data (PII) and can be safely used for telemetry purposes.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique (within a debug adapter implementation) identifier for the message. The purpose of these error IDs is to help extension authors that have the requirement that every user visible error message needs a corresponding error number, so that users or customer support can find information about the specific error more easily.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"sendTelemetry\": {"]
#[doc = "      \"description\": \"If true send to telemetry.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"showUser\": {"]
#[doc = "      \"description\": \"If true show user.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"A url where additional information about this message can be found.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"urlLabel\": {"]
#[doc = "      \"description\": \"A label that is presented to the user as the UI for opening the url.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"variables\": {"]
#[doc = "      \"description\": \"An object used as a dictionary for looking up the variables in the format string.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"description\": \"All dictionary values must be strings.\","]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Message {
    #[doc = "A format string for the message. Embedded variables have the form `{name}`.\nIf variable name starts with an underscore character, the variable does not contain user data (PII) and can be safely used for telemetry purposes."]
    pub format: ::std::string::String,
    #[doc = "Unique (within a debug adapter implementation) identifier for the message. The purpose of these error IDs is to help extension authors that have the requirement that every user visible error message needs a corresponding error number, so that users or customer support can find information about the specific error more easily."]
    pub id: i64,
    #[doc = "If true send to telemetry."]
    #[serde(
        rename = "sendTelemetry",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub send_telemetry: ::std::option::Option<bool>,
    #[doc = "If true show user."]
    #[serde(
        rename = "showUser",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub show_user: ::std::option::Option<bool>,
    #[doc = "A url where additional information about this message can be found."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
    #[doc = "A label that is presented to the user as the UI for opening the url."]
    #[serde(
        rename = "urlLabel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub url_label: ::std::option::Option<::std::string::String>,
    #[doc = "An object used as a dictionary for looking up the variables in the format string."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub variables: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
}
impl ::std::convert::From<&Message> for Message {
    fn from(value: &Message) -> Self {
        value.clone()
    }
}
#[doc = "A Module object represents a row in the modules view.\nThe `id` attribute identifies a module in the modules view and is used in a `module` event for identifying a module for adding, updating or deleting.\nThe `name` attribute is used to minimally render the module in the UI.\n\nAdditional attributes can be added to the module. They show up in the module view if they have a corresponding `ColumnDescriptor`.\n\nTo avoid an unnecessary proliferation of additional attributes with similar semantics but different names, we recommend to re-use attributes from the 'recommended' list below first, and only introduce new attributes if nothing appropriate could be found."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A Module object represents a row in the modules view.\\nThe `id` attribute identifies a module in the modules view and is used in a `module` event for identifying a module for adding, updating or deleting.\\nThe `name` attribute is used to minimally render the module in the UI.\\n\\nAdditional attributes can be added to the module. They show up in the module view if they have a corresponding `ColumnDescriptor`.\\n\\nTo avoid an unnecessary proliferation of additional attributes with similar semantics but different names, we recommend to re-use attributes from the 'recommended' list below first, and only introduce new attributes if nothing appropriate could be found.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"addressRange\": {"]
#[doc = "      \"description\": \"Address range covered by this module.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dateTimeStamp\": {"]
#[doc = "      \"description\": \"Module created or modified, encoded as a RFC 3339 timestamp.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier for the module.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"isOptimized\": {"]
#[doc = "      \"description\": \"True if the module is optimized.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"isUserCode\": {"]
#[doc = "      \"description\": \"True if the module is considered 'user code' by a debugger that supports 'Just My Code'.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"A name of the module.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"description\": \"Logical full path to the module. The exact definition is implementation defined, but usually this would be a full path to the on-disk file for the module.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"symbolFilePath\": {"]
#[doc = "      \"description\": \"Logical full path to the symbol file. The exact definition is implementation defined.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"symbolStatus\": {"]
#[doc = "      \"description\": \"User-understandable description of if symbols were found for the module (ex: 'Symbols Loaded', 'Symbols not found', etc.)\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"Version of Module.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Module {
    #[doc = "Address range covered by this module."]
    #[serde(
        rename = "addressRange",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub address_range: ::std::option::Option<::std::string::String>,
    #[doc = "Module created or modified, encoded as a RFC 3339 timestamp."]
    #[serde(
        rename = "dateTimeStamp",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub date_time_stamp: ::std::option::Option<::std::string::String>,
    #[doc = "Unique identifier for the module."]
    pub id: ModuleId,
    #[doc = "True if the module is optimized."]
    #[serde(
        rename = "isOptimized",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_optimized: ::std::option::Option<bool>,
    #[doc = "True if the module is considered 'user code' by a debugger that supports 'Just My Code'."]
    #[serde(
        rename = "isUserCode",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_user_code: ::std::option::Option<bool>,
    #[doc = "A name of the module."]
    pub name: ::std::string::String,
    #[doc = "Logical full path to the module. The exact definition is implementation defined, but usually this would be a full path to the on-disk file for the module."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[doc = "Logical full path to the symbol file. The exact definition is implementation defined."]
    #[serde(
        rename = "symbolFilePath",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub symbol_file_path: ::std::option::Option<::std::string::String>,
    #[doc = "User-understandable description of if symbols were found for the module (ex: 'Symbols Loaded', 'Symbols not found', etc.)"]
    #[serde(
        rename = "symbolStatus",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub symbol_status: ::std::option::Option<::std::string::String>,
    #[doc = "Version of Module."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Module> for Module {
    fn from(value: &Module) -> Self {
        value.clone()
    }
}
#[doc = "`ModuleEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that some information about a module has changed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"module\","]
#[doc = "            \"reason\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"module\": {"]
#[doc = "              \"description\": \"The new, changed, or removed module. In case of `removed` only the module id is used.\","]
#[doc = "              \"$ref\": \"#/definitions/Module\""]
#[doc = "            },"]
#[doc = "            \"reason\": {"]
#[doc = "              \"description\": \"The reason for the event.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"new\","]
#[doc = "                \"changed\","]
#[doc = "                \"removed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"module\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModuleEvent {
    pub body: ModuleEventBody,
    pub event: ModuleEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ModuleEventType,
}
impl ::std::convert::From<&ModuleEvent> for ModuleEvent {
    fn from(value: &ModuleEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ModuleEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"module\","]
#[doc = "    \"reason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"module\": {"]
#[doc = "      \"description\": \"The new, changed, or removed module. In case of `removed` only the module id is used.\","]
#[doc = "      \"$ref\": \"#/definitions/Module\""]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"The reason for the event.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"new\","]
#[doc = "        \"changed\","]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModuleEventBody {
    #[doc = "The new, changed, or removed module. In case of `removed` only the module id is used."]
    pub module: Module,
    #[doc = "The reason for the event."]
    pub reason: ModuleEventBodyReason,
}
impl ::std::convert::From<&ModuleEventBody> for ModuleEventBody {
    fn from(value: &ModuleEventBody) -> Self {
        value.clone()
    }
}
#[doc = "The reason for the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The reason for the event.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"new\","]
#[doc = "    \"changed\","]
#[doc = "    \"removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModuleEventBodyReason {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "changed")]
    Changed,
    #[serde(rename = "removed")]
    Removed,
}
impl ::std::convert::From<&Self> for ModuleEventBodyReason {
    fn from(value: &ModuleEventBodyReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModuleEventBodyReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::New => f.write_str("new"),
            Self::Changed => f.write_str("changed"),
            Self::Removed => f.write_str("removed"),
        }
    }
}
impl ::std::str::FromStr for ModuleEventBodyReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "new" => Ok(Self::New),
            "changed" => Ok(Self::Changed),
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModuleEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModuleEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModuleEventBodyReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ModuleEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"module\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModuleEventEvent {
    #[serde(rename = "module")]
    Module,
}
impl ::std::convert::From<&Self> for ModuleEventEvent {
    fn from(value: &ModuleEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModuleEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Module => f.write_str("module"),
        }
    }
}
impl ::std::str::FromStr for ModuleEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "module" => Ok(Self::Module),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModuleEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModuleEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModuleEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ModuleEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModuleEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ModuleEventType {
    fn from(value: &ModuleEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModuleEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ModuleEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModuleEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModuleEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModuleEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Unique identifier for the module."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Unique identifier for the module.\","]
#[doc = "  \"type\": ["]
#[doc = "    \"integer\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ModuleId {
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for ModuleId {
    fn from(value: &ModuleId) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModuleId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::String(x) => x.fmt(f),
            Self::Integer(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for ModuleId {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
#[doc = "Arguments for `modules` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `modules` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"moduleCount\": {"]
#[doc = "      \"description\": \"The number of modules to return. If `moduleCount` is not specified or 0, all modules are returned.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"startModule\": {"]
#[doc = "      \"description\": \"The index of the first module to return; if omitted modules start at 0.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModulesArguments {
    #[doc = "The number of modules to return. If `moduleCount` is not specified or 0, all modules are returned."]
    #[serde(
        rename = "moduleCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub module_count: ::std::option::Option<i64>,
    #[doc = "The index of the first module to return; if omitted modules start at 0."]
    #[serde(
        rename = "startModule",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_module: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ModulesArguments> for ModulesArguments {
    fn from(value: &ModulesArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ModulesArguments {
    fn default() -> Self {
        Self {
            module_count: Default::default(),
            start_module: Default::default(),
        }
    }
}
#[doc = "`ModulesRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Modules can be retrieved from the debug adapter with this request which can either return all modules or a range of modules to support paging.\\nClients should only call this request if the corresponding capability `supportsModulesRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ModulesArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"modules\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModulesRequest {
    pub arguments: ModulesArguments,
    pub command: ModulesRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ModulesRequestType,
}
impl ::std::convert::From<&ModulesRequest> for ModulesRequest {
    fn from(value: &ModulesRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ModulesRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"modules\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModulesRequestCommand {
    #[serde(rename = "modules")]
    Modules,
}
impl ::std::convert::From<&Self> for ModulesRequestCommand {
    fn from(value: &ModulesRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModulesRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Modules => f.write_str("modules"),
        }
    }
}
impl ::std::str::FromStr for ModulesRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "modules" => Ok(Self::Modules),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModulesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModulesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModulesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ModulesRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModulesRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ModulesRequestType {
    fn from(value: &ModulesRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModulesRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ModulesRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModulesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModulesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModulesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ModulesResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `modules` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"modules\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"modules\": {"]
#[doc = "              \"description\": \"All modules or range of modules.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Module\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"totalModules\": {"]
#[doc = "              \"description\": \"The total number of modules available.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModulesResponse {
    pub body: ModulesResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ModulesResponseType,
}
impl ::std::convert::From<&ModulesResponse> for ModulesResponse {
    fn from(value: &ModulesResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ModulesResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"modules\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"modules\": {"]
#[doc = "      \"description\": \"All modules or range of modules.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Module\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"totalModules\": {"]
#[doc = "      \"description\": \"The total number of modules available.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModulesResponseBody {
    #[doc = "All modules or range of modules."]
    pub modules: ::std::vec::Vec<Module>,
    #[doc = "The total number of modules available."]
    #[serde(
        rename = "totalModules",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_modules: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ModulesResponseBody> for ModulesResponseBody {
    fn from(value: &ModulesResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`ModulesResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ModulesResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ModulesResponseType {
    fn from(value: &ModulesResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ModulesResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ModulesResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ModulesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ModulesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ModulesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `next` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `next` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"granularity\": {"]
#[doc = "      \"description\": \"Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.\","]
#[doc = "      \"$ref\": \"#/definitions/SteppingGranularity\""]
#[doc = "    },"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, all other suspended threads are not resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the thread for which to resume execution for one step (of the given granularity).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NextArguments {
    #[doc = "Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub granularity: ::std::option::Option<SteppingGranularity>,
    #[doc = "If this flag is true, all other suspended threads are not resumed."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Specifies the thread for which to resume execution for one step (of the given granularity)."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&NextArguments> for NextArguments {
    fn from(value: &NextArguments) -> Self {
        value.clone()
    }
}
#[doc = "`NextRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request executes one step (in the given granularity) for the specified thread and allows all other threads to run freely by resuming them.\\nIf the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true prevents other suspended threads from resuming.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `step`) after the step has completed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/NextArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"next\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NextRequest {
    pub arguments: NextArguments,
    pub command: NextRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: NextRequestType,
}
impl ::std::convert::From<&NextRequest> for NextRequest {
    fn from(value: &NextRequest) -> Self {
        value.clone()
    }
}
#[doc = "`NextRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"next\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextRequestCommand {
    #[serde(rename = "next")]
    Next,
}
impl ::std::convert::From<&Self> for NextRequestCommand {
    fn from(value: &NextRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Next => f.write_str("next"),
        }
    }
}
impl ::std::str::FromStr for NextRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "next" => Ok(Self::Next),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`NextRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for NextRequestType {
    fn from(value: &NextRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for NextRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`NextResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `next` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NextResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: NextResponseType,
}
impl ::std::convert::From<&NextResponse> for NextResponse {
    fn from(value: &NextResponse) -> Self {
        value.clone()
    }
}
#[doc = "`NextResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for NextResponseType {
    fn from(value: &NextResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for NextResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OutputEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that the target has produced some output.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"output\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"category\": {"]
#[doc = "              \"description\": \"The output category. If not specified or if the category is not understood by the client, `console` is assumed.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"_enum\": ["]
#[doc = "                \"console\","]
#[doc = "                \"important\","]
#[doc = "                \"stdout\","]
#[doc = "                \"stderr\","]
#[doc = "                \"telemetry\""]
#[doc = "              ],"]
#[doc = "              \"enumDescriptions\": ["]
#[doc = "                \"Show the output in the client's default message UI, e.g. a 'debug console'. This category should only be used for informational output from the debugger (as opposed to the debuggee).\","]
#[doc = "                \"A hint for the client to show the output in the client's UI for important and highly visible information, e.g. as a popup notification. This category should only be used for important messages from the debugger (as opposed to the debuggee). Since this category value is a hint, clients might ignore the hint and assume the `console` category.\","]
#[doc = "                \"Show the output as normal program output from the debuggee.\","]
#[doc = "                \"Show the output as error program output from the debuggee.\","]
#[doc = "                \"Send the output to telemetry instead of showing it to the user.\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"column\": {"]
#[doc = "              \"description\": \"The position in `line` where the output was produced. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"description\": \"Additional data to report. For the `telemetry` category the data is sent to telemetry, for the other categories the data is shown in JSON format.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"array\","]
#[doc = "                \"boolean\","]
#[doc = "                \"integer\","]
#[doc = "                \"null\","]
#[doc = "                \"number\","]
#[doc = "                \"object\","]
#[doc = "                \"string\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"group\": {"]
#[doc = "              \"description\": \"Support for keeping an output log organized by grouping related messages.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"startCollapsed\","]
#[doc = "                \"end\""]
#[doc = "              ],"]
#[doc = "              \"enumDescriptions\": ["]
#[doc = "                \"Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "                \"Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "                \"End the current group and decrease the indentation of subsequent output events.\\nA non-empty `output` attribute is shown as the unindented end of the group.\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"line\": {"]
#[doc = "              \"description\": \"The source location's line where the output was produced.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"locationReference\": {"]
#[doc = "              \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the logged value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"output\": {"]
#[doc = "              \"description\": \"The output to report.\\n\\nANSI escape sequences may be used to influence text color and styling if `supportsANSIStyling` is present in both the adapter's `Capabilities` and the client's `InitializeRequestArguments`. A client may strip any unrecognized ANSI sequences.\\n\\nIf the `supportsANSIStyling` capabilities are not both true, then the client should display the output literally.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"source\": {"]
#[doc = "              \"description\": \"The source location where the output was produced.\","]
#[doc = "              \"$ref\": \"#/definitions/Source\""]
#[doc = "            },"]
#[doc = "            \"variablesReference\": {"]
#[doc = "              \"description\": \"If an attribute `variablesReference` exists and its value is > 0, the output contains objects which can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"output\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OutputEvent {
    pub body: OutputEventBody,
    pub event: OutputEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: OutputEventType,
}
impl ::std::convert::From<&OutputEvent> for OutputEvent {
    fn from(value: &OutputEvent) -> Self {
        value.clone()
    }
}
#[doc = "`OutputEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"output\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"category\": {"]
#[doc = "      \"description\": \"The output category. If not specified or if the category is not understood by the client, `console` is assumed.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"console\","]
#[doc = "        \"important\","]
#[doc = "        \"stdout\","]
#[doc = "        \"stderr\","]
#[doc = "        \"telemetry\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"Show the output in the client's default message UI, e.g. a 'debug console'. This category should only be used for informational output from the debugger (as opposed to the debuggee).\","]
#[doc = "        \"A hint for the client to show the output in the client's UI for important and highly visible information, e.g. as a popup notification. This category should only be used for important messages from the debugger (as opposed to the debuggee). Since this category value is a hint, clients might ignore the hint and assume the `console` category.\","]
#[doc = "        \"Show the output as normal program output from the debuggee.\","]
#[doc = "        \"Show the output as error program output from the debuggee.\","]
#[doc = "        \"Send the output to telemetry instead of showing it to the user.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"The position in `line` where the output was produced. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"Additional data to report. For the `telemetry` category the data is sent to telemetry, for the other categories the data is shown in JSON format.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"boolean\","]
#[doc = "        \"integer\","]
#[doc = "        \"null\","]
#[doc = "        \"number\","]
#[doc = "        \"object\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"group\": {"]
#[doc = "      \"description\": \"Support for keeping an output log organized by grouping related messages.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"startCollapsed\","]
#[doc = "        \"end\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "        \"Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "        \"End the current group and decrease the indentation of subsequent output events.\\nA non-empty `output` attribute is shown as the unindented end of the group.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The source location's line where the output was produced.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"locationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the logged value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"description\": \"The output to report.\\n\\nANSI escape sequences may be used to influence text color and styling if `supportsANSIStyling` is present in both the adapter's `Capabilities` and the client's `InitializeRequestArguments`. A client may strip any unrecognized ANSI sequences.\\n\\nIf the `supportsANSIStyling` capabilities are not both true, then the client should display the output literally.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source location where the output was produced.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"If an attribute `variablesReference` exists and its value is > 0, the output contains objects which can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OutputEventBody {
    #[doc = "The output category. If not specified or if the category is not understood by the client, `console` is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub category: ::std::option::Option<::std::string::String>,
    #[doc = "The position in `line` where the output was produced. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "Additional data to report. For the `telemetry` category the data is sent to telemetry, for the other categories the data is shown in JSON format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::serde_json::Value>,
    #[doc = "Support for keeping an output log organized by grouping related messages."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub group: ::std::option::Option<OutputEventBodyGroup>,
    #[doc = "The source location's line where the output was produced."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "A reference that allows the client to request the location where the new value is declared. For example, if the logged value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "locationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub location_reference: ::std::option::Option<i64>,
    #[doc = "The output to report.\n\nANSI escape sequences may be used to influence text color and styling if `supportsANSIStyling` is present in both the adapter's `Capabilities` and the client's `InitializeRequestArguments`. A client may strip any unrecognized ANSI sequences.\n\nIf the `supportsANSIStyling` capabilities are not both true, then the client should display the output literally."]
    pub output: ::std::string::String,
    #[doc = "The source location where the output was produced."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
    #[doc = "If an attribute `variablesReference` exists and its value is > 0, the output contains objects which can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "variablesReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub variables_reference: ::std::option::Option<i64>,
}
impl ::std::convert::From<&OutputEventBody> for OutputEventBody {
    fn from(value: &OutputEventBody) -> Self {
        value.clone()
    }
}
#[doc = "Support for keeping an output log organized by grouping related messages."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Support for keeping an output log organized by grouping related messages.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"startCollapsed\","]
#[doc = "    \"end\""]
#[doc = "  ],"]
#[doc = "  \"enumDescriptions\": ["]
#[doc = "    \"Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "    \"Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).\\nThe `output` attribute becomes the name of the group and is not indented.\","]
#[doc = "    \"End the current group and decrease the indentation of subsequent output events.\\nA non-empty `output` attribute is shown as the unindented end of the group.\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OutputEventBodyGroup {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "startCollapsed")]
    StartCollapsed,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for OutputEventBodyGroup {
    fn from(value: &OutputEventBodyGroup) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OutputEventBodyGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => f.write_str("start"),
            Self::StartCollapsed => f.write_str("startCollapsed"),
            Self::End => f.write_str("end"),
        }
    }
}
impl ::std::str::FromStr for OutputEventBodyGroup {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "startCollapsed" => Ok(Self::StartCollapsed),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OutputEventBodyGroup {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OutputEventBodyGroup {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OutputEventBodyGroup {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OutputEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"output\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OutputEventEvent {
    #[serde(rename = "output")]
    Output,
}
impl ::std::convert::From<&Self> for OutputEventEvent {
    fn from(value: &OutputEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OutputEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Output => f.write_str("output"),
        }
    }
}
impl ::std::str::FromStr for OutputEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "output" => Ok(Self::Output),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OutputEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OutputEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OutputEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OutputEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OutputEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for OutputEventType {
    fn from(value: &OutputEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OutputEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for OutputEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OutputEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OutputEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OutputEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `pause` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `pause` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Pause execution for this thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PauseArguments {
    #[doc = "Pause execution for this thread."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&PauseArguments> for PauseArguments {
    fn from(value: &PauseArguments) -> Self {
        value.clone()
    }
}
#[doc = "`PauseRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request suspends the debuggee.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `pause`) after the thread has been paused successfully.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/PauseArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"pause\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PauseRequest {
    pub arguments: PauseArguments,
    pub command: PauseRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: PauseRequestType,
}
impl ::std::convert::From<&PauseRequest> for PauseRequest {
    fn from(value: &PauseRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PauseRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pause\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PauseRequestCommand {
    #[serde(rename = "pause")]
    Pause,
}
impl ::std::convert::From<&Self> for PauseRequestCommand {
    fn from(value: &PauseRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PauseRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pause => f.write_str("pause"),
        }
    }
}
impl ::std::str::FromStr for PauseRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pause" => Ok(Self::Pause),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PauseRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PauseRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PauseRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PauseRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PauseRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for PauseRequestType {
    fn from(value: &PauseRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PauseRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for PauseRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PauseRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PauseRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PauseRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PauseResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `pause` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PauseResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: PauseResponseType,
}
impl ::std::convert::From<&PauseResponse> for PauseResponse {
    fn from(value: &PauseResponse) -> Self {
        value.clone()
    }
}
#[doc = "`PauseResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PauseResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for PauseResponseType {
    fn from(value: &PauseResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PauseResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for PauseResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PauseResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PauseResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PauseResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProcessEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that the debugger has begun debugging a new process. Either one that it has launched, or one that it has attached to.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"isLocalProcess\": {"]
#[doc = "              \"description\": \"If true, the process is running on the same computer as the debug adapter.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"pointerSize\": {"]
#[doc = "              \"description\": \"The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"startMethod\": {"]
#[doc = "              \"description\": \"Describes how the debug engine started debugging this process.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"launch\","]
#[doc = "                \"attach\","]
#[doc = "                \"attachForSuspendedLaunch\""]
#[doc = "              ],"]
#[doc = "              \"enumDescriptions\": ["]
#[doc = "                \"Process was launched under the debugger.\","]
#[doc = "                \"Debugger attached to an existing process.\","]
#[doc = "                \"A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"systemProcessId\": {"]
#[doc = "              \"description\": \"The process ID of the debugged process, as assigned by the operating system. This property should be omitted for logical processes that do not map to operating system processes on the machine.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"process\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProcessEvent {
    pub body: ProcessEventBody,
    pub event: ProcessEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ProcessEventType,
}
impl ::std::convert::From<&ProcessEvent> for ProcessEvent {
    fn from(value: &ProcessEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ProcessEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"isLocalProcess\": {"]
#[doc = "      \"description\": \"If true, the process is running on the same computer as the debug adapter.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pointerSize\": {"]
#[doc = "      \"description\": \"The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"startMethod\": {"]
#[doc = "      \"description\": \"Describes how the debug engine started debugging this process.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"launch\","]
#[doc = "        \"attach\","]
#[doc = "        \"attachForSuspendedLaunch\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"Process was launched under the debugger.\","]
#[doc = "        \"Debugger attached to an existing process.\","]
#[doc = "        \"A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"systemProcessId\": {"]
#[doc = "      \"description\": \"The process ID of the debugged process, as assigned by the operating system. This property should be omitted for logical processes that do not map to operating system processes on the machine.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProcessEventBody {
    #[doc = "If true, the process is running on the same computer as the debug adapter."]
    #[serde(
        rename = "isLocalProcess",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_local_process: ::std::option::Option<bool>,
    #[doc = "The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js."]
    pub name: ::std::string::String,
    #[doc = "The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display."]
    #[serde(
        rename = "pointerSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pointer_size: ::std::option::Option<i64>,
    #[doc = "Describes how the debug engine started debugging this process."]
    #[serde(
        rename = "startMethod",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_method: ::std::option::Option<ProcessEventBodyStartMethod>,
    #[doc = "The process ID of the debugged process, as assigned by the operating system. This property should be omitted for logical processes that do not map to operating system processes on the machine."]
    #[serde(
        rename = "systemProcessId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub system_process_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ProcessEventBody> for ProcessEventBody {
    fn from(value: &ProcessEventBody) -> Self {
        value.clone()
    }
}
#[doc = "Describes how the debug engine started debugging this process."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes how the debug engine started debugging this process.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"launch\","]
#[doc = "    \"attach\","]
#[doc = "    \"attachForSuspendedLaunch\""]
#[doc = "  ],"]
#[doc = "  \"enumDescriptions\": ["]
#[doc = "    \"Process was launched under the debugger.\","]
#[doc = "    \"Debugger attached to an existing process.\","]
#[doc = "    \"A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProcessEventBodyStartMethod {
    #[serde(rename = "launch")]
    Launch,
    #[serde(rename = "attach")]
    Attach,
    #[serde(rename = "attachForSuspendedLaunch")]
    AttachForSuspendedLaunch,
}
impl ::std::convert::From<&Self> for ProcessEventBodyStartMethod {
    fn from(value: &ProcessEventBodyStartMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProcessEventBodyStartMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Launch => f.write_str("launch"),
            Self::Attach => f.write_str("attach"),
            Self::AttachForSuspendedLaunch => f.write_str("attachForSuspendedLaunch"),
        }
    }
}
impl ::std::str::FromStr for ProcessEventBodyStartMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "launch" => Ok(Self::Launch),
            "attach" => Ok(Self::Attach),
            "attachForSuspendedLaunch" => Ok(Self::AttachForSuspendedLaunch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProcessEventBodyStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProcessEventBodyStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProcessEventBodyStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProcessEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"process\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProcessEventEvent {
    #[serde(rename = "process")]
    Process,
}
impl ::std::convert::From<&Self> for ProcessEventEvent {
    fn from(value: &ProcessEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProcessEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Process => f.write_str("process"),
        }
    }
}
impl ::std::str::FromStr for ProcessEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "process" => Ok(Self::Process),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProcessEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProcessEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProcessEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProcessEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProcessEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ProcessEventType {
    fn from(value: &ProcessEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProcessEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ProcessEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProcessEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProcessEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProcessEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressEndEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event signals the end of the progress reporting with a final message.\\nThis event should only be sent if the corresponding capability `supportsProgressReporting` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"progressId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"message\": {"]
#[doc = "              \"description\": \"More detailed progress message. If omitted, the previous message (if any) is used.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"progressId\": {"]
#[doc = "              \"description\": \"The ID that was introduced in the initial `ProgressStartEvent`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"progressEnd\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressEndEvent {
    pub body: ProgressEndEventBody,
    pub event: ProgressEndEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ProgressEndEventType,
}
impl ::std::convert::From<&ProgressEndEvent> for ProgressEndEvent {
    fn from(value: &ProgressEndEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressEndEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"progressId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"More detailed progress message. If omitted, the previous message (if any) is used.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"progressId\": {"]
#[doc = "      \"description\": \"The ID that was introduced in the initial `ProgressStartEvent`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressEndEventBody {
    #[doc = "More detailed progress message. If omitted, the previous message (if any) is used."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "The ID that was introduced in the initial `ProgressStartEvent`."]
    #[serde(rename = "progressId")]
    pub progress_id: ::std::string::String,
}
impl ::std::convert::From<&ProgressEndEventBody> for ProgressEndEventBody {
    fn from(value: &ProgressEndEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressEndEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"progressEnd\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressEndEventEvent {
    #[serde(rename = "progressEnd")]
    ProgressEnd,
}
impl ::std::convert::From<&Self> for ProgressEndEventEvent {
    fn from(value: &ProgressEndEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressEndEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ProgressEnd => f.write_str("progressEnd"),
        }
    }
}
impl ::std::str::FromStr for ProgressEndEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "progressEnd" => Ok(Self::ProgressEnd),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressEndEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressEndEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressEndEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressEndEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressEndEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ProgressEndEventType {
    fn from(value: &ProgressEndEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressEndEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ProgressEndEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressEndEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressEndEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressEndEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressStartEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event signals that a long running operation is about to start and provides additional information for the client to set up a corresponding progress and cancellation UI.\\nThe client is free to delay the showing of the UI in order to reduce flicker.\\nThis event should only be sent if the corresponding capability `supportsProgressReporting` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"progressId\","]
#[doc = "            \"title\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"cancellable\": {"]
#[doc = "              \"description\": \"If true, the request that reports progress may be cancelled with a `cancel` request.\\nSo this property basically controls whether the client should use UX that supports cancellation.\\nClients that don't support cancellation are allowed to ignore the setting.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"description\": \"More detailed progress message.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"percentage\": {"]
#[doc = "              \"description\": \"Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.\","]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"progressId\": {"]
#[doc = "              \"description\": \"An ID that can be used in subsequent `progressUpdate` and `progressEnd` events to make them refer to the same progress reporting.\\nIDs must be unique within a debug session.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"requestId\": {"]
#[doc = "              \"description\": \"The request ID that this progress report is related to. If specified a debug adapter is expected to emit progress events for the long running request until the request has been either completed or cancelled.\\nIf the request ID is omitted, the progress report is assumed to be related to some general activity of the debug adapter.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"description\": \"Short title of the progress reporting. Shown in the UI to describe the long running operation.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"progressStart\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressStartEvent {
    pub body: ProgressStartEventBody,
    pub event: ProgressStartEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ProgressStartEventType,
}
impl ::std::convert::From<&ProgressStartEvent> for ProgressStartEvent {
    fn from(value: &ProgressStartEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressStartEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"progressId\","]
#[doc = "    \"title\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cancellable\": {"]
#[doc = "      \"description\": \"If true, the request that reports progress may be cancelled with a `cancel` request.\\nSo this property basically controls whether the client should use UX that supports cancellation.\\nClients that don't support cancellation are allowed to ignore the setting.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"More detailed progress message.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"percentage\": {"]
#[doc = "      \"description\": \"Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"progressId\": {"]
#[doc = "      \"description\": \"An ID that can be used in subsequent `progressUpdate` and `progressEnd` events to make them refer to the same progress reporting.\\nIDs must be unique within a debug session.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"requestId\": {"]
#[doc = "      \"description\": \"The request ID that this progress report is related to. If specified a debug adapter is expected to emit progress events for the long running request until the request has been either completed or cancelled.\\nIf the request ID is omitted, the progress report is assumed to be related to some general activity of the debug adapter.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Short title of the progress reporting. Shown in the UI to describe the long running operation.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressStartEventBody {
    #[doc = "If true, the request that reports progress may be cancelled with a `cancel` request.\nSo this property basically controls whether the client should use UX that supports cancellation.\nClients that don't support cancellation are allowed to ignore the setting."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cancellable: ::std::option::Option<bool>,
    #[doc = "More detailed progress message."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub percentage: ::std::option::Option<f64>,
    #[doc = "An ID that can be used in subsequent `progressUpdate` and `progressEnd` events to make them refer to the same progress reporting.\nIDs must be unique within a debug session."]
    #[serde(rename = "progressId")]
    pub progress_id: ::std::string::String,
    #[doc = "The request ID that this progress report is related to. If specified a debug adapter is expected to emit progress events for the long running request until the request has been either completed or cancelled.\nIf the request ID is omitted, the progress report is assumed to be related to some general activity of the debug adapter."]
    #[serde(
        rename = "requestId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub request_id: ::std::option::Option<i64>,
    #[doc = "Short title of the progress reporting. Shown in the UI to describe the long running operation."]
    pub title: ::std::string::String,
}
impl ::std::convert::From<&ProgressStartEventBody> for ProgressStartEventBody {
    fn from(value: &ProgressStartEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressStartEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"progressStart\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressStartEventEvent {
    #[serde(rename = "progressStart")]
    ProgressStart,
}
impl ::std::convert::From<&Self> for ProgressStartEventEvent {
    fn from(value: &ProgressStartEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressStartEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ProgressStart => f.write_str("progressStart"),
        }
    }
}
impl ::std::str::FromStr for ProgressStartEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "progressStart" => Ok(Self::ProgressStart),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressStartEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressStartEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressStartEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressStartEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressStartEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ProgressStartEventType {
    fn from(value: &ProgressStartEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressStartEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ProgressStartEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressStartEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressStartEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressStartEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressUpdateEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event signals that the progress reporting needs to be updated with a new message and/or percentage.\\nThe client does not have to update the UI immediately, but the clients needs to keep track of the message and/or percentage values.\\nThis event should only be sent if the corresponding capability `supportsProgressReporting` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"progressId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"message\": {"]
#[doc = "              \"description\": \"More detailed progress message. If omitted, the previous message (if any) is used.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"percentage\": {"]
#[doc = "              \"description\": \"Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.\","]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"progressId\": {"]
#[doc = "              \"description\": \"The ID that was introduced in the initial `progressStart` event.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"progressUpdate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressUpdateEvent {
    pub body: ProgressUpdateEventBody,
    pub event: ProgressUpdateEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ProgressUpdateEventType,
}
impl ::std::convert::From<&ProgressUpdateEvent> for ProgressUpdateEvent {
    fn from(value: &ProgressUpdateEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressUpdateEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"progressId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"More detailed progress message. If omitted, the previous message (if any) is used.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"percentage\": {"]
#[doc = "      \"description\": \"Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"progressId\": {"]
#[doc = "      \"description\": \"The ID that was introduced in the initial `progressStart` event.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressUpdateEventBody {
    #[doc = "More detailed progress message. If omitted, the previous message (if any) is used."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub percentage: ::std::option::Option<f64>,
    #[doc = "The ID that was introduced in the initial `progressStart` event."]
    #[serde(rename = "progressId")]
    pub progress_id: ::std::string::String,
}
impl ::std::convert::From<&ProgressUpdateEventBody> for ProgressUpdateEventBody {
    fn from(value: &ProgressUpdateEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ProgressUpdateEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"progressUpdate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressUpdateEventEvent {
    #[serde(rename = "progressUpdate")]
    ProgressUpdate,
}
impl ::std::convert::From<&Self> for ProgressUpdateEventEvent {
    fn from(value: &ProgressUpdateEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressUpdateEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ProgressUpdate => f.write_str("progressUpdate"),
        }
    }
}
impl ::std::str::FromStr for ProgressUpdateEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "progressUpdate" => Ok(Self::ProgressUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressUpdateEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressUpdateEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressUpdateEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProgressUpdateEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProgressUpdateEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ProgressUpdateEventType {
    fn from(value: &ProgressUpdateEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProgressUpdateEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ProgressUpdateEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressUpdateEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressUpdateEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressUpdateEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Base class of requests, responses, and events."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Base Protocol\","]
#[doc = "  \"description\": \"Base class of requests, responses, and events.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"seq\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"seq\": {"]
#[doc = "      \"description\": \"Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"Message type.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"request\","]
#[doc = "        \"response\","]
#[doc = "        \"event\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProtocolMessage {
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Message type."]
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ProtocolMessage> for ProtocolMessage {
    fn from(value: &ProtocolMessage) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `readMemory` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `readMemory` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"count\","]
#[doc = "    \"memoryReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"description\": \"Number of bytes to read at the specified location and offset.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"Memory reference to the base location from which data should be read.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"Offset (in bytes) to be applied to the reference location before reading data. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadMemoryArguments {
    #[doc = "Number of bytes to read at the specified location and offset."]
    pub count: i64,
    #[doc = "Memory reference to the base location from which data should be read."]
    #[serde(rename = "memoryReference")]
    pub memory_reference: ::std::string::String,
    #[doc = "Offset (in bytes) to be applied to the reference location before reading data. Can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ReadMemoryArguments> for ReadMemoryArguments {
    fn from(value: &ReadMemoryArguments) -> Self {
        value.clone()
    }
}
#[doc = "`ReadMemoryRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Reads bytes from memory at the provided location.\\nClients should only call this request if the corresponding capability `supportsReadMemoryRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ReadMemoryArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"readMemory\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadMemoryRequest {
    pub arguments: ReadMemoryArguments,
    pub command: ReadMemoryRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ReadMemoryRequestType,
}
impl ::std::convert::From<&ReadMemoryRequest> for ReadMemoryRequest {
    fn from(value: &ReadMemoryRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ReadMemoryRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"readMemory\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReadMemoryRequestCommand {
    #[serde(rename = "readMemory")]
    ReadMemory,
}
impl ::std::convert::From<&Self> for ReadMemoryRequestCommand {
    fn from(value: &ReadMemoryRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReadMemoryRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReadMemory => f.write_str("readMemory"),
        }
    }
}
impl ::std::str::FromStr for ReadMemoryRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "readMemory" => Ok(Self::ReadMemory),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReadMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReadMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReadMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReadMemoryRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReadMemoryRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ReadMemoryRequestType {
    fn from(value: &ReadMemoryRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReadMemoryRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ReadMemoryRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReadMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReadMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReadMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReadMemoryResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `readMemory` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"address\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"address\": {"]
#[doc = "              \"description\": \"The address of the first byte of data returned.\\nTreated as a hex value if prefixed with `0x`, or as a decimal value otherwise.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"description\": \"The bytes read from memory, encoded using base64. If the decoded length of `data` is less than the requested `count` in the original `readMemory` request, and `unreadableBytes` is zero or omitted, then the client should assume it's reached the end of readable memory.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"unreadableBytes\": {"]
#[doc = "              \"description\": \"The number of unreadable bytes encountered after the last successfully read byte.\\nThis can be used to determine the number of bytes that should be skipped before a subsequent `readMemory` request succeeds.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadMemoryResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<ReadMemoryResponseBody>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ReadMemoryResponseType,
}
impl ::std::convert::From<&ReadMemoryResponse> for ReadMemoryResponse {
    fn from(value: &ReadMemoryResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ReadMemoryResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"address\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"address\": {"]
#[doc = "      \"description\": \"The address of the first byte of data returned.\\nTreated as a hex value if prefixed with `0x`, or as a decimal value otherwise.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"The bytes read from memory, encoded using base64. If the decoded length of `data` is less than the requested `count` in the original `readMemory` request, and `unreadableBytes` is zero or omitted, then the client should assume it's reached the end of readable memory.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unreadableBytes\": {"]
#[doc = "      \"description\": \"The number of unreadable bytes encountered after the last successfully read byte.\\nThis can be used to determine the number of bytes that should be skipped before a subsequent `readMemory` request succeeds.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadMemoryResponseBody {
    #[doc = "The address of the first byte of data returned.\nTreated as a hex value if prefixed with `0x`, or as a decimal value otherwise."]
    pub address: ::std::string::String,
    #[doc = "The bytes read from memory, encoded using base64. If the decoded length of `data` is less than the requested `count` in the original `readMemory` request, and `unreadableBytes` is zero or omitted, then the client should assume it's reached the end of readable memory."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::std::string::String>,
    #[doc = "The number of unreadable bytes encountered after the last successfully read byte.\nThis can be used to determine the number of bytes that should be skipped before a subsequent `readMemory` request succeeds."]
    #[serde(
        rename = "unreadableBytes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub unreadable_bytes: ::std::option::Option<i64>,
}
impl ::std::convert::From<&ReadMemoryResponseBody> for ReadMemoryResponseBody {
    fn from(value: &ReadMemoryResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`ReadMemoryResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReadMemoryResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ReadMemoryResponseType {
    fn from(value: &ReadMemoryResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReadMemoryResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ReadMemoryResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReadMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReadMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReadMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Request`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolMessage\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"A client or debug adapter initiated request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"description\": \"Object containing arguments for the command.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"array\","]
#[doc = "            \"boolean\","]
#[doc = "            \"integer\","]
#[doc = "            \"null\","]
#[doc = "            \"number\","]
#[doc = "            \"object\","]
#[doc = "            \"string\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"description\": \"The command to execute.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"request\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Request {
    #[doc = "Object containing arguments for the command."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command to execute."]
    pub command: ::std::string::String,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: RequestType,
}
impl ::std::convert::From<&Request> for Request {
    fn from(value: &Request) -> Self {
        value.clone()
    }
}
#[doc = "`RequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for RequestType {
    fn from(value: &RequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for RequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Response`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolMessage\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response for a request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\","]
#[doc = "        \"request_seq\","]
#[doc = "        \"success\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"Contains request result if success is true and error details if success is false.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"array\","]
#[doc = "            \"boolean\","]
#[doc = "            \"integer\","]
#[doc = "            \"null\","]
#[doc = "            \"number\","]
#[doc = "            \"object\","]
#[doc = "            \"string\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"description\": \"The command requested.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"description\": \"Contains the raw error in short form if `success` is false.\\nThis raw error might be interpreted by the client and is not shown in the UI.\\nSome predefined values exist.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"_enum\": ["]
#[doc = "            \"cancelled\","]
#[doc = "            \"notStopped\""]
#[doc = "          ],"]
#[doc = "          \"enumDescriptions\": ["]
#[doc = "            \"the request was cancelled.\","]
#[doc = "            \"the request may be retried once the adapter is in a 'stopped' state.\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"request_seq\": {"]
#[doc = "          \"description\": \"Sequence number of the corresponding request.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"success\": {"]
#[doc = "          \"description\": \"Outcome of the request.\\nIf true, the request was successful and the `body` attribute may contain the result of the request.\\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"response\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Response {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ResponseType,
}
impl ::std::convert::From<&Response> for Response {
    fn from(value: &Response) -> Self {
        value.clone()
    }
}
#[doc = "`ResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ResponseType {
    fn from(value: &ResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `restart` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `restart` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"description\": \"The latest version of the `launch` or `attach` configuration.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/LaunchRequestArguments\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/AttachRequestArguments\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartArguments {
    #[doc = "The latest version of the `launch` or `attach` configuration."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<RestartArgumentsArguments>,
}
impl ::std::convert::From<&RestartArguments> for RestartArguments {
    fn from(value: &RestartArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RestartArguments {
    fn default() -> Self {
        Self {
            arguments: Default::default(),
        }
    }
}
#[doc = "The latest version of the `launch` or `attach` configuration."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The latest version of the `launch` or `attach` configuration.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/LaunchRequestArguments\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/AttachRequestArguments\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RestartArgumentsArguments {
    LaunchRequestArguments(LaunchRequestArguments),
    AttachRequestArguments(AttachRequestArguments),
}
impl ::std::convert::From<&Self> for RestartArgumentsArguments {
    fn from(value: &RestartArgumentsArguments) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LaunchRequestArguments> for RestartArgumentsArguments {
    fn from(value: LaunchRequestArguments) -> Self {
        Self::LaunchRequestArguments(value)
    }
}
impl ::std::convert::From<AttachRequestArguments> for RestartArgumentsArguments {
    fn from(value: AttachRequestArguments) -> Self {
        Self::AttachRequestArguments(value)
    }
}
#[doc = "Arguments for `restartFrame` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `restartFrame` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"frameId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"Restart the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartFrameArguments {
    #[doc = "Restart the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "frameId")]
    pub frame_id: i64,
}
impl ::std::convert::From<&RestartFrameArguments> for RestartFrameArguments {
    fn from(value: &RestartFrameArguments) -> Self {
        value.clone()
    }
}
#[doc = "`RestartFrameRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request restarts execution of the specified stack frame.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `restart`) after the restart has completed.\\nClients should only call this request if the corresponding capability `supportsRestartFrame` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/RestartFrameArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"restartFrame\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartFrameRequest {
    pub arguments: RestartFrameArguments,
    pub command: RestartFrameRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: RestartFrameRequestType,
}
impl ::std::convert::From<&RestartFrameRequest> for RestartFrameRequest {
    fn from(value: &RestartFrameRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RestartFrameRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"restartFrame\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartFrameRequestCommand {
    #[serde(rename = "restartFrame")]
    RestartFrame,
}
impl ::std::convert::From<&Self> for RestartFrameRequestCommand {
    fn from(value: &RestartFrameRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartFrameRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RestartFrame => f.write_str("restartFrame"),
        }
    }
}
impl ::std::str::FromStr for RestartFrameRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "restartFrame" => Ok(Self::RestartFrame),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartFrameRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartFrameRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartFrameRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RestartFrameRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartFrameRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for RestartFrameRequestType {
    fn from(value: &RestartFrameRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartFrameRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for RestartFrameRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartFrameRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartFrameRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartFrameRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RestartFrameResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `restartFrame` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartFrameResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: RestartFrameResponseType,
}
impl ::std::convert::From<&RestartFrameResponse> for RestartFrameResponse {
    fn from(value: &RestartFrameResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RestartFrameResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartFrameResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for RestartFrameResponseType {
    fn from(value: &RestartFrameResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartFrameResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for RestartFrameResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartFrameResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartFrameResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartFrameResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RestartRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Restarts a debug session. Clients should only call this request if the corresponding capability `supportsRestartRequest` is true.\\nIf the capability is missing or has the value false, a typical client emulates `restart` by terminating the debug adapter first and then launching it anew.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/RestartArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"restart\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<RestartArguments>,
    pub command: RestartRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: RestartRequestType,
}
impl ::std::convert::From<&RestartRequest> for RestartRequest {
    fn from(value: &RestartRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RestartRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"restart\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartRequestCommand {
    #[serde(rename = "restart")]
    Restart,
}
impl ::std::convert::From<&Self> for RestartRequestCommand {
    fn from(value: &RestartRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Restart => f.write_str("restart"),
        }
    }
}
impl ::std::str::FromStr for RestartRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "restart" => Ok(Self::Restart),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RestartRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for RestartRequestType {
    fn from(value: &RestartRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for RestartRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RestartResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `restart` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RestartResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: RestartResponseType,
}
impl ::std::convert::From<&RestartResponse> for RestartResponse {
    fn from(value: &RestartResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RestartResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RestartResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for RestartResponseType {
    fn from(value: &RestartResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RestartResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for RestartResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RestartResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RestartResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RestartResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `reverseContinue` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `reverseContinue` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, backward execution is resumed only for the thread with given `threadId`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the `singleThread` argument is true, only the thread with this ID is resumed.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReverseContinueArguments {
    #[doc = "If this flag is true, backward execution is resumed only for the thread with given `threadId`."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the `singleThread` argument is true, only the thread with this ID is resumed."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&ReverseContinueArguments> for ReverseContinueArguments {
    fn from(value: &ReverseContinueArguments) -> Self {
        value.clone()
    }
}
#[doc = "`ReverseContinueRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request resumes backward execution of all threads. If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true resumes only the specified thread. If not all threads were resumed, the `allThreadsContinued` attribute of the response should be set to false.\\nClients should only call this request if the corresponding capability `supportsStepBack` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ReverseContinueArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"reverseContinue\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReverseContinueRequest {
    pub arguments: ReverseContinueArguments,
    pub command: ReverseContinueRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ReverseContinueRequestType,
}
impl ::std::convert::From<&ReverseContinueRequest> for ReverseContinueRequest {
    fn from(value: &ReverseContinueRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ReverseContinueRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reverseContinue\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReverseContinueRequestCommand {
    #[serde(rename = "reverseContinue")]
    ReverseContinue,
}
impl ::std::convert::From<&Self> for ReverseContinueRequestCommand {
    fn from(value: &ReverseContinueRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReverseContinueRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReverseContinue => f.write_str("reverseContinue"),
        }
    }
}
impl ::std::str::FromStr for ReverseContinueRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reverseContinue" => Ok(Self::ReverseContinue),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReverseContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReverseContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReverseContinueRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReverseContinueRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReverseContinueRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ReverseContinueRequestType {
    fn from(value: &ReverseContinueRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReverseContinueRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ReverseContinueRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReverseContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReverseContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReverseContinueRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReverseContinueResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `reverseContinue` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReverseContinueResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ReverseContinueResponseType,
}
impl ::std::convert::From<&ReverseContinueResponse> for ReverseContinueResponse {
    fn from(value: &ReverseContinueResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ReverseContinueResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReverseContinueResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ReverseContinueResponseType {
    fn from(value: &ReverseContinueResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReverseContinueResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ReverseContinueResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReverseContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReverseContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReverseContinueResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RunInTerminalRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Reverse Requests\","]
#[doc = "      \"description\": \"This request is sent from the debug adapter to the client to run a command in a terminal.\\nThis is typically used to launch the debuggee in a terminal provided by the client.\\nThis request should only be called if the corresponding client capability `supportsRunInTerminalRequest` is true.\\nClient implementations of `runInTerminal` are free to run the command however they choose including issuing the command to a command line interpreter (aka 'shell'). Argument strings passed to the `runInTerminal` request must arrive verbatim in the command to be run. As a consequence, clients which use a shell are responsible for escaping any special shell characters in the argument strings to prevent them from being interpreted (and modified) by the shell.\\nSome users may wish to take advantage of shell processing in the argument strings. For clients which implement `runInTerminal` using an intermediary shell, the `argsCanBeInterpretedByShell` property can be set to true. In this case the client is requested not to escape any special shell characters in the argument strings.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/RunInTerminalRequestArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"runInTerminal\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RunInTerminalRequest {
    pub arguments: RunInTerminalRequestArguments,
    pub command: RunInTerminalRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: RunInTerminalRequestType,
}
impl ::std::convert::From<&RunInTerminalRequest> for RunInTerminalRequest {
    fn from(value: &RunInTerminalRequest) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `runInTerminal` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `runInTerminal` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"args\","]
#[doc = "    \"cwd\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"args\": {"]
#[doc = "      \"description\": \"List of arguments. The first argument is the command to run.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"argsCanBeInterpretedByShell\": {"]
#[doc = "      \"description\": \"This property should only be set if the corresponding capability `supportsArgsCanBeInterpretedByShell` is true. If the client uses an intermediary shell to launch the application, then the client must not attempt to escape characters with special meanings for the shell. The user is fully responsible for escaping as needed and that arguments using special characters may not be portable across shells.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"cwd\": {"]
#[doc = "      \"description\": \"Working directory for the command. For non-empty, valid paths this typically results in execution of a change directory command.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"env\": {"]
#[doc = "      \"description\": \"Environment key-value pairs that are added to or removed from the default environment.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"description\": \"A string is a proper value for an environment variable. The value `null` removes the variable from the environment.\","]
#[doc = "        \"type\": ["]
#[doc = "          \"string\","]
#[doc = "          \"null\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"kind\": {"]
#[doc = "      \"description\": \"What kind of terminal to launch. Defaults to `integrated` if not specified.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"integrated\","]
#[doc = "        \"external\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Title of the terminal.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RunInTerminalRequestArguments {
    #[doc = "List of arguments. The first argument is the command to run."]
    pub args: ::std::vec::Vec<::std::string::String>,
    #[doc = "This property should only be set if the corresponding capability `supportsArgsCanBeInterpretedByShell` is true. If the client uses an intermediary shell to launch the application, then the client must not attempt to escape characters with special meanings for the shell. The user is fully responsible for escaping as needed and that arguments using special characters may not be portable across shells."]
    #[serde(
        rename = "argsCanBeInterpretedByShell",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub args_can_be_interpreted_by_shell: ::std::option::Option<bool>,
    #[doc = "Working directory for the command. For non-empty, valid paths this typically results in execution of a change directory command."]
    pub cwd: ::std::string::String,
    #[doc = "Environment key-value pairs that are added to or removed from the default environment."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub env: ::std::collections::HashMap<
        ::std::string::String,
        ::std::option::Option<::std::string::String>,
    >,
    #[doc = "What kind of terminal to launch. Defaults to `integrated` if not specified."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub kind: ::std::option::Option<RunInTerminalRequestArgumentsKind>,
    #[doc = "Title of the terminal."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RunInTerminalRequestArguments> for RunInTerminalRequestArguments {
    fn from(value: &RunInTerminalRequestArguments) -> Self {
        value.clone()
    }
}
#[doc = "What kind of terminal to launch. Defaults to `integrated` if not specified."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"What kind of terminal to launch. Defaults to `integrated` if not specified.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"integrated\","]
#[doc = "    \"external\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RunInTerminalRequestArgumentsKind {
    #[serde(rename = "integrated")]
    Integrated,
    #[serde(rename = "external")]
    External,
}
impl ::std::convert::From<&Self> for RunInTerminalRequestArgumentsKind {
    fn from(value: &RunInTerminalRequestArgumentsKind) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RunInTerminalRequestArgumentsKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Integrated => f.write_str("integrated"),
            Self::External => f.write_str("external"),
        }
    }
}
impl ::std::str::FromStr for RunInTerminalRequestArgumentsKind {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "integrated" => Ok(Self::Integrated),
            "external" => Ok(Self::External),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RunInTerminalRequestArgumentsKind {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RunInTerminalRequestArgumentsKind {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RunInTerminalRequestArgumentsKind {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RunInTerminalRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"runInTerminal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RunInTerminalRequestCommand {
    #[serde(rename = "runInTerminal")]
    RunInTerminal,
}
impl ::std::convert::From<&Self> for RunInTerminalRequestCommand {
    fn from(value: &RunInTerminalRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RunInTerminalRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RunInTerminal => f.write_str("runInTerminal"),
        }
    }
}
impl ::std::str::FromStr for RunInTerminalRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "runInTerminal" => Ok(Self::RunInTerminal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RunInTerminalRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RunInTerminalRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RunInTerminalRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RunInTerminalRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RunInTerminalRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for RunInTerminalRequestType {
    fn from(value: &RunInTerminalRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RunInTerminalRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for RunInTerminalRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RunInTerminalRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RunInTerminalRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RunInTerminalRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RunInTerminalResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `runInTerminal` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"processId\": {"]
#[doc = "              \"description\": \"The process ID. The value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"shellProcessId\": {"]
#[doc = "              \"description\": \"The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RunInTerminalResponse {
    pub body: RunInTerminalResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: RunInTerminalResponseType,
}
impl ::std::convert::From<&RunInTerminalResponse> for RunInTerminalResponse {
    fn from(value: &RunInTerminalResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RunInTerminalResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"processId\": {"]
#[doc = "      \"description\": \"The process ID. The value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"shellProcessId\": {"]
#[doc = "      \"description\": \"The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RunInTerminalResponseBody {
    #[doc = "The process ID. The value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "processId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub process_id: ::std::option::Option<i64>,
    #[doc = "The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "shellProcessId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub shell_process_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&RunInTerminalResponseBody> for RunInTerminalResponseBody {
    fn from(value: &RunInTerminalResponseBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RunInTerminalResponseBody {
    fn default() -> Self {
        Self {
            process_id: Default::default(),
            shell_process_id: Default::default(),
        }
    }
}
#[doc = "`RunInTerminalResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RunInTerminalResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for RunInTerminalResponseType {
    fn from(value: &RunInTerminalResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RunInTerminalResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for RunInTerminalResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RunInTerminalResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RunInTerminalResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RunInTerminalResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `Scope` is a named container for variables. Optionally a scope can map to a source or a range within a source."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `Scope` is a named container for variables. Optionally a scope can map to a source or a range within a source.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expensive\","]
#[doc = "    \"name\","]
#[doc = "    \"variablesReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the range covered by this scope.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"expensive\": {"]
#[doc = "      \"description\": \"If true, the number of variables in this scope is large or expensive to retrieve.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"indexedVariables\": {"]
#[doc = "      \"description\": \"The number of indexed variables in this scope.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The start line of the range covered by this scope.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This string is shown in the UI as is and can be translated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namedVariables\": {"]
#[doc = "      \"description\": \"The number of named variables in this scope.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"A hint for how to present this scope in the UI. If this attribute is missing, the scope is shown with a generic UI.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"locals\","]
#[doc = "        \"registers\","]
#[doc = "        \"returnValue\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"Scope contains method arguments.\","]
#[doc = "        \"Scope contains local variables.\","]
#[doc = "        \"Scope contains registers. Only a single `registers` scope should be returned from a `scopes` request.\","]
#[doc = "        \"Scope contains one or more return values.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source for this scope.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"The variables of this scope can be retrieved by passing the value of `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Scope {
    #[doc = "Start position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "End position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the range covered by this scope."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "If true, the number of variables in this scope is large or expensive to retrieve."]
    pub expensive: bool,
    #[doc = "The number of indexed variables in this scope.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks."]
    #[serde(
        rename = "indexedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub indexed_variables: ::std::option::Option<i64>,
    #[doc = "The start line of the range covered by this scope."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
    #[doc = "Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This string is shown in the UI as is and can be translated."]
    pub name: ::std::string::String,
    #[doc = "The number of named variables in this scope.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks."]
    #[serde(
        rename = "namedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub named_variables: ::std::option::Option<i64>,
    #[doc = "A hint for how to present this scope in the UI. If this attribute is missing, the scope is shown with a generic UI."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<::std::string::String>,
    #[doc = "The source for this scope."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
    #[doc = "The variables of this scope can be retrieved by passing the value of `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
impl ::std::convert::From<&Scope> for Scope {
    fn from(value: &Scope) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `scopes` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `scopes` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"frameId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"Retrieve the scopes for the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ScopesArguments {
    #[doc = "Retrieve the scopes for the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "frameId")]
    pub frame_id: i64,
}
impl ::std::convert::From<&ScopesArguments> for ScopesArguments {
    fn from(value: &ScopesArguments) -> Self {
        value.clone()
    }
}
#[doc = "`ScopesRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request returns the variable scopes for a given stack frame ID.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/ScopesArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"scopes\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ScopesRequest {
    pub arguments: ScopesArguments,
    pub command: ScopesRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ScopesRequestType,
}
impl ::std::convert::From<&ScopesRequest> for ScopesRequest {
    fn from(value: &ScopesRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ScopesRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"scopes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScopesRequestCommand {
    #[serde(rename = "scopes")]
    Scopes,
}
impl ::std::convert::From<&Self> for ScopesRequestCommand {
    fn from(value: &ScopesRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScopesRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Scopes => f.write_str("scopes"),
        }
    }
}
impl ::std::str::FromStr for ScopesRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "scopes" => Ok(Self::Scopes),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScopesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScopesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScopesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScopesRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScopesRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ScopesRequestType {
    fn from(value: &ScopesRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScopesRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ScopesRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScopesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScopesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScopesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScopesResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `scopes` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scopes\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"scopes\": {"]
#[doc = "              \"description\": \"The scopes of the stack frame. If the array has length zero, there are no scopes available.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Scope\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ScopesResponse {
    pub body: ScopesResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ScopesResponseType,
}
impl ::std::convert::From<&ScopesResponse> for ScopesResponse {
    fn from(value: &ScopesResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ScopesResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"scopes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"scopes\": {"]
#[doc = "      \"description\": \"The scopes of the stack frame. If the array has length zero, there are no scopes available.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Scope\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ScopesResponseBody {
    #[doc = "The scopes of the stack frame. If the array has length zero, there are no scopes available."]
    pub scopes: ::std::vec::Vec<Scope>,
}
impl ::std::convert::From<&ScopesResponseBody> for ScopesResponseBody {
    fn from(value: &ScopesResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`ScopesResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScopesResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ScopesResponseType {
    fn from(value: &ScopesResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScopesResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ScopesResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScopesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScopesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScopesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"source\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"The code locations of the breakpoints.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/SourceBreakpoint\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"lines\": {"]
#[doc = "      \"description\": \"Deprecated: The code locations of the breakpoints.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"sourceModified\": {"]
#[doc = "      \"description\": \"A value of true indicates that the underlying source has been modified which results in new breakpoint locations.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetBreakpointsArguments {
    #[doc = "The code locations of the breakpoints."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub breakpoints: ::std::vec::Vec<SourceBreakpoint>,
    #[doc = "Deprecated: The code locations of the breakpoints."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub lines: ::std::vec::Vec<i64>,
    #[doc = "The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified."]
    pub source: Source,
    #[doc = "A value of true indicates that the underlying source has been modified which results in new breakpoint locations."]
    #[serde(
        rename = "sourceModified",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub source_modified: ::std::option::Option<bool>,
}
impl ::std::convert::From<&SetBreakpointsArguments> for SetBreakpointsArguments {
    fn from(value: &SetBreakpointsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetBreakpointsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.\\nTo clear all breakpoint for a source, specify an empty array.\\nWhen a breakpoint is hit, a `stopped` event (with reason `breakpoint`) is generated.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetBreakpointsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setBreakpoints\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetBreakpointsRequest {
    pub arguments: SetBreakpointsArguments,
    pub command: SetBreakpointsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetBreakpointsRequestType,
}
impl ::std::convert::From<&SetBreakpointsRequest> for SetBreakpointsRequest {
    fn from(value: &SetBreakpointsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetBreakpointsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setBreakpoints\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetBreakpointsRequestCommand {
    #[serde(rename = "setBreakpoints")]
    SetBreakpoints,
}
impl ::std::convert::From<&Self> for SetBreakpointsRequestCommand {
    fn from(value: &SetBreakpointsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetBreakpointsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetBreakpoints => f.write_str("setBreakpoints"),
        }
    }
}
impl ::std::str::FromStr for SetBreakpointsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setBreakpoints" => Ok(Self::SetBreakpoints),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetBreakpointsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetBreakpointsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetBreakpointsRequestType {
    fn from(value: &SetBreakpointsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetBreakpointsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetBreakpointsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetBreakpointsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setBreakpoints` request.\\nReturned is information about each breakpoint created by this request.\\nThis includes the actual code location and whether the breakpoint could be verified.\\nThe breakpoints returned are in the same order as the elements of the `breakpoints`\\n(or the deprecated `lines`) array in the arguments.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoints\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Information about the breakpoints.\\nThe array elements are in the same order as the elements of the `breakpoints` (or the deprecated `lines`) array in the arguments.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetBreakpointsResponse {
    pub body: SetBreakpointsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetBreakpointsResponseType,
}
impl ::std::convert::From<&SetBreakpointsResponse> for SetBreakpointsResponse {
    fn from(value: &SetBreakpointsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetBreakpointsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Information about the breakpoints.\\nThe array elements are in the same order as the elements of the `breakpoints` (or the deprecated `lines`) array in the arguments.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetBreakpointsResponseBody {
    #[doc = "Information about the breakpoints.\nThe array elements are in the same order as the elements of the `breakpoints` (or the deprecated `lines`) array in the arguments."]
    pub breakpoints: ::std::vec::Vec<Breakpoint>,
}
impl ::std::convert::From<&SetBreakpointsResponseBody> for SetBreakpointsResponseBody {
    fn from(value: &SetBreakpointsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetBreakpointsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetBreakpointsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetBreakpointsResponseType {
    fn from(value: &SetBreakpointsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetBreakpointsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetBreakpointsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setDataBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setDataBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/DataBreakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetDataBreakpointsArguments {
    #[doc = "The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints."]
    pub breakpoints: ::std::vec::Vec<DataBreakpoint>,
}
impl ::std::convert::From<&SetDataBreakpointsArguments> for SetDataBreakpointsArguments {
    fn from(value: &SetDataBreakpointsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetDataBreakpointsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Replaces all existing data breakpoints with new data breakpoints.\\nTo clear all data breakpoints, specify an empty array.\\nWhen a data breakpoint is hit, a `stopped` event (with reason `data breakpoint`) is generated.\\nClients should only call this request if the corresponding capability `supportsDataBreakpoints` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetDataBreakpointsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setDataBreakpoints\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetDataBreakpointsRequest {
    pub arguments: SetDataBreakpointsArguments,
    pub command: SetDataBreakpointsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetDataBreakpointsRequestType,
}
impl ::std::convert::From<&SetDataBreakpointsRequest> for SetDataBreakpointsRequest {
    fn from(value: &SetDataBreakpointsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetDataBreakpointsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setDataBreakpoints\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetDataBreakpointsRequestCommand {
    #[serde(rename = "setDataBreakpoints")]
    SetDataBreakpoints,
}
impl ::std::convert::From<&Self> for SetDataBreakpointsRequestCommand {
    fn from(value: &SetDataBreakpointsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetDataBreakpointsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetDataBreakpoints => f.write_str("setDataBreakpoints"),
        }
    }
}
impl ::std::str::FromStr for SetDataBreakpointsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setDataBreakpoints" => Ok(Self::SetDataBreakpoints),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetDataBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetDataBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetDataBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetDataBreakpointsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetDataBreakpointsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetDataBreakpointsRequestType {
    fn from(value: &SetDataBreakpointsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetDataBreakpointsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetDataBreakpointsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetDataBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetDataBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetDataBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetDataBreakpointsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setDataBreakpoints` request.\\nReturned is information about each breakpoint created by this request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoints\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Information about the data breakpoints. The array elements correspond to the elements of the input argument `breakpoints` array.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetDataBreakpointsResponse {
    pub body: SetDataBreakpointsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetDataBreakpointsResponseType,
}
impl ::std::convert::From<&SetDataBreakpointsResponse> for SetDataBreakpointsResponse {
    fn from(value: &SetDataBreakpointsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetDataBreakpointsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Information about the data breakpoints. The array elements correspond to the elements of the input argument `breakpoints` array.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetDataBreakpointsResponseBody {
    #[doc = "Information about the data breakpoints. The array elements correspond to the elements of the input argument `breakpoints` array."]
    pub breakpoints: ::std::vec::Vec<Breakpoint>,
}
impl ::std::convert::From<&SetDataBreakpointsResponseBody> for SetDataBreakpointsResponseBody {
    fn from(value: &SetDataBreakpointsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetDataBreakpointsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetDataBreakpointsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetDataBreakpointsResponseType {
    fn from(value: &SetDataBreakpointsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetDataBreakpointsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetDataBreakpointsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetDataBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetDataBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetDataBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setExceptionBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setExceptionBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"filters\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"exceptionOptions\": {"]
#[doc = "      \"description\": \"Configuration options for selected exceptions.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionOptions` is true.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ExceptionOptions\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"filterOptions\": {"]
#[doc = "      \"description\": \"Set of exception filters and their options. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. This attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionFilterOptions` is true. The `filter` and `filterOptions` sets are additive.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ExceptionFilterOptions\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"filters\": {"]
#[doc = "      \"description\": \"Set of exception filters specified by their ID. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. The `filter` and `filterOptions` sets are additive.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExceptionBreakpointsArguments {
    #[doc = "Configuration options for selected exceptions.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionOptions` is true."]
    #[serde(
        rename = "exceptionOptions",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub exception_options: ::std::vec::Vec<ExceptionOptions>,
    #[doc = "Set of exception filters and their options. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. This attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionFilterOptions` is true. The `filter` and `filterOptions` sets are additive."]
    #[serde(
        rename = "filterOptions",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub filter_options: ::std::vec::Vec<ExceptionFilterOptions>,
    #[doc = "Set of exception filters specified by their ID. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. The `filter` and `filterOptions` sets are additive."]
    pub filters: ::std::vec::Vec<::std::string::String>,
}
impl ::std::convert::From<&SetExceptionBreakpointsArguments> for SetExceptionBreakpointsArguments {
    fn from(value: &SetExceptionBreakpointsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetExceptionBreakpointsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request configures the debugger's response to thrown exceptions. Each of the `filters`, `filterOptions`, and `exceptionOptions` in the request are independent configurations to a debug adapter indicating a kind of exception to catch. An exception thrown in a program should result in a `stopped` event from the debug adapter (with reason `exception`) if any of the configured filters match.\\nClients should only call this request if the corresponding capability `exceptionBreakpointFilters` returns one or more filters.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetExceptionBreakpointsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setExceptionBreakpoints\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExceptionBreakpointsRequest {
    pub arguments: SetExceptionBreakpointsArguments,
    pub command: SetExceptionBreakpointsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetExceptionBreakpointsRequestType,
}
impl ::std::convert::From<&SetExceptionBreakpointsRequest> for SetExceptionBreakpointsRequest {
    fn from(value: &SetExceptionBreakpointsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetExceptionBreakpointsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setExceptionBreakpoints\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExceptionBreakpointsRequestCommand {
    #[serde(rename = "setExceptionBreakpoints")]
    SetExceptionBreakpoints,
}
impl ::std::convert::From<&Self> for SetExceptionBreakpointsRequestCommand {
    fn from(value: &SetExceptionBreakpointsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExceptionBreakpointsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetExceptionBreakpoints => f.write_str("setExceptionBreakpoints"),
        }
    }
}
impl ::std::str::FromStr for SetExceptionBreakpointsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setExceptionBreakpoints" => Ok(Self::SetExceptionBreakpoints),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExceptionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExceptionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExceptionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetExceptionBreakpointsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExceptionBreakpointsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetExceptionBreakpointsRequestType {
    fn from(value: &SetExceptionBreakpointsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExceptionBreakpointsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetExceptionBreakpointsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExceptionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExceptionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExceptionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetExceptionBreakpointsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setExceptionBreakpoints` request.\\nThe response contains an array of `Breakpoint` objects with information about each exception breakpoint or filter. The `Breakpoint` objects are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays given as arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information.\\nThe `verified` property of a `Breakpoint` object signals whether the exception breakpoint or filter could be successfully created and whether the condition is valid. In case of an error the `message` property explains the problem. The `id` property can be used to introduce a unique ID for the exception breakpoint or filter so that it can be updated subsequently by sending breakpoint events.\\nFor backward compatibility both the `breakpoints` array and the enclosing `body` are optional. If these elements are missing a client is not able to show problems for individual exception breakpoints or filters.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Information about the exception breakpoints or filters.\\nThe breakpoints returned are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExceptionBreakpointsResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<SetExceptionBreakpointsResponseBody>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetExceptionBreakpointsResponseType,
}
impl ::std::convert::From<&SetExceptionBreakpointsResponse> for SetExceptionBreakpointsResponse {
    fn from(value: &SetExceptionBreakpointsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetExceptionBreakpointsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Information about the exception breakpoints or filters.\\nThe breakpoints returned are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExceptionBreakpointsResponseBody {
    #[doc = "Information about the exception breakpoints or filters.\nThe breakpoints returned are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub breakpoints: ::std::vec::Vec<Breakpoint>,
}
impl ::std::convert::From<&SetExceptionBreakpointsResponseBody>
    for SetExceptionBreakpointsResponseBody
{
    fn from(value: &SetExceptionBreakpointsResponseBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SetExceptionBreakpointsResponseBody {
    fn default() -> Self {
        Self {
            breakpoints: Default::default(),
        }
    }
}
#[doc = "`SetExceptionBreakpointsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExceptionBreakpointsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetExceptionBreakpointsResponseType {
    fn from(value: &SetExceptionBreakpointsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExceptionBreakpointsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetExceptionBreakpointsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExceptionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExceptionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExceptionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setExpression` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setExpression` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expression\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expression\": {"]
#[doc = "      \"description\": \"The l-value expression to assign to.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Specifies how the resulting value should be formatted.\","]
#[doc = "      \"$ref\": \"#/definitions/ValueFormat\""]
#[doc = "    },"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"Evaluate the expressions in the scope of this stack frame. If not specified, the expressions are evaluated in the global scope.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The value expression to assign to the l-value expression.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExpressionArguments {
    #[doc = "The l-value expression to assign to."]
    pub expression: ::std::string::String,
    #[doc = "Specifies how the resulting value should be formatted."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<ValueFormat>,
    #[doc = "Evaluate the expressions in the scope of this stack frame. If not specified, the expressions are evaluated in the global scope."]
    #[serde(
        rename = "frameId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub frame_id: ::std::option::Option<i64>,
    #[doc = "The value expression to assign to the l-value expression."]
    pub value: ::std::string::String,
}
impl ::std::convert::From<&SetExpressionArguments> for SetExpressionArguments {
    fn from(value: &SetExpressionArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetExpressionRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Evaluates the given `value` expression and assigns it to the `expression` which must be a modifiable l-value.\\nThe expressions have access to any variables and arguments that are in scope of the specified frame.\\nClients should only call this request if the corresponding capability `supportsSetExpression` is true.\\nIf a debug adapter implements both `setExpression` and `setVariable`, a client uses `setExpression` if the variable has an `evaluateName` property.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetExpressionArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setExpression\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExpressionRequest {
    pub arguments: SetExpressionArguments,
    pub command: SetExpressionRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetExpressionRequestType,
}
impl ::std::convert::From<&SetExpressionRequest> for SetExpressionRequest {
    fn from(value: &SetExpressionRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetExpressionRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setExpression\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExpressionRequestCommand {
    #[serde(rename = "setExpression")]
    SetExpression,
}
impl ::std::convert::From<&Self> for SetExpressionRequestCommand {
    fn from(value: &SetExpressionRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExpressionRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetExpression => f.write_str("setExpression"),
        }
    }
}
impl ::std::str::FromStr for SetExpressionRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setExpression" => Ok(Self::SetExpression),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExpressionRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExpressionRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExpressionRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetExpressionRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExpressionRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetExpressionRequestType {
    fn from(value: &SetExpressionRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExpressionRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetExpressionRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExpressionRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExpressionRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExpressionRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetExpressionResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setExpression` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"indexedVariables\": {"]
#[doc = "              \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"memoryReference\": {"]
#[doc = "              \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"namedVariables\": {"]
#[doc = "              \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"presentationHint\": {"]
#[doc = "              \"description\": \"Properties of a value that can be used to determine how to render the result in the UI.\","]
#[doc = "              \"$ref\": \"#/definitions/VariablePresentationHint\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"description\": \"The type of the value.\\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"value\": {"]
#[doc = "              \"description\": \"The new value of the expression.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"valueLocationReference\": {"]
#[doc = "              \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"variablesReference\": {"]
#[doc = "              \"description\": \"If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExpressionResponse {
    pub body: SetExpressionResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetExpressionResponseType,
}
impl ::std::convert::From<&SetExpressionResponse> for SetExpressionResponse {
    fn from(value: &SetExpressionResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetExpressionResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"indexedVariables\": {"]
#[doc = "      \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namedVariables\": {"]
#[doc = "      \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"Properties of a value that can be used to determine how to render the result in the UI.\","]
#[doc = "      \"$ref\": \"#/definitions/VariablePresentationHint\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"The type of the value.\\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The new value of the expression.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"valueLocationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetExpressionResponseBody {
    #[doc = "The number of indexed child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "indexedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub indexed_variables: ::std::option::Option<i64>,
    #[doc = "A memory reference to a location appropriate for this result.\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true."]
    #[serde(
        rename = "memoryReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub memory_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The number of named child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "namedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub named_variables: ::std::option::Option<i64>,
    #[doc = "Properties of a value that can be used to determine how to render the result in the UI."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<VariablePresentationHint>,
    #[doc = "The type of the value.\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[doc = "The new value of the expression."]
    pub value: ::std::string::String,
    #[doc = "A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "valueLocationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub value_location_reference: ::std::option::Option<i64>,
    #[doc = "If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "variablesReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub variables_reference: ::std::option::Option<i64>,
}
impl ::std::convert::From<&SetExpressionResponseBody> for SetExpressionResponseBody {
    fn from(value: &SetExpressionResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetExpressionResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetExpressionResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetExpressionResponseType {
    fn from(value: &SetExpressionResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetExpressionResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetExpressionResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetExpressionResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetExpressionResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetExpressionResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setFunctionBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setFunctionBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"The function names of the breakpoints.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/FunctionBreakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetFunctionBreakpointsArguments {
    #[doc = "The function names of the breakpoints."]
    pub breakpoints: ::std::vec::Vec<FunctionBreakpoint>,
}
impl ::std::convert::From<&SetFunctionBreakpointsArguments> for SetFunctionBreakpointsArguments {
    fn from(value: &SetFunctionBreakpointsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetFunctionBreakpointsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Replaces all existing function breakpoints with new function breakpoints.\\nTo clear all function breakpoints, specify an empty array.\\nWhen a function breakpoint is hit, a `stopped` event (with reason `function breakpoint`) is generated.\\nClients should only call this request if the corresponding capability `supportsFunctionBreakpoints` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetFunctionBreakpointsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setFunctionBreakpoints\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetFunctionBreakpointsRequest {
    pub arguments: SetFunctionBreakpointsArguments,
    pub command: SetFunctionBreakpointsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetFunctionBreakpointsRequestType,
}
impl ::std::convert::From<&SetFunctionBreakpointsRequest> for SetFunctionBreakpointsRequest {
    fn from(value: &SetFunctionBreakpointsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetFunctionBreakpointsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setFunctionBreakpoints\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetFunctionBreakpointsRequestCommand {
    #[serde(rename = "setFunctionBreakpoints")]
    SetFunctionBreakpoints,
}
impl ::std::convert::From<&Self> for SetFunctionBreakpointsRequestCommand {
    fn from(value: &SetFunctionBreakpointsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetFunctionBreakpointsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetFunctionBreakpoints => f.write_str("setFunctionBreakpoints"),
        }
    }
}
impl ::std::str::FromStr for SetFunctionBreakpointsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setFunctionBreakpoints" => Ok(Self::SetFunctionBreakpoints),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetFunctionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetFunctionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetFunctionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetFunctionBreakpointsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetFunctionBreakpointsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetFunctionBreakpointsRequestType {
    fn from(value: &SetFunctionBreakpointsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetFunctionBreakpointsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetFunctionBreakpointsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetFunctionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetFunctionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetFunctionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetFunctionBreakpointsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setFunctionBreakpoints` request.\\nReturned is information about each breakpoint created by this request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoints\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetFunctionBreakpointsResponse {
    pub body: SetFunctionBreakpointsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetFunctionBreakpointsResponseType,
}
impl ::std::convert::From<&SetFunctionBreakpointsResponse> for SetFunctionBreakpointsResponse {
    fn from(value: &SetFunctionBreakpointsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetFunctionBreakpointsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetFunctionBreakpointsResponseBody {
    #[doc = "Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array."]
    pub breakpoints: ::std::vec::Vec<Breakpoint>,
}
impl ::std::convert::From<&SetFunctionBreakpointsResponseBody>
    for SetFunctionBreakpointsResponseBody
{
    fn from(value: &SetFunctionBreakpointsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetFunctionBreakpointsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetFunctionBreakpointsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetFunctionBreakpointsResponseType {
    fn from(value: &SetFunctionBreakpointsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetFunctionBreakpointsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetFunctionBreakpointsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetFunctionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetFunctionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetFunctionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setInstructionBreakpoints` request"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setInstructionBreakpoints` request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"The instruction references of the breakpoints\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/InstructionBreakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetInstructionBreakpointsArguments {
    #[doc = "The instruction references of the breakpoints"]
    pub breakpoints: ::std::vec::Vec<InstructionBreakpoint>,
}
impl ::std::convert::From<&SetInstructionBreakpointsArguments>
    for SetInstructionBreakpointsArguments
{
    fn from(value: &SetInstructionBreakpointsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetInstructionBreakpointsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Replaces all existing instruction breakpoints. Typically, instruction breakpoints would be set from a disassembly window. \\nTo clear all instruction breakpoints, specify an empty array.\\nWhen an instruction breakpoint is hit, a `stopped` event (with reason `instruction breakpoint`) is generated.\\nClients should only call this request if the corresponding capability `supportsInstructionBreakpoints` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetInstructionBreakpointsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setInstructionBreakpoints\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetInstructionBreakpointsRequest {
    pub arguments: SetInstructionBreakpointsArguments,
    pub command: SetInstructionBreakpointsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetInstructionBreakpointsRequestType,
}
impl ::std::convert::From<&SetInstructionBreakpointsRequest> for SetInstructionBreakpointsRequest {
    fn from(value: &SetInstructionBreakpointsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetInstructionBreakpointsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setInstructionBreakpoints\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetInstructionBreakpointsRequestCommand {
    #[serde(rename = "setInstructionBreakpoints")]
    SetInstructionBreakpoints,
}
impl ::std::convert::From<&Self> for SetInstructionBreakpointsRequestCommand {
    fn from(value: &SetInstructionBreakpointsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetInstructionBreakpointsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetInstructionBreakpoints => f.write_str("setInstructionBreakpoints"),
        }
    }
}
impl ::std::str::FromStr for SetInstructionBreakpointsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setInstructionBreakpoints" => Ok(Self::SetInstructionBreakpoints),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetInstructionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetInstructionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetInstructionBreakpointsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetInstructionBreakpointsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetInstructionBreakpointsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetInstructionBreakpointsRequestType {
    fn from(value: &SetInstructionBreakpointsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetInstructionBreakpointsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetInstructionBreakpointsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetInstructionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetInstructionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetInstructionBreakpointsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetInstructionBreakpointsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setInstructionBreakpoints` request\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"breakpoints\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"breakpoints\": {"]
#[doc = "              \"description\": \"Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetInstructionBreakpointsResponse {
    pub body: SetInstructionBreakpointsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetInstructionBreakpointsResponseType,
}
impl ::std::convert::From<&SetInstructionBreakpointsResponse>
    for SetInstructionBreakpointsResponse
{
    fn from(value: &SetInstructionBreakpointsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetInstructionBreakpointsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"breakpoints\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"breakpoints\": {"]
#[doc = "      \"description\": \"Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Breakpoint\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetInstructionBreakpointsResponseBody {
    #[doc = "Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array."]
    pub breakpoints: ::std::vec::Vec<Breakpoint>,
}
impl ::std::convert::From<&SetInstructionBreakpointsResponseBody>
    for SetInstructionBreakpointsResponseBody
{
    fn from(value: &SetInstructionBreakpointsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetInstructionBreakpointsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetInstructionBreakpointsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetInstructionBreakpointsResponseType {
    fn from(value: &SetInstructionBreakpointsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetInstructionBreakpointsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetInstructionBreakpointsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetInstructionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetInstructionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetInstructionBreakpointsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `setVariable` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `setVariable` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"value\","]
#[doc = "    \"variablesReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Specifies details on how to format the response value.\","]
#[doc = "      \"$ref\": \"#/definitions/ValueFormat\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the variable in the container.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The value of the variable.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"The reference of the variable container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetVariableArguments {
    #[doc = "Specifies details on how to format the response value."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<ValueFormat>,
    #[doc = "The name of the variable in the container."]
    pub name: ::std::string::String,
    #[doc = "The value of the variable."]
    pub value: ::std::string::String,
    #[doc = "The reference of the variable container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
impl ::std::convert::From<&SetVariableArguments> for SetVariableArguments {
    fn from(value: &SetVariableArguments) -> Self {
        value.clone()
    }
}
#[doc = "`SetVariableRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Set the variable with the given name in the variable container to a new value. Clients should only call this request if the corresponding capability `supportsSetVariable` is true.\\nIf a debug adapter implements both `setVariable` and `setExpression`, a client will only use `setExpression` if the variable has an `evaluateName` property.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SetVariableArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"setVariable\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetVariableRequest {
    pub arguments: SetVariableArguments,
    pub command: SetVariableRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SetVariableRequestType,
}
impl ::std::convert::From<&SetVariableRequest> for SetVariableRequest {
    fn from(value: &SetVariableRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SetVariableRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"setVariable\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetVariableRequestCommand {
    #[serde(rename = "setVariable")]
    SetVariable,
}
impl ::std::convert::From<&Self> for SetVariableRequestCommand {
    fn from(value: &SetVariableRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetVariableRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SetVariable => f.write_str("setVariable"),
        }
    }
}
impl ::std::str::FromStr for SetVariableRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "setVariable" => Ok(Self::SetVariable),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetVariableRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetVariableRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetVariableRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetVariableRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetVariableRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SetVariableRequestType {
    fn from(value: &SetVariableRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetVariableRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SetVariableRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetVariableRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetVariableRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetVariableRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SetVariableResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `setVariable` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"indexedVariables\": {"]
#[doc = "              \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"memoryReference\": {"]
#[doc = "              \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"namedVariables\": {"]
#[doc = "              \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"description\": \"The type of the new value. Typically shown in the UI when hovering over the value.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"value\": {"]
#[doc = "              \"description\": \"The new value of the variable.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"valueLocationReference\": {"]
#[doc = "              \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"variablesReference\": {"]
#[doc = "              \"description\": \"If `variablesReference` is > 0, the new value is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\\n\\nIf this property is included in the response, any `variablesReference` previously associated with the updated variable, and those of its children, are no longer valid.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetVariableResponse {
    pub body: SetVariableResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SetVariableResponseType,
}
impl ::std::convert::From<&SetVariableResponse> for SetVariableResponse {
    fn from(value: &SetVariableResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SetVariableResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"indexedVariables\": {"]
#[doc = "      \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"A memory reference to a location appropriate for this result.\\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namedVariables\": {"]
#[doc = "      \"description\": \"The number of named child variables.\\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"The type of the new value. Typically shown in the UI when hovering over the value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The new value of the variable.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"valueLocationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"If `variablesReference` is > 0, the new value is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\\n\\nIf this property is included in the response, any `variablesReference` previously associated with the updated variable, and those of its children, are no longer valid.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetVariableResponseBody {
    #[doc = "The number of indexed child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "indexedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub indexed_variables: ::std::option::Option<i64>,
    #[doc = "A memory reference to a location appropriate for this result.\nFor pointer type eval results, this is generally a reference to the memory address contained in the pointer.\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true."]
    #[serde(
        rename = "memoryReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub memory_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The number of named child variables.\nThe client can use this information to present the variables in a paged UI and fetch them in chunks.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "namedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub named_variables: ::std::option::Option<i64>,
    #[doc = "The type of the new value. Typically shown in the UI when hovering over the value."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[doc = "The new value of the variable."]
    pub value: ::std::string::String,
    #[doc = "A reference that allows the client to request the location where the new value is declared. For example, if the new value is function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "valueLocationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub value_location_reference: ::std::option::Option<i64>,
    #[doc = "If `variablesReference` is > 0, the new value is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\n\nIf this property is included in the response, any `variablesReference` previously associated with the updated variable, and those of its children, are no longer valid."]
    #[serde(
        rename = "variablesReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub variables_reference: ::std::option::Option<i64>,
}
impl ::std::convert::From<&SetVariableResponseBody> for SetVariableResponseBody {
    fn from(value: &SetVariableResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SetVariableResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SetVariableResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SetVariableResponseType {
    fn from(value: &SetVariableResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SetVariableResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SetVariableResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SetVariableResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SetVariableResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SetVariableResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `Source` is a descriptor for source code.\nIt is returned from the debug adapter as part of a `StackFrame` and it is used by clients when specifying breakpoints."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `Source` is a descriptor for source code.\\nIt is returned from the debug adapter as part of a `StackFrame` and it is used by clients when specifying breakpoints.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"adapterData\": {"]
#[doc = "      \"description\": \"Additional data that a debug adapter might want to loop through the client.\\nThe client should leave the data intact and persist it across sessions. The client should not interpret the data.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"boolean\","]
#[doc = "        \"integer\","]
#[doc = "        \"null\","]
#[doc = "        \"number\","]
#[doc = "        \"object\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"checksums\": {"]
#[doc = "      \"description\": \"The checksums associated with this file.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Checksum\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The short name of the source. Every source returned from the debug adapter has a name.\\nWhen sending a source to the debug adapter this name is optional.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"origin\": {"]
#[doc = "      \"description\": \"The origin of this source. For example, 'internal module', 'inlined content from source map', etc.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"description\": \"The path of the source to be shown in the UI.\\nIt is only used to locate and load the content of the source if no `sourceReference` is specified (or its value is 0).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"A hint for how to present the source in the UI.\\nA value of `deemphasize` can be used to indicate that the source is not available or that it is skipped on stepping.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"normal\","]
#[doc = "        \"emphasize\","]
#[doc = "        \"deemphasize\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sourceReference\": {"]
#[doc = "      \"description\": \"If the value > 0 the contents of the source must be retrieved through the `source` request (even if a path is specified).\\nSince a `sourceReference` is only valid for a session, it can not be used to persist a source.\\nThe value should be less than or equal to 2147483647 (2^31-1).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"sources\": {"]
#[doc = "      \"description\": \"A list of sources that are related to this source. These may be the source that generated this source.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Source\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Source {
    #[doc = "Additional data that a debug adapter might want to loop through the client.\nThe client should leave the data intact and persist it across sessions. The client should not interpret the data."]
    #[serde(
        rename = "adapterData",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub adapter_data: ::std::option::Option<::serde_json::Value>,
    #[doc = "The checksums associated with this file."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub checksums: ::std::vec::Vec<Checksum>,
    #[doc = "The short name of the source. Every source returned from the debug adapter has a name.\nWhen sending a source to the debug adapter this name is optional."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The origin of this source. For example, 'internal module', 'inlined content from source map', etc."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub origin: ::std::option::Option<::std::string::String>,
    #[doc = "The path of the source to be shown in the UI.\nIt is only used to locate and load the content of the source if no `sourceReference` is specified (or its value is 0)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[doc = "A hint for how to present the source in the UI.\nA value of `deemphasize` can be used to indicate that the source is not available or that it is skipped on stepping."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<SourcePresentationHint>,
    #[doc = "If the value > 0 the contents of the source must be retrieved through the `source` request (even if a path is specified).\nSince a `sourceReference` is only valid for a session, it can not be used to persist a source.\nThe value should be less than or equal to 2147483647 (2^31-1)."]
    #[serde(
        rename = "sourceReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub source_reference: ::std::option::Option<i64>,
    #[doc = "A list of sources that are related to this source. These may be the source that generated this source."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub sources: ::std::vec::Vec<Source>,
}
impl ::std::convert::From<&Source> for Source {
    fn from(value: &Source) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Source {
    fn default() -> Self {
        Self {
            adapter_data: Default::default(),
            checksums: Default::default(),
            name: Default::default(),
            origin: Default::default(),
            path: Default::default(),
            presentation_hint: Default::default(),
            source_reference: Default::default(),
            sources: Default::default(),
        }
    }
}
#[doc = "Arguments for `source` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `source` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"sourceReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"Specifies the source content to load. Either `source.path` or `source.sourceReference` must be specified.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    },"]
#[doc = "    \"sourceReference\": {"]
#[doc = "      \"description\": \"The reference to the source. This is the same as `source.sourceReference`.\\nThis is provided for backward compatibility since old clients do not understand the `source` attribute.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SourceArguments {
    #[doc = "Specifies the source content to load. Either `source.path` or `source.sourceReference` must be specified."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
    #[doc = "The reference to the source. This is the same as `source.sourceReference`.\nThis is provided for backward compatibility since old clients do not understand the `source` attribute."]
    #[serde(rename = "sourceReference")]
    pub source_reference: i64,
}
impl ::std::convert::From<&SourceArguments> for SourceArguments {
    fn from(value: &SourceArguments) -> Self {
        value.clone()
    }
}
#[doc = "Properties of a breakpoint or logpoint passed to the `setBreakpoints` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a breakpoint or logpoint passed to the `setBreakpoints` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"line\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position within source line of the breakpoint or logpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"condition\": {"]
#[doc = "      \"description\": \"The expression for conditional breakpoints.\\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hitCondition\": {"]
#[doc = "      \"description\": \"The expression that controls how many hits of the breakpoint are ignored.\\nThe debug adapter is expected to interpret the expression as needed.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.\\nIf both this property and `condition` are specified, `hitCondition` should be evaluated only if the `condition` is met, and the debug adapter should stop only if both conditions are met.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The source line of the breakpoint or logpoint.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"logMessage\": {"]
#[doc = "      \"description\": \"If this attribute exists and is non-empty, the debug adapter must not 'break' (stop)\\nbut log the message instead. Expressions within `{}` are interpolated.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsLogPoints` is true.\\nIf either `hitCondition` or `condition` is specified, then the message should only be logged if those conditions are met.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The mode of this breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SourceBreakpoint {
    #[doc = "Start position within source line of the breakpoint or logpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "The expression for conditional breakpoints.\nIt is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<::std::string::String>,
    #[doc = "The expression that controls how many hits of the breakpoint are ignored.\nThe debug adapter is expected to interpret the expression as needed.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.\nIf both this property and `condition` are specified, `hitCondition` should be evaluated only if the `condition` is met, and the debug adapter should stop only if both conditions are met."]
    #[serde(
        rename = "hitCondition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub hit_condition: ::std::option::Option<::std::string::String>,
    #[doc = "The source line of the breakpoint or logpoint."]
    pub line: i64,
    #[doc = "If this attribute exists and is non-empty, the debug adapter must not 'break' (stop)\nbut log the message instead. Expressions within `{}` are interpolated.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsLogPoints` is true.\nIf either `hitCondition` or `condition` is specified, then the message should only be logged if those conditions are met."]
    #[serde(
        rename = "logMessage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub log_message: ::std::option::Option<::std::string::String>,
    #[doc = "The mode of this breakpoint. If defined, this must be one of the `breakpointModes` the debug adapter advertised in its `Capabilities`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SourceBreakpoint> for SourceBreakpoint {
    fn from(value: &SourceBreakpoint) -> Self {
        value.clone()
    }
}
#[doc = "A hint for how to present the source in the UI.\nA value of `deemphasize` can be used to indicate that the source is not available or that it is skipped on stepping."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A hint for how to present the source in the UI.\\nA value of `deemphasize` can be used to indicate that the source is not available or that it is skipped on stepping.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"normal\","]
#[doc = "    \"emphasize\","]
#[doc = "    \"deemphasize\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SourcePresentationHint {
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "emphasize")]
    Emphasize,
    #[serde(rename = "deemphasize")]
    Deemphasize,
}
impl ::std::convert::From<&Self> for SourcePresentationHint {
    fn from(value: &SourcePresentationHint) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SourcePresentationHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Normal => f.write_str("normal"),
            Self::Emphasize => f.write_str("emphasize"),
            Self::Deemphasize => f.write_str("deemphasize"),
        }
    }
}
impl ::std::str::FromStr for SourcePresentationHint {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "normal" => Ok(Self::Normal),
            "emphasize" => Ok(Self::Emphasize),
            "deemphasize" => Ok(Self::Deemphasize),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SourcePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SourcePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SourcePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SourceRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request retrieves the source code for a given source reference.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/SourceArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"source\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SourceRequest {
    pub arguments: SourceArguments,
    pub command: SourceRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: SourceRequestType,
}
impl ::std::convert::From<&SourceRequest> for SourceRequest {
    fn from(value: &SourceRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SourceRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"source\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SourceRequestCommand {
    #[serde(rename = "source")]
    Source,
}
impl ::std::convert::From<&Self> for SourceRequestCommand {
    fn from(value: &SourceRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SourceRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Source => f.write_str("source"),
        }
    }
}
impl ::std::str::FromStr for SourceRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "source" => Ok(Self::Source),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SourceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SourceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SourceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SourceRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SourceRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for SourceRequestType {
    fn from(value: &SourceRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SourceRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for SourceRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SourceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SourceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SourceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SourceResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `source` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"content\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"content\": {"]
#[doc = "              \"description\": \"Content of the source reference.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"mimeType\": {"]
#[doc = "              \"description\": \"Content type (MIME type) of the source.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SourceResponse {
    pub body: SourceResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: SourceResponseType,
}
impl ::std::convert::From<&SourceResponse> for SourceResponse {
    fn from(value: &SourceResponse) -> Self {
        value.clone()
    }
}
#[doc = "`SourceResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content\": {"]
#[doc = "      \"description\": \"Content of the source reference.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"Content type (MIME type) of the source.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SourceResponseBody {
    #[doc = "Content of the source reference."]
    pub content: ::std::string::String,
    #[doc = "Content type (MIME type) of the source."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SourceResponseBody> for SourceResponseBody {
    fn from(value: &SourceResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`SourceResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SourceResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for SourceResponseType {
    fn from(value: &SourceResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SourceResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for SourceResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SourceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SourceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SourceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Stackframe contains the source location."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A Stackframe contains the source location.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"column\","]
#[doc = "    \"id\","]
#[doc = "    \"line\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"canRestart\": {"]
#[doc = "      \"description\": \"Indicates whether this frame can be restarted with the `restartFrame` request. Clients should only use this if the debug adapter supports the `restart` request and the corresponding capability `supportsRestartFrame` is true. If a debug adapter has this capability, then `canRestart` defaults to `true` if the property is absent.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If attribute `source` is missing or doesn't exist, `column` is 0 and should be ignored by the client.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the range covered by the stack frame.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An identifier for the stack frame. It must be unique across all threads.\\nThis id can be used to retrieve the scopes of the frame with the `scopes` request or to restart the execution of a stack frame.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"instructionPointerReference\": {"]
#[doc = "      \"description\": \"A memory reference for the current instruction pointer in this frame.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line within the source of the frame. If the source attribute is missing or doesn't exist, `line` is 0 and should be ignored by the client.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"moduleId\": {"]
#[doc = "      \"description\": \"The module associated with this frame, if any.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the stack frame, typically a method name.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"A hint for how to present this frame in the UI.\\nA value of `label` can be used to indicate that the frame is an artificial frame that is used as a visual label or separator. A value of `subtle` can be used to change the appearance of a frame in a 'subtle' way.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"normal\","]
#[doc = "        \"label\","]
#[doc = "        \"subtle\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"description\": \"The source of the frame.\","]
#[doc = "      \"$ref\": \"#/definitions/Source\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackFrame {
    #[doc = "Indicates whether this frame can be restarted with the `restartFrame` request. Clients should only use this if the debug adapter supports the `restart` request and the corresponding capability `supportsRestartFrame` is true. If a debug adapter has this capability, then `canRestart` defaults to `true` if the property is absent."]
    #[serde(
        rename = "canRestart",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub can_restart: ::std::option::Option<bool>,
    #[doc = "Start position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If attribute `source` is missing or doesn't exist, `column` is 0 and should be ignored by the client."]
    pub column: i64,
    #[doc = "End position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the range covered by the stack frame."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "An identifier for the stack frame. It must be unique across all threads.\nThis id can be used to retrieve the scopes of the frame with the `scopes` request or to restart the execution of a stack frame."]
    pub id: i64,
    #[doc = "A memory reference for the current instruction pointer in this frame."]
    #[serde(
        rename = "instructionPointerReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub instruction_pointer_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The line within the source of the frame. If the source attribute is missing or doesn't exist, `line` is 0 and should be ignored by the client."]
    pub line: i64,
    #[doc = "The module associated with this frame, if any."]
    #[serde(
        rename = "moduleId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub module_id: ::std::option::Option<StackFrameModuleId>,
    #[doc = "The name of the stack frame, typically a method name."]
    pub name: ::std::string::String,
    #[doc = "A hint for how to present this frame in the UI.\nA value of `label` can be used to indicate that the frame is an artificial frame that is used as a visual label or separator. A value of `subtle` can be used to change the appearance of a frame in a 'subtle' way."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<StackFramePresentationHint>,
    #[doc = "The source of the frame."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<Source>,
}
impl ::std::convert::From<&StackFrame> for StackFrame {
    fn from(value: &StackFrame) -> Self {
        value.clone()
    }
}
#[doc = "`StackFrameFormat`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/ValueFormat\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Provides formatting information for a stack frame.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"includeAll\": {"]
#[doc = "          \"description\": \"Includes all stack frames, including those the debug adapter might otherwise hide.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"line\": {"]
#[doc = "          \"description\": \"Displays the line number of the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"module\": {"]
#[doc = "          \"description\": \"Displays the module of the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"parameterNames\": {"]
#[doc = "          \"description\": \"Displays the names of parameters for the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"parameterTypes\": {"]
#[doc = "          \"description\": \"Displays the types of parameters for the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"parameterValues\": {"]
#[doc = "          \"description\": \"Displays the values of parameters for the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"parameters\": {"]
#[doc = "          \"description\": \"Displays parameters for the stack frame.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackFrameFormat {
    #[doc = "Display the value in hex."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub hex: ::std::option::Option<bool>,
    #[doc = "Includes all stack frames, including those the debug adapter might otherwise hide."]
    #[serde(
        rename = "includeAll",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub include_all: ::std::option::Option<bool>,
    #[doc = "Displays the line number of the stack frame."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<bool>,
    #[doc = "Displays the module of the stack frame."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub module: ::std::option::Option<bool>,
    #[doc = "Displays the names of parameters for the stack frame."]
    #[serde(
        rename = "parameterNames",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub parameter_names: ::std::option::Option<bool>,
    #[doc = "Displays the types of parameters for the stack frame."]
    #[serde(
        rename = "parameterTypes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub parameter_types: ::std::option::Option<bool>,
    #[doc = "Displays the values of parameters for the stack frame."]
    #[serde(
        rename = "parameterValues",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub parameter_values: ::std::option::Option<bool>,
    #[doc = "Displays parameters for the stack frame."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parameters: ::std::option::Option<bool>,
}
impl ::std::convert::From<&StackFrameFormat> for StackFrameFormat {
    fn from(value: &StackFrameFormat) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StackFrameFormat {
    fn default() -> Self {
        Self {
            hex: Default::default(),
            include_all: Default::default(),
            line: Default::default(),
            module: Default::default(),
            parameter_names: Default::default(),
            parameter_types: Default::default(),
            parameter_values: Default::default(),
            parameters: Default::default(),
        }
    }
}
#[doc = "The module associated with this frame, if any."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The module associated with this frame, if any.\","]
#[doc = "  \"type\": ["]
#[doc = "    \"integer\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackFrameModuleId {
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for StackFrameModuleId {
    fn from(value: &StackFrameModuleId) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackFrameModuleId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::String(x) => x.fmt(f),
            Self::Integer(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for StackFrameModuleId {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
#[doc = "A hint for how to present this frame in the UI.\nA value of `label` can be used to indicate that the frame is an artificial frame that is used as a visual label or separator. A value of `subtle` can be used to change the appearance of a frame in a 'subtle' way."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A hint for how to present this frame in the UI.\\nA value of `label` can be used to indicate that the frame is an artificial frame that is used as a visual label or separator. A value of `subtle` can be used to change the appearance of a frame in a 'subtle' way.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"normal\","]
#[doc = "    \"label\","]
#[doc = "    \"subtle\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackFramePresentationHint {
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "subtle")]
    Subtle,
}
impl ::std::convert::From<&Self> for StackFramePresentationHint {
    fn from(value: &StackFramePresentationHint) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackFramePresentationHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Normal => f.write_str("normal"),
            Self::Label => f.write_str("label"),
            Self::Subtle => f.write_str("subtle"),
        }
    }
}
impl ::std::str::FromStr for StackFramePresentationHint {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "normal" => Ok(Self::Normal),
            "label" => Ok(Self::Label),
            "subtle" => Ok(Self::Subtle),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackFramePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackFramePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackFramePresentationHint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `stackTrace` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `stackTrace` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Specifies details on how to format the returned `StackFrame.name`. The debug adapter may format requested details in any way that would make sense to a developer.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.\","]
#[doc = "      \"$ref\": \"#/definitions/StackFrameFormat\""]
#[doc = "    },"]
#[doc = "    \"levels\": {"]
#[doc = "      \"description\": \"The maximum number of frames to return. If levels is not specified or 0, all frames are returned.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"startFrame\": {"]
#[doc = "      \"description\": \"The index of the first frame to return; if omitted frames start at 0.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Retrieve the stacktrace for this thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackTraceArguments {
    #[doc = "Specifies details on how to format the returned `StackFrame.name`. The debug adapter may format requested details in any way that would make sense to a developer.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<StackFrameFormat>,
    #[doc = "The maximum number of frames to return. If levels is not specified or 0, all frames are returned."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub levels: ::std::option::Option<i64>,
    #[doc = "The index of the first frame to return; if omitted frames start at 0."]
    #[serde(
        rename = "startFrame",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_frame: ::std::option::Option<i64>,
    #[doc = "Retrieve the stacktrace for this thread."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&StackTraceArguments> for StackTraceArguments {
    fn from(value: &StackTraceArguments) -> Self {
        value.clone()
    }
}
#[doc = "`StackTraceRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request returns a stacktrace from the current execution state of a given thread.\\nA client can request all stack frames by omitting the startFrame and levels arguments. For performance-conscious clients and if the corresponding capability `supportsDelayedStackTraceLoading` is true, stack frames can be retrieved in a piecemeal way with the `startFrame` and `levels` arguments. The response of the `stackTrace` request may contain a `totalFrames` property that hints at the total number of frames in the stack. If a client needs this total number upfront, it can issue a request for a single (first) frame and depending on the value of `totalFrames` decide how to proceed. In any case a client should be prepared to receive fewer frames than requested, which is an indication that the end of the stack has been reached.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StackTraceArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stackTrace\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackTraceRequest {
    pub arguments: StackTraceArguments,
    pub command: StackTraceRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StackTraceRequestType,
}
impl ::std::convert::From<&StackTraceRequest> for StackTraceRequest {
    fn from(value: &StackTraceRequest) -> Self {
        value.clone()
    }
}
#[doc = "`StackTraceRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stackTrace\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackTraceRequestCommand {
    #[serde(rename = "stackTrace")]
    StackTrace,
}
impl ::std::convert::From<&Self> for StackTraceRequestCommand {
    fn from(value: &StackTraceRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackTraceRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StackTrace => f.write_str("stackTrace"),
        }
    }
}
impl ::std::str::FromStr for StackTraceRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stackTrace" => Ok(Self::StackTrace),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackTraceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackTraceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackTraceRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StackTraceRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackTraceRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StackTraceRequestType {
    fn from(value: &StackTraceRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackTraceRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StackTraceRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackTraceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackTraceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackTraceRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StackTraceResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `stackTrace` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stackFrames\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"stackFrames\": {"]
#[doc = "              \"description\": \"The frames of the stack frame. If the array has length zero, there are no stack frames available.\\nThis means that there is no location information available.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/StackFrame\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"totalFrames\": {"]
#[doc = "              \"description\": \"The total number of frames available in the stack. If omitted or if `totalFrames` is larger than the available frames, a client is expected to request frames until a request returns less frames than requested (which indicates the end of the stack). Returning monotonically increasing `totalFrames` values for subsequent requests can be used to enforce paging in the client.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackTraceResponse {
    pub body: StackTraceResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StackTraceResponseType,
}
impl ::std::convert::From<&StackTraceResponse> for StackTraceResponse {
    fn from(value: &StackTraceResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StackTraceResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"stackFrames\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"stackFrames\": {"]
#[doc = "      \"description\": \"The frames of the stack frame. If the array has length zero, there are no stack frames available.\\nThis means that there is no location information available.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/StackFrame\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"totalFrames\": {"]
#[doc = "      \"description\": \"The total number of frames available in the stack. If omitted or if `totalFrames` is larger than the available frames, a client is expected to request frames until a request returns less frames than requested (which indicates the end of the stack). Returning monotonically increasing `totalFrames` values for subsequent requests can be used to enforce paging in the client.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StackTraceResponseBody {
    #[doc = "The frames of the stack frame. If the array has length zero, there are no stack frames available.\nThis means that there is no location information available."]
    #[serde(rename = "stackFrames")]
    pub stack_frames: ::std::vec::Vec<StackFrame>,
    #[doc = "The total number of frames available in the stack. If omitted or if `totalFrames` is larger than the available frames, a client is expected to request frames until a request returns less frames than requested (which indicates the end of the stack). Returning monotonically increasing `totalFrames` values for subsequent requests can be used to enforce paging in the client."]
    #[serde(
        rename = "totalFrames",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_frames: ::std::option::Option<i64>,
}
impl ::std::convert::From<&StackTraceResponseBody> for StackTraceResponseBody {
    fn from(value: &StackTraceResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`StackTraceResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackTraceResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StackTraceResponseType {
    fn from(value: &StackTraceResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackTraceResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StackTraceResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackTraceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackTraceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackTraceResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StartDebuggingRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This request is sent from the debug adapter to the client to start a new debug session of the same type as the caller.\\nThis request should only be sent if the corresponding client capability `supportsStartDebuggingRequest` is true.\\nA client implementation of `startDebugging` should start a new debug session (of the same type as the caller) in the same way that the caller's session was started. If the client supports hierarchical debug sessions, the newly created session can be treated as a child of the caller session.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StartDebuggingRequestArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"startDebugging\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StartDebuggingRequest {
    pub arguments: StartDebuggingRequestArguments,
    pub command: StartDebuggingRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StartDebuggingRequestType,
}
impl ::std::convert::From<&StartDebuggingRequest> for StartDebuggingRequest {
    fn from(value: &StartDebuggingRequest) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `startDebugging` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `startDebugging` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"configuration\","]
#[doc = "    \"request\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"configuration\": {"]
#[doc = "      \"description\": \"Arguments passed to the new debug session. The arguments must only contain properties understood by the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties (e.g. `type`) or client-specific features (e.g. substitutable 'variables').\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"request\": {"]
#[doc = "      \"description\": \"Indicates whether the new debug session should be started with a `launch` or `attach` request.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"launch\","]
#[doc = "        \"attach\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StartDebuggingRequestArguments {
    #[doc = "Arguments passed to the new debug session. The arguments must only contain properties understood by the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties (e.g. `type`) or client-specific features (e.g. substitutable 'variables')."]
    pub configuration: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Indicates whether the new debug session should be started with a `launch` or `attach` request."]
    pub request: StartDebuggingRequestArgumentsRequest,
}
impl ::std::convert::From<&StartDebuggingRequestArguments> for StartDebuggingRequestArguments {
    fn from(value: &StartDebuggingRequestArguments) -> Self {
        value.clone()
    }
}
#[doc = "Indicates whether the new debug session should be started with a `launch` or `attach` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Indicates whether the new debug session should be started with a `launch` or `attach` request.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"launch\","]
#[doc = "    \"attach\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StartDebuggingRequestArgumentsRequest {
    #[serde(rename = "launch")]
    Launch,
    #[serde(rename = "attach")]
    Attach,
}
impl ::std::convert::From<&Self> for StartDebuggingRequestArgumentsRequest {
    fn from(value: &StartDebuggingRequestArgumentsRequest) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StartDebuggingRequestArgumentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Launch => f.write_str("launch"),
            Self::Attach => f.write_str("attach"),
        }
    }
}
impl ::std::str::FromStr for StartDebuggingRequestArgumentsRequest {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "launch" => Ok(Self::Launch),
            "attach" => Ok(Self::Attach),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StartDebuggingRequestArgumentsRequest {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StartDebuggingRequestArgumentsRequest {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StartDebuggingRequestArgumentsRequest {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StartDebuggingRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"startDebugging\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StartDebuggingRequestCommand {
    #[serde(rename = "startDebugging")]
    StartDebugging,
}
impl ::std::convert::From<&Self> for StartDebuggingRequestCommand {
    fn from(value: &StartDebuggingRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StartDebuggingRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StartDebugging => f.write_str("startDebugging"),
        }
    }
}
impl ::std::str::FromStr for StartDebuggingRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "startDebugging" => Ok(Self::StartDebugging),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StartDebuggingRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StartDebuggingRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StartDebuggingRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StartDebuggingRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StartDebuggingRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StartDebuggingRequestType {
    fn from(value: &StartDebuggingRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StartDebuggingRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StartDebuggingRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StartDebuggingRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StartDebuggingRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StartDebuggingRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StartDebuggingResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `startDebugging` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StartDebuggingResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StartDebuggingResponseType,
}
impl ::std::convert::From<&StartDebuggingResponse> for StartDebuggingResponse {
    fn from(value: &StartDebuggingResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StartDebuggingResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StartDebuggingResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StartDebuggingResponseType {
    fn from(value: &StartDebuggingResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StartDebuggingResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StartDebuggingResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StartDebuggingResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StartDebuggingResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StartDebuggingResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `stepBack` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `stepBack` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"granularity\": {"]
#[doc = "      \"description\": \"Stepping granularity to step. If no granularity is specified, a granularity of `statement` is assumed.\","]
#[doc = "      \"$ref\": \"#/definitions/SteppingGranularity\""]
#[doc = "    },"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, all other suspended threads are not resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the thread for which to resume execution for one step backwards (of the given granularity).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepBackArguments {
    #[doc = "Stepping granularity to step. If no granularity is specified, a granularity of `statement` is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub granularity: ::std::option::Option<SteppingGranularity>,
    #[doc = "If this flag is true, all other suspended threads are not resumed."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Specifies the thread for which to resume execution for one step backwards (of the given granularity)."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&StepBackArguments> for StepBackArguments {
    fn from(value: &StepBackArguments) -> Self {
        value.clone()
    }
}
#[doc = "`StepBackRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request executes one backward step (in the given granularity) for the specified thread and allows all other threads to run backward freely by resuming them.\\nIf the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true prevents other suspended threads from resuming.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `step`) after the step has completed.\\nClients should only call this request if the corresponding capability `supportsStepBack` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StepBackArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stepBack\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepBackRequest {
    pub arguments: StepBackArguments,
    pub command: StepBackRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StepBackRequestType,
}
impl ::std::convert::From<&StepBackRequest> for StepBackRequest {
    fn from(value: &StepBackRequest) -> Self {
        value.clone()
    }
}
#[doc = "`StepBackRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stepBack\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepBackRequestCommand {
    #[serde(rename = "stepBack")]
    StepBack,
}
impl ::std::convert::From<&Self> for StepBackRequestCommand {
    fn from(value: &StepBackRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepBackRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StepBack => f.write_str("stepBack"),
        }
    }
}
impl ::std::str::FromStr for StepBackRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stepBack" => Ok(Self::StepBack),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepBackRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepBackRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepBackRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepBackRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepBackRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StepBackRequestType {
    fn from(value: &StepBackRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepBackRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StepBackRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepBackRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepBackRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepBackRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepBackResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `stepBack` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepBackResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StepBackResponseType,
}
impl ::std::convert::From<&StepBackResponse> for StepBackResponse {
    fn from(value: &StepBackResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StepBackResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepBackResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StepBackResponseType {
    fn from(value: &StepBackResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepBackResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StepBackResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepBackResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepBackResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepBackResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `stepIn` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `stepIn` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"granularity\": {"]
#[doc = "      \"description\": \"Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.\","]
#[doc = "      \"$ref\": \"#/definitions/SteppingGranularity\""]
#[doc = "    },"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, all other suspended threads are not resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"targetId\": {"]
#[doc = "      \"description\": \"Id of the target to step into.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the thread for which to resume execution for one step-into (of the given granularity).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInArguments {
    #[doc = "Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub granularity: ::std::option::Option<SteppingGranularity>,
    #[doc = "If this flag is true, all other suspended threads are not resumed."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Id of the target to step into."]
    #[serde(
        rename = "targetId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub target_id: ::std::option::Option<i64>,
    #[doc = "Specifies the thread for which to resume execution for one step-into (of the given granularity)."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&StepInArguments> for StepInArguments {
    fn from(value: &StepInArguments) -> Self {
        value.clone()
    }
}
#[doc = "`StepInRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request resumes the given thread to step into a function/method and allows all other threads to run freely by resuming them.\\nIf the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true prevents other suspended threads from resuming.\\nIf the request cannot step into a target, `stepIn` behaves like the `next` request.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `step`) after the step has completed.\\nIf there are multiple function/method calls (or other targets) on the source line,\\nthe argument `targetId` can be used to control into which target the `stepIn` should occur.\\nThe list of possible targets for a given source line can be retrieved via the `stepInTargets` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StepInArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stepIn\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInRequest {
    pub arguments: StepInArguments,
    pub command: StepInRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StepInRequestType,
}
impl ::std::convert::From<&StepInRequest> for StepInRequest {
    fn from(value: &StepInRequest) -> Self {
        value.clone()
    }
}
#[doc = "`StepInRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stepIn\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInRequestCommand {
    #[serde(rename = "stepIn")]
    StepIn,
}
impl ::std::convert::From<&Self> for StepInRequestCommand {
    fn from(value: &StepInRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StepIn => f.write_str("stepIn"),
        }
    }
}
impl ::std::str::FromStr for StepInRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stepIn" => Ok(Self::StepIn),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepInRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StepInRequestType {
    fn from(value: &StepInRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StepInRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepInResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `stepIn` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StepInResponseType,
}
impl ::std::convert::From<&StepInResponse> for StepInResponse {
    fn from(value: &StepInResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StepInResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StepInResponseType {
    fn from(value: &StepInResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StepInResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A `StepInTarget` can be used in the `stepIn` request and determines into which single target the `stepIn` request should step."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A `StepInTarget` can be used in the `stepIn` request and determines into which single target the `stepIn` request should step.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"label\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column\": {"]
#[doc = "      \"description\": \"Start position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endColumn\": {"]
#[doc = "      \"description\": \"End position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"endLine\": {"]
#[doc = "      \"description\": \"The end line of the range covered by the step-in target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier for a step-in target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The name of the step-in target (shown in the UI).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line of the step-in target.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInTarget {
    #[doc = "Start position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub column: ::std::option::Option<i64>,
    #[doc = "End position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based."]
    #[serde(
        rename = "endColumn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_column: ::std::option::Option<i64>,
    #[doc = "The end line of the range covered by the step-in target."]
    #[serde(
        rename = "endLine",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_line: ::std::option::Option<i64>,
    #[doc = "Unique identifier for a step-in target."]
    pub id: i64,
    #[doc = "The name of the step-in target (shown in the UI)."]
    pub label: ::std::string::String,
    #[doc = "The line of the step-in target."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&StepInTarget> for StepInTarget {
    fn from(value: &StepInTarget) -> Self {
        value.clone()
    }
}
#[doc = "Arguments for `stepInTargets` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `stepInTargets` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"frameId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"frameId\": {"]
#[doc = "      \"description\": \"The stack frame for which to retrieve the possible step-in targets.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInTargetsArguments {
    #[doc = "The stack frame for which to retrieve the possible step-in targets."]
    #[serde(rename = "frameId")]
    pub frame_id: i64,
}
impl ::std::convert::From<&StepInTargetsArguments> for StepInTargetsArguments {
    fn from(value: &StepInTargetsArguments) -> Self {
        value.clone()
    }
}
#[doc = "`StepInTargetsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This request retrieves the possible step-in targets for the specified stack frame.\\nThese targets can be used in the `stepIn` request.\\nClients should only call this request if the corresponding capability `supportsStepInTargetsRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StepInTargetsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stepInTargets\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInTargetsRequest {
    pub arguments: StepInTargetsArguments,
    pub command: StepInTargetsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StepInTargetsRequestType,
}
impl ::std::convert::From<&StepInTargetsRequest> for StepInTargetsRequest {
    fn from(value: &StepInTargetsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`StepInTargetsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stepInTargets\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInTargetsRequestCommand {
    #[serde(rename = "stepInTargets")]
    StepInTargets,
}
impl ::std::convert::From<&Self> for StepInTargetsRequestCommand {
    fn from(value: &StepInTargetsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInTargetsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StepInTargets => f.write_str("stepInTargets"),
        }
    }
}
impl ::std::str::FromStr for StepInTargetsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stepInTargets" => Ok(Self::StepInTargets),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInTargetsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepInTargetsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInTargetsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StepInTargetsRequestType {
    fn from(value: &StepInTargetsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInTargetsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StepInTargetsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInTargetsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepInTargetsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `stepInTargets` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"targets\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"targets\": {"]
#[doc = "              \"description\": \"The possible step-in targets of the specified source location.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/StepInTarget\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInTargetsResponse {
    pub body: StepInTargetsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StepInTargetsResponseType,
}
impl ::std::convert::From<&StepInTargetsResponse> for StepInTargetsResponse {
    fn from(value: &StepInTargetsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StepInTargetsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"targets\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"targets\": {"]
#[doc = "      \"description\": \"The possible step-in targets of the specified source location.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/StepInTarget\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepInTargetsResponseBody {
    #[doc = "The possible step-in targets of the specified source location."]
    pub targets: ::std::vec::Vec<StepInTarget>,
}
impl ::std::convert::From<&StepInTargetsResponseBody> for StepInTargetsResponseBody {
    fn from(value: &StepInTargetsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`StepInTargetsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepInTargetsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StepInTargetsResponseType {
    fn from(value: &StepInTargetsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepInTargetsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StepInTargetsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepInTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepInTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepInTargetsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `stepOut` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `stepOut` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"granularity\": {"]
#[doc = "      \"description\": \"Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.\","]
#[doc = "      \"$ref\": \"#/definitions/SteppingGranularity\""]
#[doc = "    },"]
#[doc = "    \"singleThread\": {"]
#[doc = "      \"description\": \"If this flag is true, all other suspended threads are not resumed.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"Specifies the thread for which to resume execution for one step-out (of the given granularity).\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepOutArguments {
    #[doc = "Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub granularity: ::std::option::Option<SteppingGranularity>,
    #[doc = "If this flag is true, all other suspended threads are not resumed."]
    #[serde(
        rename = "singleThread",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub single_thread: ::std::option::Option<bool>,
    #[doc = "Specifies the thread for which to resume execution for one step-out (of the given granularity)."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&StepOutArguments> for StepOutArguments {
    fn from(value: &StepOutArguments) -> Self {
        value.clone()
    }
}
#[doc = "`StepOutRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request resumes the given thread to step out (return) from a function/method and allows all other threads to run freely by resuming them.\\nIf the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument to true prevents other suspended threads from resuming.\\nThe debug adapter first sends the response and then a `stopped` event (with reason `step`) after the step has completed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/StepOutArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stepOut\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepOutRequest {
    pub arguments: StepOutArguments,
    pub command: StepOutRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StepOutRequestType,
}
impl ::std::convert::From<&StepOutRequest> for StepOutRequest {
    fn from(value: &StepOutRequest) -> Self {
        value.clone()
    }
}
#[doc = "`StepOutRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stepOut\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepOutRequestCommand {
    #[serde(rename = "stepOut")]
    StepOut,
}
impl ::std::convert::From<&Self> for StepOutRequestCommand {
    fn from(value: &StepOutRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepOutRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::StepOut => f.write_str("stepOut"),
        }
    }
}
impl ::std::str::FromStr for StepOutRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stepOut" => Ok(Self::StepOut),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepOutRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepOutRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepOutRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepOutRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepOutRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for StepOutRequestType {
    fn from(value: &StepOutRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepOutRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for StepOutRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepOutRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepOutRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepOutRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StepOutResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `stepOut` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StepOutResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: StepOutResponseType,
}
impl ::std::convert::From<&StepOutResponse> for StepOutResponse {
    fn from(value: &StepOutResponse) -> Self {
        value.clone()
    }
}
#[doc = "`StepOutResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StepOutResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for StepOutResponseType {
    fn from(value: &StepOutResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StepOutResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for StepOutResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StepOutResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StepOutResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StepOutResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The granularity of one 'step' in the stepping requests `next`, `stepIn`, `stepOut`, and `stepBack`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The granularity of one 'step' in the stepping requests `next`, `stepIn`, `stepOut`, and `stepBack`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"statement\","]
#[doc = "    \"line\","]
#[doc = "    \"instruction\""]
#[doc = "  ],"]
#[doc = "  \"enumDescriptions\": ["]
#[doc = "    \"The step should allow the program to run until the current statement has finished executing.\\nThe meaning of a statement is determined by the adapter and it may be considered equivalent to a line.\\nFor example 'for(int i = 0; i < 10; i++)' could be considered to have 3 statements 'int i = 0', 'i < 10', and 'i++'.\","]
#[doc = "    \"The step should allow the program to run until the current source line has executed.\","]
#[doc = "    \"The step should allow one instruction to execute (e.g. one x86 instruction).\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SteppingGranularity {
    #[serde(rename = "statement")]
    Statement,
    #[serde(rename = "line")]
    Line,
    #[serde(rename = "instruction")]
    Instruction,
}
impl ::std::convert::From<&Self> for SteppingGranularity {
    fn from(value: &SteppingGranularity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SteppingGranularity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Statement => f.write_str("statement"),
            Self::Line => f.write_str("line"),
            Self::Instruction => f.write_str("instruction"),
        }
    }
}
impl ::std::str::FromStr for SteppingGranularity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "statement" => Ok(Self::Statement),
            "line" => Ok(Self::Line),
            "instruction" => Ok(Self::Instruction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SteppingGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SteppingGranularity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SteppingGranularity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StoppedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that the execution of the debuggee has stopped due to some condition.\\nThis can be caused by a breakpoint previously set, a stepping request has completed, by executing a debugger statement etc.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"reason\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"allThreadsStopped\": {"]
#[doc = "              \"description\": \"If `allThreadsStopped` is true, a debug adapter can announce that all threads have stopped.\\n- The client should use this information to enable that all threads can be expanded to access their stacktraces.\\n- If the attribute is missing or false, only the thread with the given `threadId` can be expanded.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and can be translated.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"hitBreakpointIds\": {"]
#[doc = "              \"description\": \"Ids of the breakpoints that triggered the event. In most cases there is only a single breakpoint but here are some examples for multiple breakpoints:\\n- Different types of breakpoints map to the same location.\\n- Multiple source breakpoints get collapsed to the same instruction by the compiler/runtime.\\n- Multiple function breakpoints with different function names map to the same location.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"integer\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"preserveFocusHint\": {"]
#[doc = "              \"description\": \"A value of true hints to the client that this event should not change the focus.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"reason\": {"]
#[doc = "              \"description\": \"The reason for the event.\\nFor backward compatibility this string is shown in the UI if the `description` attribute is missing (but it must not be translated).\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"_enum\": ["]
#[doc = "                \"step\","]
#[doc = "                \"breakpoint\","]
#[doc = "                \"exception\","]
#[doc = "                \"pause\","]
#[doc = "                \"entry\","]
#[doc = "                \"goto\","]
#[doc = "                \"function breakpoint\","]
#[doc = "                \"data breakpoint\","]
#[doc = "                \"instruction breakpoint\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"text\": {"]
#[doc = "              \"description\": \"Additional information. E.g. if reason is `exception`, text contains the exception name. This string is shown in the UI.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"threadId\": {"]
#[doc = "              \"description\": \"The thread which was stopped.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stopped\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StoppedEvent {
    pub body: StoppedEventBody,
    pub event: StoppedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: StoppedEventType,
}
impl ::std::convert::From<&StoppedEvent> for StoppedEvent {
    fn from(value: &StoppedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`StoppedEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"reason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allThreadsStopped\": {"]
#[doc = "      \"description\": \"If `allThreadsStopped` is true, a debug adapter can announce that all threads have stopped.\\n- The client should use this information to enable that all threads can be expanded to access their stacktraces.\\n- If the attribute is missing or false, only the thread with the given `threadId` can be expanded.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and can be translated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hitBreakpointIds\": {"]
#[doc = "      \"description\": \"Ids of the breakpoints that triggered the event. In most cases there is only a single breakpoint but here are some examples for multiple breakpoints:\\n- Different types of breakpoints map to the same location.\\n- Multiple source breakpoints get collapsed to the same instruction by the compiler/runtime.\\n- Multiple function breakpoints with different function names map to the same location.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"preserveFocusHint\": {"]
#[doc = "      \"description\": \"A value of true hints to the client that this event should not change the focus.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"The reason for the event.\\nFor backward compatibility this string is shown in the UI if the `description` attribute is missing (but it must not be translated).\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"step\","]
#[doc = "        \"breakpoint\","]
#[doc = "        \"exception\","]
#[doc = "        \"pause\","]
#[doc = "        \"entry\","]
#[doc = "        \"goto\","]
#[doc = "        \"function breakpoint\","]
#[doc = "        \"data breakpoint\","]
#[doc = "        \"instruction breakpoint\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"description\": \"Additional information. E.g. if reason is `exception`, text contains the exception name. This string is shown in the UI.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"The thread which was stopped.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StoppedEventBody {
    #[doc = "If `allThreadsStopped` is true, a debug adapter can announce that all threads have stopped.\n- The client should use this information to enable that all threads can be expanded to access their stacktraces.\n- If the attribute is missing or false, only the thread with the given `threadId` can be expanded."]
    #[serde(
        rename = "allThreadsStopped",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub all_threads_stopped: ::std::option::Option<bool>,
    #[doc = "The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and can be translated."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Ids of the breakpoints that triggered the event. In most cases there is only a single breakpoint but here are some examples for multiple breakpoints:\n- Different types of breakpoints map to the same location.\n- Multiple source breakpoints get collapsed to the same instruction by the compiler/runtime.\n- Multiple function breakpoints with different function names map to the same location."]
    #[serde(
        rename = "hitBreakpointIds",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub hit_breakpoint_ids: ::std::vec::Vec<i64>,
    #[doc = "A value of true hints to the client that this event should not change the focus."]
    #[serde(
        rename = "preserveFocusHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub preserve_focus_hint: ::std::option::Option<bool>,
    #[doc = "The reason for the event.\nFor backward compatibility this string is shown in the UI if the `description` attribute is missing (but it must not be translated)."]
    pub reason: ::std::string::String,
    #[doc = "Additional information. E.g. if reason is `exception`, text contains the exception name. This string is shown in the UI."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
    #[doc = "The thread which was stopped."]
    #[serde(
        rename = "threadId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub thread_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&StoppedEventBody> for StoppedEventBody {
    fn from(value: &StoppedEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`StoppedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"stopped\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StoppedEventEvent {
    #[serde(rename = "stopped")]
    Stopped,
}
impl ::std::convert::From<&Self> for StoppedEventEvent {
    fn from(value: &StoppedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StoppedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Stopped => f.write_str("stopped"),
        }
    }
}
impl ::std::str::FromStr for StoppedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stopped" => Ok(Self::Stopped),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StoppedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StoppedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StoppedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StoppedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StoppedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for StoppedEventType {
    fn from(value: &StoppedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StoppedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for StoppedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StoppedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StoppedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StoppedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `terminate` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `terminate` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"restart\": {"]
#[doc = "      \"description\": \"A value of true indicates that this `terminate` request is part of a restart sequence.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateArguments {
    #[doc = "A value of true indicates that this `terminate` request is part of a restart sequence."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub restart: ::std::option::Option<bool>,
}
impl ::std::convert::From<&TerminateArguments> for TerminateArguments {
    fn from(value: &TerminateArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TerminateArguments {
    fn default() -> Self {
        Self {
            restart: Default::default(),
        }
    }
}
#[doc = "`TerminateRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `terminate` request is sent from the client to the debug adapter in order to shut down the debuggee gracefully. Clients should only call this request if the capability `supportsTerminateRequest` is true.\\nTypically a debug adapter implements `terminate` by sending a software signal which the debuggee intercepts in order to clean things up properly before terminating itself.\\nPlease note that this request does not directly affect the state of the debug session: if the debuggee decides to veto the graceful shutdown for any reason by not terminating itself, then the debug session just continues.\\nClients can surface the `terminate` request as an explicit command or they can integrate it into a two stage Stop command that first sends `terminate` to request a graceful shutdown, and if that fails uses `disconnect` for a forceful shutdown.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/TerminateArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"terminate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<TerminateArguments>,
    pub command: TerminateRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: TerminateRequestType,
}
impl ::std::convert::From<&TerminateRequest> for TerminateRequest {
    fn from(value: &TerminateRequest) -> Self {
        value.clone()
    }
}
#[doc = "`TerminateRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"terminate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateRequestCommand {
    #[serde(rename = "terminate")]
    Terminate,
}
impl ::std::convert::From<&Self> for TerminateRequestCommand {
    fn from(value: &TerminateRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Terminate => f.write_str("terminate"),
        }
    }
}
impl ::std::str::FromStr for TerminateRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "terminate" => Ok(Self::Terminate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminateRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for TerminateRequestType {
    fn from(value: &TerminateRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for TerminateRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminateResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `terminate` request. This is just an acknowledgement, so no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: TerminateResponseType,
}
impl ::std::convert::From<&TerminateResponse> for TerminateResponse {
    fn from(value: &TerminateResponse) -> Self {
        value.clone()
    }
}
#[doc = "`TerminateResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for TerminateResponseType {
    fn from(value: &TerminateResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for TerminateResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `terminateThreads` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `terminateThreads` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"threadIds\": {"]
#[doc = "      \"description\": \"Ids of threads to be terminated.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateThreadsArguments {
    #[doc = "Ids of threads to be terminated."]
    #[serde(
        rename = "threadIds",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub thread_ids: ::std::vec::Vec<i64>,
}
impl ::std::convert::From<&TerminateThreadsArguments> for TerminateThreadsArguments {
    fn from(value: &TerminateThreadsArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TerminateThreadsArguments {
    fn default() -> Self {
        Self {
            thread_ids: Default::default(),
        }
    }
}
#[doc = "`TerminateThreadsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request terminates the threads with the given ids.\\nClients should only call this request if the corresponding capability `supportsTerminateThreadsRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/TerminateThreadsArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"terminateThreads\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateThreadsRequest {
    pub arguments: TerminateThreadsArguments,
    pub command: TerminateThreadsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: TerminateThreadsRequestType,
}
impl ::std::convert::From<&TerminateThreadsRequest> for TerminateThreadsRequest {
    fn from(value: &TerminateThreadsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`TerminateThreadsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"terminateThreads\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateThreadsRequestCommand {
    #[serde(rename = "terminateThreads")]
    TerminateThreads,
}
impl ::std::convert::From<&Self> for TerminateThreadsRequestCommand {
    fn from(value: &TerminateThreadsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateThreadsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::TerminateThreads => f.write_str("terminateThreads"),
        }
    }
}
impl ::std::str::FromStr for TerminateThreadsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "terminateThreads" => Ok(Self::TerminateThreads),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminateThreadsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateThreadsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for TerminateThreadsRequestType {
    fn from(value: &TerminateThreadsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateThreadsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for TerminateThreadsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminateThreadsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `terminateThreads` request. This is just an acknowledgement, no body field is required.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminateThreadsResponse {
    #[doc = "Contains request result if success is true and error details if success is false."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: TerminateThreadsResponseType,
}
impl ::std::convert::From<&TerminateThreadsResponse> for TerminateThreadsResponse {
    fn from(value: &TerminateThreadsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`TerminateThreadsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminateThreadsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for TerminateThreadsResponseType {
    fn from(value: &TerminateThreadsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminateThreadsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for TerminateThreadsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminateThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminateThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminateThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminatedEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that debugging of the debuggee has terminated. This does **not** mean that the debuggee itself has exited.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"restart\": {"]
#[doc = "              \"description\": \"A debug adapter may set `restart` to true (or to an arbitrary object) to request that the client restarts the session.\\nThe value is not interpreted by the client and passed unmodified as an attribute `__restart` to the `launch` and `attach` requests.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"array\","]
#[doc = "                \"boolean\","]
#[doc = "                \"integer\","]
#[doc = "                \"null\","]
#[doc = "                \"number\","]
#[doc = "                \"object\","]
#[doc = "                \"string\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"terminated\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminatedEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<TerminatedEventBody>,
    pub event: TerminatedEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: TerminatedEventType,
}
impl ::std::convert::From<&TerminatedEvent> for TerminatedEvent {
    fn from(value: &TerminatedEvent) -> Self {
        value.clone()
    }
}
#[doc = "`TerminatedEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"restart\": {"]
#[doc = "      \"description\": \"A debug adapter may set `restart` to true (or to an arbitrary object) to request that the client restarts the session.\\nThe value is not interpreted by the client and passed unmodified as an attribute `__restart` to the `launch` and `attach` requests.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"boolean\","]
#[doc = "        \"integer\","]
#[doc = "        \"null\","]
#[doc = "        \"number\","]
#[doc = "        \"object\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TerminatedEventBody {
    #[doc = "A debug adapter may set `restart` to true (or to an arbitrary object) to request that the client restarts the session.\nThe value is not interpreted by the client and passed unmodified as an attribute `__restart` to the `launch` and `attach` requests."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub restart: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&TerminatedEventBody> for TerminatedEventBody {
    fn from(value: &TerminatedEventBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TerminatedEventBody {
    fn default() -> Self {
        Self {
            restart: Default::default(),
        }
    }
}
#[doc = "`TerminatedEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"terminated\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminatedEventEvent {
    #[serde(rename = "terminated")]
    Terminated,
}
impl ::std::convert::From<&Self> for TerminatedEventEvent {
    fn from(value: &TerminatedEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminatedEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Terminated => f.write_str("terminated"),
        }
    }
}
impl ::std::str::FromStr for TerminatedEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "terminated" => Ok(Self::Terminated),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminatedEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TerminatedEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TerminatedEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for TerminatedEventType {
    fn from(value: &TerminatedEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TerminatedEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for TerminatedEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TerminatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TerminatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TerminatedEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Thread"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A Thread\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier for the thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the thread.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Thread {
    #[doc = "Unique identifier for the thread."]
    pub id: i64,
    #[doc = "The name of the thread."]
    pub name: ::std::string::String,
}
impl ::std::convert::From<&Thread> for Thread {
    fn from(value: &Thread) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The event indicates that a thread has started or exited.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\","]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"reason\","]
#[doc = "            \"threadId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"reason\": {"]
#[doc = "              \"description\": \"The reason for the event.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"_enum\": ["]
#[doc = "                \"started\","]
#[doc = "                \"exited\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"threadId\": {"]
#[doc = "              \"description\": \"The identifier of the thread.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"thread\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ThreadEvent {
    pub body: ThreadEventBody,
    pub event: ThreadEventEvent,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ThreadEventType,
}
impl ::std::convert::From<&ThreadEvent> for ThreadEvent {
    fn from(value: &ThreadEvent) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadEventBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"reason\","]
#[doc = "    \"threadId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"The reason for the event.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"started\","]
#[doc = "        \"exited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"threadId\": {"]
#[doc = "      \"description\": \"The identifier of the thread.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ThreadEventBody {
    #[doc = "The reason for the event."]
    pub reason: ::std::string::String,
    #[doc = "The identifier of the thread."]
    #[serde(rename = "threadId")]
    pub thread_id: i64,
}
impl ::std::convert::From<&ThreadEventBody> for ThreadEventBody {
    fn from(value: &ThreadEventBody) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadEventEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"thread\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ThreadEventEvent {
    #[serde(rename = "thread")]
    Thread,
}
impl ::std::convert::From<&Self> for ThreadEventEvent {
    fn from(value: &ThreadEventEvent) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ThreadEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Thread => f.write_str("thread"),
        }
    }
}
impl ::std::str::FromStr for ThreadEventEvent {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "thread" => Ok(Self::Thread),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ThreadEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ThreadEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ThreadEventEvent {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ThreadEventType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"event\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ThreadEventType {
    #[serde(rename = "event")]
    Event,
}
impl ::std::convert::From<&Self> for ThreadEventType {
    fn from(value: &ThreadEventType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ThreadEventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Event => f.write_str("event"),
        }
    }
}
impl ::std::str::FromStr for ThreadEventType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "event" => Ok(Self::Event),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ThreadEventType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ThreadEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ThreadEventType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ThreadsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The request retrieves a list of all threads.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"threads\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ThreadsRequest {
    #[doc = "Object containing arguments for the command."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<::serde_json::Value>,
    pub command: ThreadsRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: ThreadsRequestType,
}
impl ::std::convert::From<&ThreadsRequest> for ThreadsRequest {
    fn from(value: &ThreadsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadsRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"threads\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ThreadsRequestCommand {
    #[serde(rename = "threads")]
    Threads,
}
impl ::std::convert::From<&Self> for ThreadsRequestCommand {
    fn from(value: &ThreadsRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ThreadsRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Threads => f.write_str("threads"),
        }
    }
}
impl ::std::str::FromStr for ThreadsRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "threads" => Ok(Self::Threads),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ThreadsRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ThreadsRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ThreadsRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for ThreadsRequestType {
    fn from(value: &ThreadsRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ThreadsRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for ThreadsRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ThreadsRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ThreadsResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `threads` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"threads\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"threads\": {"]
#[doc = "              \"description\": \"All threads.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Thread\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ThreadsResponse {
    pub body: ThreadsResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: ThreadsResponseType,
}
impl ::std::convert::From<&ThreadsResponse> for ThreadsResponse {
    fn from(value: &ThreadsResponse) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadsResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"threads\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"threads\": {"]
#[doc = "      \"description\": \"All threads.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Thread\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ThreadsResponseBody {
    #[doc = "All threads."]
    pub threads: ::std::vec::Vec<Thread>,
}
impl ::std::convert::From<&ThreadsResponseBody> for ThreadsResponseBody {
    fn from(value: &ThreadsResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`ThreadsResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ThreadsResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for ThreadsResponseType {
    fn from(value: &ThreadsResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ThreadsResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for ThreadsResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ThreadsResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Provides formatting information for a value."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Provides formatting information for a value.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"hex\": {"]
#[doc = "      \"description\": \"Display the value in hex.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ValueFormat {
    #[doc = "Display the value in hex."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub hex: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ValueFormat> for ValueFormat {
    fn from(value: &ValueFormat) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ValueFormat {
    fn default() -> Self {
        Self {
            hex: Default::default(),
        }
    }
}
#[doc = "A Variable is a name/value pair.\nThe `type` attribute is shown if space permits or when hovering over the variable's name.\nThe `kind` attribute is used to render additional properties of the variable, e.g. different icons can be used to indicate that a variable is public or private.\nIf the value is structured (has children), a handle is provided to retrieve the children with the `variables` request.\nIf the number of named or indexed children is large, the numbers should be returned via the `namedVariables` and `indexedVariables` attributes.\nThe client can use this information to present the children in a paged UI and fetch them in chunks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A Variable is a name/value pair.\\nThe `type` attribute is shown if space permits or when hovering over the variable's name.\\nThe `kind` attribute is used to render additional properties of the variable, e.g. different icons can be used to indicate that a variable is public or private.\\nIf the value is structured (has children), a handle is provided to retrieve the children with the `variables` request.\\nIf the number of named or indexed children is large, the numbers should be returned via the `namedVariables` and `indexedVariables` attributes.\\nThe client can use this information to present the children in a paged UI and fetch them in chunks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"value\","]
#[doc = "    \"variablesReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"declarationLocationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the variable is declared. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"evaluateName\": {"]
#[doc = "      \"description\": \"The evaluatable name of this variable which can be passed to the `evaluate` request to fetch the variable's value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"indexedVariables\": {"]
#[doc = "      \"description\": \"The number of indexed child variables.\\nThe client can use this information to present the children in a paged UI and fetch them in chunks.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"A memory reference associated with this variable.\\nFor pointer type variables, this is generally a reference to the memory address contained in the pointer.\\nFor executable data, this reference may later be used in a `disassemble` request.\\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The variable's name.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namedVariables\": {"]
#[doc = "      \"description\": \"The number of named child variables.\\nThe client can use this information to present the children in a paged UI and fetch them in chunks.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"presentationHint\": {"]
#[doc = "      \"description\": \"Properties of a variable that can be used to determine how to render the variable in the UI.\","]
#[doc = "      \"$ref\": \"#/definitions/VariablePresentationHint\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"description\": \"The type of the variable's value. Typically shown in the UI when hovering over the value.\\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The variable's value.\\nThis can be a multi-line text, e.g. for a function the body of a function.\\nFor structured variables (which do not have a simple value), it is recommended to provide a one-line representation of the structured object. This helps to identify the structured object in the collapsed state when its children are not yet visible.\\nAn empty string can be used if no value should be shown in the UI.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"valueLocationReference\": {"]
#[doc = "      \"description\": \"A reference that allows the client to request the location where the variable's value is declared. For example, if the variable contains a function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\\n\\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"If `variablesReference` is > 0, the variable is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Variable {
    #[doc = "A reference that allows the client to request the location where the variable is declared. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "declarationLocationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub declaration_location_reference: ::std::option::Option<i64>,
    #[doc = "The evaluatable name of this variable which can be passed to the `evaluate` request to fetch the variable's value."]
    #[serde(
        rename = "evaluateName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub evaluate_name: ::std::option::Option<::std::string::String>,
    #[doc = "The number of indexed child variables.\nThe client can use this information to present the children in a paged UI and fetch them in chunks."]
    #[serde(
        rename = "indexedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub indexed_variables: ::std::option::Option<i64>,
    #[doc = "A memory reference associated with this variable.\nFor pointer type variables, this is generally a reference to the memory address contained in the pointer.\nFor executable data, this reference may later be used in a `disassemble` request.\nThis attribute may be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true."]
    #[serde(
        rename = "memoryReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub memory_reference: ::std::option::Option<::std::string::String>,
    #[doc = "The variable's name."]
    pub name: ::std::string::String,
    #[doc = "The number of named child variables.\nThe client can use this information to present the children in a paged UI and fetch them in chunks."]
    #[serde(
        rename = "namedVariables",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub named_variables: ::std::option::Option<i64>,
    #[doc = "Properties of a variable that can be used to determine how to render the variable in the UI."]
    #[serde(
        rename = "presentationHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub presentation_hint: ::std::option::Option<VariablePresentationHint>,
    #[doc = "The type of the variable's value. Typically shown in the UI when hovering over the value.\nThis attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[doc = "The variable's value.\nThis can be a multi-line text, e.g. for a function the body of a function.\nFor structured variables (which do not have a simple value), it is recommended to provide a one-line representation of the structured object. This helps to identify the structured object in the collapsed state when its children are not yet visible.\nAn empty string can be used if no value should be shown in the UI."]
    pub value: ::std::string::String,
    #[doc = "A reference that allows the client to request the location where the variable's value is declared. For example, if the variable contains a function pointer, the adapter may be able to look up the function's location. This should be present only if the adapter is likely to be able to resolve the location.\n\nThis reference shares the same lifetime as the `variablesReference`. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(
        rename = "valueLocationReference",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub value_location_reference: ::std::option::Option<i64>,
    #[doc = "If `variablesReference` is > 0, the variable is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
impl ::std::convert::From<&Variable> for Variable {
    fn from(value: &Variable) -> Self {
        value.clone()
    }
}
#[doc = "Properties of a variable that can be used to determine how to render the variable in the UI."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Properties of a variable that can be used to determine how to render the variable in the UI.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"attributes\": {"]
#[doc = "      \"description\": \"Set of attributes represented as an array of strings. Before introducing additional values, try to use the listed values.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\","]
#[doc = "        \"_enum\": ["]
#[doc = "          \"static\","]
#[doc = "          \"constant\","]
#[doc = "          \"readOnly\","]
#[doc = "          \"rawString\","]
#[doc = "          \"hasObjectId\","]
#[doc = "          \"canHaveObjectId\","]
#[doc = "          \"hasSideEffects\","]
#[doc = "          \"hasDataBreakpoint\""]
#[doc = "        ],"]
#[doc = "        \"enumDescriptions\": ["]
#[doc = "          \"Indicates that the object is static.\","]
#[doc = "          \"Indicates that the object is a constant.\","]
#[doc = "          \"Indicates that the object is read only.\","]
#[doc = "          \"Indicates that the object is a raw string.\","]
#[doc = "          \"Indicates that the object can have an Object ID created for it. This is a vestigial attribute that is used by some clients; 'Object ID's are not specified in the protocol.\","]
#[doc = "          \"Indicates that the object has an Object ID associated with it. This is a vestigial attribute that is used by some clients; 'Object ID's are not specified in the protocol.\","]
#[doc = "          \"Indicates that the evaluation had side effects.\","]
#[doc = "          \"Indicates that the object has its value tracked by a data breakpoint.\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"kind\": {"]
#[doc = "      \"description\": \"The kind of variable. Before introducing additional values, try to use the listed values.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"property\","]
#[doc = "        \"method\","]
#[doc = "        \"class\","]
#[doc = "        \"data\","]
#[doc = "        \"event\","]
#[doc = "        \"baseClass\","]
#[doc = "        \"innerClass\","]
#[doc = "        \"interface\","]
#[doc = "        \"mostDerivedClass\","]
#[doc = "        \"virtual\","]
#[doc = "        \"dataBreakpoint\""]
#[doc = "      ],"]
#[doc = "      \"enumDescriptions\": ["]
#[doc = "        \"Indicates that the object is a property.\","]
#[doc = "        \"Indicates that the object is a method.\","]
#[doc = "        \"Indicates that the object is a class.\","]
#[doc = "        \"Indicates that the object is data.\","]
#[doc = "        \"Indicates that the object is an event.\","]
#[doc = "        \"Indicates that the object is a base class.\","]
#[doc = "        \"Indicates that the object is an inner class.\","]
#[doc = "        \"Indicates that the object is an interface.\","]
#[doc = "        \"Indicates that the object is the most derived class.\","]
#[doc = "        \"Indicates that the object is virtual, that means it is a synthetic object introduced by the adapter for rendering purposes, e.g. an index range for large arrays.\","]
#[doc = "        \"Deprecated: Indicates that a data breakpoint is registered for the object. The `hasDataBreakpoint` attribute should generally be used instead.\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"lazy\": {"]
#[doc = "      \"description\": \"If true, clients can present the variable with a UI that supports a specific gesture to trigger its evaluation.\\nThis mechanism can be used for properties that require executing code when retrieving their value and where the code execution can be expensive and/or produce side-effects. A typical example are properties based on a getter function.\\nPlease note that in addition to the `lazy` flag, the variable's `variablesReference` is expected to refer to a variable that will provide the value through another `variable` request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"visibility\": {"]
#[doc = "      \"description\": \"Visibility of variable. Before introducing additional values, try to use the listed values.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"_enum\": ["]
#[doc = "        \"public\","]
#[doc = "        \"private\","]
#[doc = "        \"protected\","]
#[doc = "        \"internal\","]
#[doc = "        \"final\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VariablePresentationHint {
    #[doc = "Set of attributes represented as an array of strings. Before introducing additional values, try to use the listed values."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub attributes: ::std::vec::Vec<::std::string::String>,
    #[doc = "The kind of variable. Before introducing additional values, try to use the listed values."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub kind: ::std::option::Option<::std::string::String>,
    #[doc = "If true, clients can present the variable with a UI that supports a specific gesture to trigger its evaluation.\nThis mechanism can be used for properties that require executing code when retrieving their value and where the code execution can be expensive and/or produce side-effects. A typical example are properties based on a getter function.\nPlease note that in addition to the `lazy` flag, the variable's `variablesReference` is expected to refer to a variable that will provide the value through another `variable` request."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lazy: ::std::option::Option<bool>,
    #[doc = "Visibility of variable. Before introducing additional values, try to use the listed values."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub visibility: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&VariablePresentationHint> for VariablePresentationHint {
    fn from(value: &VariablePresentationHint) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for VariablePresentationHint {
    fn default() -> Self {
        Self {
            attributes: Default::default(),
            kind: Default::default(),
            lazy: Default::default(),
            visibility: Default::default(),
        }
    }
}
#[doc = "Arguments for `variables` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `variables` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"variablesReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"description\": \"The number of variables to return. If count is missing or 0, all variables are returned.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsVariablePaging` is true.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"filter\": {"]
#[doc = "      \"description\": \"Filter to limit the child variables to either named or indexed. If omitted, both types are fetched.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"indexed\","]
#[doc = "        \"named\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"description\": \"Specifies details on how to format the Variable values.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.\","]
#[doc = "      \"$ref\": \"#/definitions/ValueFormat\""]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"description\": \"The index of the first variable to return; if omitted children start at 0.\\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsVariablePaging` is true.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"variablesReference\": {"]
#[doc = "      \"description\": \"The variable for which to retrieve its children. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VariablesArguments {
    #[doc = "The number of variables to return. If count is missing or 0, all variables are returned.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsVariablePaging` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i64>,
    #[doc = "Filter to limit the child variables to either named or indexed. If omitted, both types are fetched."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub filter: ::std::option::Option<VariablesArgumentsFilter>,
    #[doc = "Specifies details on how to format the Variable values.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<ValueFormat>,
    #[doc = "The index of the first variable to return; if omitted children start at 0.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsVariablePaging` is true."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start: ::std::option::Option<i64>,
    #[doc = "The variable for which to retrieve its children. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details."]
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
impl ::std::convert::From<&VariablesArguments> for VariablesArguments {
    fn from(value: &VariablesArguments) -> Self {
        value.clone()
    }
}
#[doc = "Filter to limit the child variables to either named or indexed. If omitted, both types are fetched."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Filter to limit the child variables to either named or indexed. If omitted, both types are fetched.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"indexed\","]
#[doc = "    \"named\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VariablesArgumentsFilter {
    #[serde(rename = "indexed")]
    Indexed,
    #[serde(rename = "named")]
    Named,
}
impl ::std::convert::From<&Self> for VariablesArgumentsFilter {
    fn from(value: &VariablesArgumentsFilter) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VariablesArgumentsFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Indexed => f.write_str("indexed"),
            Self::Named => f.write_str("named"),
        }
    }
}
impl ::std::str::FromStr for VariablesArgumentsFilter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "indexed" => Ok(Self::Indexed),
            "named" => Ok(Self::Named),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VariablesArgumentsFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VariablesArgumentsFilter {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VariablesArgumentsFilter {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`VariablesRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Retrieves all child variables for the given variable reference.\\nA filter can be used to limit the fetched children to either named or indexed children.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/VariablesArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"variables\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VariablesRequest {
    pub arguments: VariablesArguments,
    pub command: VariablesRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: VariablesRequestType,
}
impl ::std::convert::From<&VariablesRequest> for VariablesRequest {
    fn from(value: &VariablesRequest) -> Self {
        value.clone()
    }
}
#[doc = "`VariablesRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"variables\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VariablesRequestCommand {
    #[serde(rename = "variables")]
    Variables,
}
impl ::std::convert::From<&Self> for VariablesRequestCommand {
    fn from(value: &VariablesRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VariablesRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Variables => f.write_str("variables"),
        }
    }
}
impl ::std::str::FromStr for VariablesRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "variables" => Ok(Self::Variables),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VariablesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VariablesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VariablesRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`VariablesRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VariablesRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for VariablesRequestType {
    fn from(value: &VariablesRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VariablesRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for VariablesRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VariablesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VariablesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VariablesRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`VariablesResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `variables` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"variables\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"variables\": {"]
#[doc = "              \"description\": \"All (or a range) of variables for the given variable reference.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Variable\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VariablesResponse {
    pub body: VariablesResponseBody,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: VariablesResponseType,
}
impl ::std::convert::From<&VariablesResponse> for VariablesResponse {
    fn from(value: &VariablesResponse) -> Self {
        value.clone()
    }
}
#[doc = "`VariablesResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"variables\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"variables\": {"]
#[doc = "      \"description\": \"All (or a range) of variables for the given variable reference.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Variable\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VariablesResponseBody {
    #[doc = "All (or a range) of variables for the given variable reference."]
    pub variables: ::std::vec::Vec<Variable>,
}
impl ::std::convert::From<&VariablesResponseBody> for VariablesResponseBody {
    fn from(value: &VariablesResponseBody) -> Self {
        value.clone()
    }
}
#[doc = "`VariablesResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VariablesResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for VariablesResponseType {
    fn from(value: &VariablesResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VariablesResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for VariablesResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VariablesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VariablesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VariablesResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Arguments for `writeMemory` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments for `writeMemory` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data\","]
#[doc = "    \"memoryReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allowPartial\": {"]
#[doc = "      \"description\": \"Property to control partial writes. If true, the debug adapter should attempt to write memory even if the entire memory region is not writable. In such a case the debug adapter should stop after hitting the first byte of memory that cannot be written and return the number of bytes written in the response via the `offset` and `bytesWritten` properties.\\nIf false or missing, a debug adapter should attempt to verify the region is writable before writing, and fail the response if it is not.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"Bytes to write, encoded using base64.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"memoryReference\": {"]
#[doc = "      \"description\": \"Memory reference to the base location to which data should be written.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"Offset (in bytes) to be applied to the reference location before writing data. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WriteMemoryArguments {
    #[doc = "Property to control partial writes. If true, the debug adapter should attempt to write memory even if the entire memory region is not writable. In such a case the debug adapter should stop after hitting the first byte of memory that cannot be written and return the number of bytes written in the response via the `offset` and `bytesWritten` properties.\nIf false or missing, a debug adapter should attempt to verify the region is writable before writing, and fail the response if it is not."]
    #[serde(
        rename = "allowPartial",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub allow_partial: ::std::option::Option<bool>,
    #[doc = "Bytes to write, encoded using base64."]
    pub data: ::std::string::String,
    #[doc = "Memory reference to the base location to which data should be written."]
    #[serde(rename = "memoryReference")]
    pub memory_reference: ::std::string::String,
    #[doc = "Offset (in bytes) to be applied to the reference location before writing data. Can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
}
impl ::std::convert::From<&WriteMemoryArguments> for WriteMemoryArguments {
    fn from(value: &WriteMemoryArguments) -> Self {
        value.clone()
    }
}
#[doc = "`WriteMemoryRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Writes bytes to memory at the provided location.\\nClients should only call this request if the corresponding capability `supportsWriteMemoryRequest` is true.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"arguments\","]
#[doc = "        \"command\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"$ref\": \"#/definitions/WriteMemoryArguments\""]
#[doc = "        },"]
#[doc = "        \"command\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"writeMemory\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WriteMemoryRequest {
    pub arguments: WriteMemoryArguments,
    pub command: WriteMemoryRequestCommand,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: WriteMemoryRequestType,
}
impl ::std::convert::From<&WriteMemoryRequest> for WriteMemoryRequest {
    fn from(value: &WriteMemoryRequest) -> Self {
        value.clone()
    }
}
#[doc = "`WriteMemoryRequestCommand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"writeMemory\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WriteMemoryRequestCommand {
    #[serde(rename = "writeMemory")]
    WriteMemory,
}
impl ::std::convert::From<&Self> for WriteMemoryRequestCommand {
    fn from(value: &WriteMemoryRequestCommand) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WriteMemoryRequestCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::WriteMemory => f.write_str("writeMemory"),
        }
    }
}
impl ::std::str::FromStr for WriteMemoryRequestCommand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "writeMemory" => Ok(Self::WriteMemory),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WriteMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WriteMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WriteMemoryRequestCommand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WriteMemoryRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"request\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WriteMemoryRequestType {
    #[serde(rename = "request")]
    Request,
}
impl ::std::convert::From<&Self> for WriteMemoryRequestType {
    fn from(value: &WriteMemoryRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WriteMemoryRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Request => f.write_str("request"),
        }
    }
}
impl ::std::str::FromStr for WriteMemoryRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "request" => Ok(Self::Request),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WriteMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WriteMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WriteMemoryRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WriteMemoryResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Response\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Response to `writeMemory` request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"bytesWritten\": {"]
#[doc = "              \"description\": \"Property that should be returned when `allowPartial` is true to indicate the number of bytes starting from address that were successfully written.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"offset\": {"]
#[doc = "              \"description\": \"Property that should be returned when `allowPartial` is true to indicate the offset of the first byte of data successfully written. Can be negative.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WriteMemoryResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<WriteMemoryResponseBody>,
    #[doc = "The command requested."]
    pub command: ::std::string::String,
    #[doc = "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "Sequence number of the corresponding request."]
    pub request_seq: i64,
    #[doc = "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request."]
    pub seq: i64,
    #[doc = "Outcome of the request.\nIf true, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`)."]
    pub success: bool,
    #[serde(rename = "type")]
    pub type_: WriteMemoryResponseType,
}
impl ::std::convert::From<&WriteMemoryResponse> for WriteMemoryResponse {
    fn from(value: &WriteMemoryResponse) -> Self {
        value.clone()
    }
}
#[doc = "`WriteMemoryResponseBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"bytesWritten\": {"]
#[doc = "      \"description\": \"Property that should be returned when `allowPartial` is true to indicate the number of bytes starting from address that were successfully written.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"description\": \"Property that should be returned when `allowPartial` is true to indicate the offset of the first byte of data successfully written. Can be negative.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WriteMemoryResponseBody {
    #[doc = "Property that should be returned when `allowPartial` is true to indicate the number of bytes starting from address that were successfully written."]
    #[serde(
        rename = "bytesWritten",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub bytes_written: ::std::option::Option<i64>,
    #[doc = "Property that should be returned when `allowPartial` is true to indicate the offset of the first byte of data successfully written. Can be negative."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<i64>,
}
impl ::std::convert::From<&WriteMemoryResponseBody> for WriteMemoryResponseBody {
    fn from(value: &WriteMemoryResponseBody) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WriteMemoryResponseBody {
    fn default() -> Self {
        Self {
            bytes_written: Default::default(),
            offset: Default::default(),
        }
    }
}
#[doc = "`WriteMemoryResponseType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WriteMemoryResponseType {
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for WriteMemoryResponseType {
    fn from(value: &WriteMemoryResponseType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WriteMemoryResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Response => f.write_str("response"),
        }
    }
}
impl ::std::str::FromStr for WriteMemoryResponseType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WriteMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WriteMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WriteMemoryResponseType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
