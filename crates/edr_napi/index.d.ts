/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Specification of overrides for an account and its storage. */
export interface AccountOverride {
  /** The account's address */
  address: Uint8Array
  /** If present, the overwriting balance. */
  balance?: bigint
  /** If present, the overwriting nonce. */
  nonce?: bigint
  /** If present, the overwriting code. */
  code?: Uint8Array
  /**
   * BEWARE: This field is not supported yet. See <https://github.com/NomicFoundation/edr/issues/911>
   *
   * If present, the overwriting storage.
   */
  storage?: Array<StorageSlot>
}
/** A description of a storage slot's state. */
export interface StorageSlot {
  /** The storage slot's index */
  index: bigint
  /** The storage slot's value */
  value: bigint
}
/** Information about the blob gas used in a block. */
export interface BlobGas {
  /**
   * The total amount of blob gas consumed by the transactions within the
   * block.
   */
  gasUsed: bigint
  /**
   * The running total of blob gas consumed in excess of the target, prior to
   * the block. Blocks with above-target blob gas consumption increase this
   * value, blocks with below-target blob gas consumption decrease it
   * (bounded at 0).
   */
  excessGas: bigint
}
/** The result of executing a call override. */
export interface CallOverrideResult {
  result: Uint8Array
  shouldRevert: boolean
}
export const GENERIC_CHAIN_TYPE: string
export declare function genericChainProviderFactory(): ProviderFactory
export const L1_CHAIN_TYPE: string
export declare function l1GenesisState(hardfork: SpecId): Array<AccountOverride>
export declare function l1ProviderFactory(): ProviderFactory
/** Identifier for the Ethereum spec. */
export enum SpecId {
  /** Frontier */
  Frontier = 0,
  /** Frontier Thawing */
  FrontierThawing = 1,
  /** Homestead */
  Homestead = 2,
  /** DAO Fork */
  DaoFork = 3,
  /** Tangerine */
  Tangerine = 4,
  /** Spurious Dragon */
  SpuriousDragon = 5,
  /** Byzantium */
  Byzantium = 6,
  /** Constantinople */
  Constantinople = 7,
  /** Petersburg */
  Petersburg = 8,
  /** Istanbul */
  Istanbul = 9,
  /** Muir Glacier */
  MuirGlacier = 10,
  /** Berlin */
  Berlin = 11,
  /** London */
  London = 12,
  /** Arrow Glacier */
  ArrowGlacier = 13,
  /** Gray Glacier */
  GrayGlacier = 14,
  /** Merge */
  Merge = 15,
  /** Shanghai */
  Shanghai = 16,
  /** Cancun */
  Cancun = 17,
  /** Prague */
  Prague = 18
}
/**
 * Tries to parse the provided string to create a [`SpecId`] instance.
 *
 * Returns an error if the string does not match any known hardfork.
 */
export declare function l1HardforkFromString(hardfork: string): SpecId
export declare function l1HardforkToString(harfork: SpecId): string
/**
 * Returns the latest supported OP hardfork.
 *
 * The returned value will be updated after each network upgrade.
 */
export declare function l1HardforkLatest(): SpecId
export const FRONTIER: string
export const FRONTIER_THAWING: string
export const HOMESTEAD: string
export const DAO_FORK: string
export const TANGERINE: string
export const SPURIOUS_DRAGON: string
export const BYZANTIUM: string
export const CONSTANTINOPLE: string
export const PETERSBURG: string
export const ISTANBUL: string
export const MUIR_GLACIER: string
export const BERLIN: string
export const LONDON: string
export const ARROW_GLACIER: string
export const GRAY_GLACIER: string
export const MERGE: string
export const SHANGHAI: string
export const CANCUN: string
export const PRAGUE: string
/** Enumeration of supported OP hardforks. */
export enum OpHardfork {
  Bedrock = 100,
  Regolith = 101,
  Canyon = 102,
  Ecotone = 103,
  Fjord = 104,
  Granite = 105,
  Holocene = 106,
  Isthmus = 107
}
/**
 * Tries to parse the provided string to create an [`OpHardfork`]
 * instance.
 *
 * Returns an error if the string does not match any known hardfork.
 */
export declare function opHardforkFromString(hardfork: string): OpHardfork
/** Returns the string representation of the provided OP hardfork. */
export declare function opHardforkToString(hardfork: OpHardfork): string
/**
 * Returns the latest supported OP hardfork.
 *
 * The returned value will be updated after each network upgrade.
 */
export declare function opLatestHardfork(): OpHardfork
export const OP_CHAIN_TYPE: string
export declare function opGenesisState(hardfork: OpHardfork): Array<AccountOverride>
export declare function opProviderFactory(): ProviderFactory
export const BEDROCK: string
export const REGOLITH: string
export const CANYON: string
export const ECOTONE: string
export const FJORD: string
export const GRANITE: string
export const HOLOCENE: string
export const ISTHMUS: string
/** Specification of a chain with possible overrides. */
export interface ChainOverride {
  /** The chain ID */
  chainId: bigint
  /** The chain's name */
  name: string
  /** If present, overrides for the chain's supported hardforks */
  hardforkActivationOverrides?: Array<HardforkActivation>
}
/** Configuration for a code coverage reporter. */
export interface CodeCoverageConfig {
  /**
   * The callback to be called when coverage has been collected.
   *
   * The callback receives an array of unique coverage hit markers (i.e. no
   * repetition) per transaction.
   *
   * Exceptions thrown in the callback will be propagated to the original
   * caller.
   */
  onCollectedCoverageCallback: (coverageHits: Uint8Array[]) => Promise<void>
}
/** Configuration for forking a blockchain */
export interface ForkConfig {
  /**
   * The block number to fork from. If not provided, the latest safe block is
   * used.
   */
  blockNumber?: bigint
  /** The directory to cache remote JSON-RPC responses */
  cacheDir?: string
  /** Overrides for the configuration of chains. */
  chainOverrides?: Array<ChainOverride>
  /** The HTTP headers to use when making requests to the JSON-RPC endpoint */
  httpHeaders?: Array<HttpHeader>
  /** The URL of the JSON-RPC endpoint to fork from */
  url: string
}
export interface HttpHeader {
  name: string
  value: string
}
/** Configuration for a hardfork activation */
export interface HardforkActivation {
  /** The condition for the hardfork activation */
  condition: HardforkActivationByBlockNumber | HardforkActivationByTimestamp
  /** The activated hardfork */
  hardfork: string
}
export interface HardforkActivationByBlockNumber {
  /** The block number at which the hardfork is activated */
  blockNumber: bigint
}
export interface HardforkActivationByTimestamp {
  /** The timestamp at which the hardfork is activated */
  timestamp: bigint
}
/**The type of ordering to use when selecting blocks to mine. */
export enum MineOrdering {
  /**Insertion order */
  Fifo = 'Fifo',
  /**Effective miner fee */
  Priority = 'Priority'
}
/** Configuration for the provider's mempool. */
export interface MemPoolConfig {
  order: MineOrdering
}
export interface IntervalRange {
  min: bigint
  max: bigint
}
/** Configuration for the provider's miner. */
export interface MiningConfig {
  autoMine: boolean
  interval?: bigint | IntervalRange
  memPool: MemPoolConfig
}
/** Configuration for runtime observability. */
export interface ObservabilityConfig {
  /** If present, configures runtime observability to collect code coverage. */
  codeCoverage?: CodeCoverageConfig
}
/** Configuration for a provider */
export interface ProviderConfig {
  /** Whether to allow blocks with the same timestamp */
  allowBlocksWithSameTimestamp: boolean
  /** Whether to allow unlimited contract size */
  allowUnlimitedContractSize: boolean
  /** Whether to return an `Err` when `eth_call` fails */
  bailOnCallFailure: boolean
  /** Whether to return an `Err` when a `eth_sendTransaction` fails */
  bailOnTransactionFailure: boolean
  /** The gas limit of each block */
  blockGasLimit: bigint
  /** The chain ID of the blockchain */
  chainId: bigint
  /** The address of the coinbase */
  coinbase: Uint8Array
  /**
   * The configuration for forking a blockchain. If not provided, a local
   * blockchain will be created
   */
  fork?: ForkConfig
  /** The genesis state of the blockchain */
  genesisState: Array<AccountOverride>
  /** The hardfork of the blockchain */
  hardfork: string
  /**
   * The initial base fee per gas of the blockchain. Required for EIP-1559
   * transactions and later
   */
  initialBaseFeePerGas?: bigint
  /** The initial blob gas of the blockchain. Required for EIP-4844 */
  initialBlobGas?: BlobGas
  /** The initial date of the blockchain, in seconds since the Unix epoch */
  initialDate?: bigint
  /**
   * The initial parent beacon block root of the blockchain. Required for
   * EIP-4788
   */
  initialParentBeaconBlockRoot?: Uint8Array
  /** The minimum gas price of the next block. */
  minGasPrice: bigint
  /** The configuration for the miner */
  mining: MiningConfig
  /** The network ID of the blockchain */
  networkId: bigint
  /** The configuration for the provider's observability */
  observability: ObservabilityConfig
  /** Secret keys of owned accounts */
  ownedAccounts: Array<string>
  /** Overrides for precompiles */
  precompileOverrides: Array<Precompile>
}
/** Tracing config for Solidity stack trace generation. */
export interface TracingConfigWithBuffers {
  /**
   * Build information to use for decoding contracts. Either a Hardhat v2
   * build info file that contains both input and output or a Hardhat v3
   * build info file that doesn't contain output and a separate output file.
   */
  buildInfos?: Array<Uint8Array> | Array<BuildInfoAndOutput>
  /** Whether to ignore contracts whose name starts with "Ignored". */
  ignoreContracts?: boolean
}
/**
 * Hardhat V3 build info where the compiler output is not part of the build
 * info file.
 */
export interface BuildInfoAndOutput {
  /** The build info input file */
  buildInfo: Uint8Array
  /** The build info output file */
  output: Uint8Array
}
export interface DebugTraceResult {
  pass: boolean
  gasUsed: bigint
  output?: Uint8Array
  structLogs: Array<DebugTraceLogItem>
}
export interface DebugTraceLogItem {
  /** Program Counter */
  pc: bigint
  op: number
  /** Gas left before executing this operation as hex number. */
  gas: string
  /** Gas cost of this operation as hex number. */
  gasCost: string
  /** Array of all values (hex numbers) on the stack */
  stack?: Array<string>
  /** Depth of the call stack */
  depth: bigint
  /** Size of memory array */
  memSize: bigint
  /** Name of the operation */
  opName: string
  /** Description of an error as a hex string. */
  error?: string
  /** Array of all allocated values as hex strings. */
  memory?: Array<string>
  /** Map of all stored values with keys and values encoded as hex strings. */
  storage?: Record<string, string>
}
export interface InstrumentationResult {
  /** The generated source code with coverage instrumentation. */
  readonly source: string
  /** The metadata for each instrumented code segment. */
  readonly metadata: Array<InstrumentationMetadata>
}
export interface InstrumentationMetadata {
  /**
   * The tag that identifies the instrumented code. Tags are
   * deterministically generated from the source code, source id, and
   * Solidity version.
   */
  readonly tag: Uint8Array
  /**
   * The kind of instrumented code. Currently, the only supported kind
   * is "statement".
   */
  readonly kind: string
  /**
   * The starting position of the instrumented code - including trivia such
   * as whitespace - in the source code, in UTF-16 code units.
   */
  readonly startUtf16: number
  /**
   * The ending position of the instrumented code - including trivia such as
   * whitespace - in the source code, in UTF-16 code units.
   */
  readonly endUtf16: number
}
/**
 * Adds per-statement coverage instrumentation to the given Solidity source
 * code.
 */
export declare function addStatementCoverageInstrumentation(sourceCode: string, sourceId: string, solidityVersion: string, coverageLibraryPath: string): InstrumentationResult
/** Ethereum execution log. */
export interface ExecutionLog {
  address: Uint8Array
  topics: Array<Uint8Array>
  data: Uint8Array
}
export interface LoggerConfig {
  /** Whether to enable the logger. */
  enable: boolean
  decodeConsoleLogInputsCallback: (inputs: ArrayBuffer[]) => string[]
  printLineCallback: (message: string, replace: boolean) => void
}
/**
 * [RIP-7212](https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md#specification)
 * secp256r1 precompile.
 */
export declare function precompileP256Verify(): Precompile
/** The possible reasons for successful termination of the EVM. */
export enum SuccessReason {
  /** The opcode `STOP` was called */
  Stop = 0,
  /** The opcode `RETURN` was called */
  Return = 1,
  /** The opcode `SELFDESTRUCT` was called */
  SelfDestruct = 2,
  EofReturnContract = 3
}
export interface CallOutput {
  /** Return value */
  returnValue: Uint8Array
}
export interface CreateOutput {
  /** Return value */
  returnValue: Uint8Array
  /** Optionally, a 160-bit address */
  address?: Uint8Array
}
/** The result when the EVM terminates successfully. */
export interface SuccessResult {
  /** The reason for termination */
  reason: SuccessReason
  /** The amount of gas used */
  gasUsed: bigint
  /** The amount of gas refunded */
  gasRefunded: bigint
  /** The logs */
  logs: Array<ExecutionLog>
  /** The transaction output */
  output: CallOutput | CreateOutput
}
/** The result when the EVM terminates due to a revert. */
export interface RevertResult {
  /** The amount of gas used */
  gasUsed: bigint
  /** The transaction output */
  output: Uint8Array
}
/**
 * Indicates that the EVM has experienced an exceptional halt. This causes
 * execution to immediately end with all gas being consumed.
 */
export enum ExceptionalHalt {
  OutOfGas = 0,
  OpcodeNotFound = 1,
  InvalidFEOpcode = 2,
  InvalidJump = 3,
  NotActivated = 4,
  StackUnderflow = 5,
  StackOverflow = 6,
  OutOfOffset = 7,
  CreateCollision = 8,
  PrecompileError = 9,
  NonceOverflow = 10,
  /** Create init code size exceeds limit (runtime). */
  CreateContractSizeLimit = 11,
  /** Error on created contract that begins with EF */
  CreateContractStartingWithEF = 12,
  /** EIP-3860: Limit and meter initcode. Initcode size limit exceeded. */
  CreateInitCodeSizeLimit = 13,
  /** Aux data overflow, new aux data is larger tha u16 max size. */
  EofAuxDataOverflow = 14,
  /** Aud data is smaller then already present data size. */
  EofAuxDataTooSmall = 15,
  /** EOF Subroutine stack overflow */
  SubRoutineStackOverflow = 16,
  /** Check for target address validity is only done inside subcall. */
  InvalidEXTCALLTarget = 17
}
/** The result when the EVM terminates due to an exceptional halt. */
export interface HaltResult {
  /** The exceptional halt that occurred */
  reason: ExceptionalHalt
  /**
   * Halting will spend all the gas and will thus be equal to the specified
   * gas limit
   */
  gasUsed: bigint
}
/** The result of executing a transaction. */
export interface ExecutionResult {
  /** The transaction result */
  result: SuccessResult | RevertResult | HaltResult
  /** Optional contract address if the transaction created a new contract. */
  contractAddress?: Uint8Array
}
/** A compilation artifact. */
export interface Artifact {
  /** The identifier of the artifact. */
  id: ArtifactId
  /** The test contract. */
  contract: ContractData
}
/** The identifier of a Solidity contract. */
export interface ArtifactId {
  /** The name of the contract. */
  name: string
  /** Original source file path. */
  source: string
  /** The solc semver string. */
  solcVersion: string
}
/** A test contract to execute. */
export interface ContractData {
  /** Contract ABI as json string. */
  abi: string
  /**
   * Contract creation code as hex string. It can be missing if the contract
   * is ABI only.
   */
  bytecode?: string
  /** The link references of the deployment bytecode. */
  linkReferences?: Record<string, Record<string, Array<LinkReference>>>
  /**
   * Contract runtime code as hex string. It can be missing if the contract
   * is ABI only.
   */
  deployedBytecode?: string
  /** The link references of the deployed bytecode. */
  deployedLinkReferences?: Record<string, Record<string, Array<LinkReference>>>
}
export interface LinkReference {
  start: number
  length: number
}
/**
 * Solidity test runner configuration arguments exposed through the ffi.
 * Docs based on <https://book.getfoundry.sh/reference/config/testing>.
 */
export interface SolidityTestRunnerConfigArgs {
  /**
   * The absolute path to the project root directory.
   * Relative paths in cheat codes are resolved against this path.
   */
  projectRoot: string
  /** Configures the permissions of cheat codes that access the file system. */
  fsPermissions?: Array<PathPermission>
  /** Whether to support the `testFail` prefix. Defaults to false. */
  testFail?: boolean
  /** Address labels for traces. Defaults to none. */
  labels?: Array<AddressLabel>
  /**
   * Whether to enable isolation of calls. In isolation mode all top-level
   * calls are executed as a separate transaction in a separate EVM
   * context, enabling more precise gas accounting and transaction state
   * changes.
   * Defaults to false.
   */
  isolate?: boolean
  /**
   * Whether or not to enable the ffi cheatcode.
   * Warning: Enabling this cheatcode has security implications, as it allows
   * tests to execute arbitrary programs on your computer.
   * Defaults to false.
   */
  ffi?: boolean
  /**
   * Allow expecting reverts with `expectRevert` at the same callstack depth
   * as the test. Defaults to false.
   */
  allowInternalExpectRevert?: boolean
  /**
   * The value of `msg.sender` in tests as hex string.
   * Defaults to `0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38`.
   */
  sender?: Uint8Array
  /**
   * The value of `tx.origin` in tests as hex string.
   * Defaults to `0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38`.
   */
  txOrigin?: Uint8Array
  /**
   * The initial balance of the sender in tests.
   * Defaults to `0xffffffffffffffffffffffff`.
   */
  initialBalance?: bigint
  /**
   * The value of `block.number` in tests.
   * Defaults to `1`.
   */
  blockNumber?: bigint
  /**
   * The value of the `chainid` opcode in tests.
   * Defaults to `31337`.
   */
  chainId?: bigint
  /**
   * The gas limit for each test case.
   * Defaults to `9_223_372_036_854_775_807` (`i64::MAX`).
   */
  gasLimit?: bigint
  /**
   * The price of gas (in wei) in tests.
   * Defaults to `0`.
   */
  gasPrice?: bigint
  /**
   * The base fee per gas (in wei) in tests.
   * Defaults to `0`.
   */
  blockBaseFeePerGas?: bigint
  /**
   * The value of `block.coinbase` in tests.
   * Defaults to `0x0000000000000000000000000000000000000000`.
   */
  blockCoinbase?: Uint8Array
  /**
   * The value of `block.timestamp` in tests.
   * Defaults to 1.
   */
  blockTimestamp?: bigint
  /**
   * The value of `block.difficulty` in tests.
   * Defaults to 0.
   */
  blockDifficulty?: bigint
  /**
   * The `block.gaslimit` value during EVM execution.
   * Defaults to none.
   */
  blockGasLimit?: bigint
  /**
   * Whether to disable the block gas limit.
   * Defaults to false.
   */
  disableBlockGasLimit?: boolean
  /**
   * The memory limit of the EVM in bytes.
   * Defaults to 33_554_432 (2^25 = 32MiB).
   */
  memoryLimit?: bigint
  /**
   * The predeploys applied in local mode. Defaults to no predeploys.
   * These should match the predeploys of the network in fork mode, so they
   * aren't set in fork mode.
   * The code must be set and non-empty. The nonce and the balance default to
   * zero and storage defaults to empty.
   */
  localPredeploys?: Array<AccountOverride>
  /**
   * If set, all tests are run in fork mode using this url or remote name.
   * Defaults to none.
   */
  ethRpcUrl?: string
  /** Pins the block number for the global state fork. */
  forkBlockNumber?: bigint
  /**
   * Map of RPC endpoints from chain name to RPC urls for fork cheat codes,
   * e.g. `{ "optimism": "https://optimism.alchemyapi.io/v2/..." }`
   */
  rpcEndpoints?: Record<string, string>
  /**
   * Optional RPC cache path. If this is none, then no RPC calls will be
   * cached, otherwise data is cached to `<rpc_cache_path>/<chain
   * id>/<block number>`. Caching can be disabled for specific chains
   * with `rpc_storage_caching`.
   */
  rpcCachePath?: string
  /** What RPC endpoints are cached. Defaults to all. */
  rpcStorageCaching?: StorageCachingConfig
  /**
   * The number of seconds to wait before `vm.prompt` reverts with a timeout.
   * Defaults to 120.
   */
  promptTimeout?: number
  /** Fuzz testing configuration. */
  fuzz?: FuzzConfigArgs
  /**
   * Invariant testing configuration.
   * If an invariant config setting is not set, but a corresponding fuzz
   * config value is set, then the fuzz config value will be used.
   */
  invariant?: InvariantConfigArgs
  /**
   * Controls which test results should include execution traces. Defaults to
   * None.
   */
  includeTraces?: IncludeTraces
  /** The configuration for the Solidity test runner's observability */
  observability?: ObservabilityConfig
  /**
   * A regex pattern to filter tests. If provided, only test methods that
   * match the pattern will be executed and reported as a test result.
   */
  testPattern?: string
}
/** Fuzz testing configuration */
export interface FuzzConfigArgs {
  /** Path where fuzz failures are recorded and replayed if set. */
  failurePersistDir?: string
  /** Name of the file to record fuzz failures, defaults to `failures`. */
  failurePersistFile?: string
  /**
   * The amount of fuzz runs to perform for each fuzz test case. Higher
   * values gives more confidence in results at the cost of testing
   * speed.
   * Defaults to 256.
   */
  runs?: number
  /**
   * The maximum number of combined inputs that may be rejected before the
   * test as a whole aborts. “Global” filters apply to the whole test
   * case. If the test case is rejected, the whole thing is regenerated.
   * Defaults to 65536.
   */
  maxTestRejects?: number
  /**
   * Hexadecimal string.
   * Optional seed for the fuzzing RNG algorithm.
   * Defaults to None.
   */
  seed?: string
  /**
   * Integer between 0 and 100.
   * The weight of the dictionary. A higher dictionary weight will bias the
   * fuzz inputs towards “interesting” values, e.g. boundary values like
   * type(uint256).max or contract addresses from your environment.
   * Defaults to 40.
   */
  dictionaryWeight?: number
  /**
   * The flag indicating whether to include values from storage.
   * Defaults to true.
   */
  includeStorage?: boolean
  /**
   * The flag indicating whether to include push bytes values.
   * Defaults to true.
   */
  includePushBytes?: boolean
}
/** Invariant testing configuration. */
export interface InvariantConfigArgs {
  /** Path where invariant failures are recorded and replayed if set. */
  failurePersistDir?: string
  /**
   * The number of runs that must execute for each invariant test group.
   * Defaults to 256.
   */
  runs?: number
  /**
   * The number of calls executed to attempt to break invariants in one run.
   * Defaults to 500.
   */
  depth?: number
  /**
   * Fails the invariant fuzzing if a revert occurs.
   * Defaults to false.
   */
  failOnRevert?: boolean
  /**
   * Overrides unsafe external calls when running invariant tests, useful for
   * e.g. performing reentrancy checks.
   * Defaults to false.
   */
  callOverride?: boolean
  /**
   * Integer between 0 and 100.
   * The weight of the dictionary. A higher dictionary weight will bias the
   * fuzz inputs towards “interesting” values, e.g. boundary values like
   * type(uint256).max or contract addresses from your environment.
   * Defaults to 40.
   */
  dictionaryWeight?: number
  /**
   * The flag indicating whether to include values from storage.
   * Defaults to true.
   */
  includeStorage?: boolean
  /**
   * The flag indicating whether to include push bytes values.
   * Defaults to true.
   */
  includePushBytes?: boolean
  /**
   * The maximum number of attempts to shrink a failed the sequence. Shrink
   * process is disabled if set to 0.
   * Defaults to 5000.
   */
  shrinkRunLimit?: number
}
/** Settings to configure caching of remote RPC endpoints. */
export interface StorageCachingConfig {
  /**
   * Chains to cache. Either all or none or a list of chain names, e.g.
   * ["optimism", "mainnet"].
   */
  chains: CachedChains | Array<string>
  /** Endpoints to cache. Either all or remote or a regex. */
  endpoints: CachedEndpoints | string
}
/** What chains to cache */
export enum CachedChains {
  /** Cache all chains */
  All = 0,
  /** Don't cache anything */
  None = 1
}
/** What endpoints to enable caching for */
export enum CachedEndpoints {
  /** Cache all endpoints */
  All = 0,
  /** Only cache non-local host endpoints */
  Remote = 1
}
/** Represents an access permission to a single path */
export interface PathPermission {
  /** Permission level to access the `path` */
  access: FsAccessPermission
  /** The targeted path guarded by the permission */
  path: string
}
/**
 * Determines the level of file system access for the given path.
 *
 * Exact path matching is used for file permissions. Prefix matching is used
 * for directory permissions.
 *
 * Giving write access to configuration files, source files or executables
 * in a project is considered dangerous, because it can be used by malicious
 * Solidity dependencies to escape the EVM sandbox. It is therefore
 * recommended to give write access to specific safe files only. If write
 * access to a directory is needed, please make sure that it doesn't contain
 * configuration files, source files or executables neither in the top level
 * directory, nor in any subdirectories.
*/
export enum FsAccessPermission {
  /** Allows reading and writing the file */
  ReadWriteFile = 0,
  /** Only allows reading the file */
  ReadFile = 1,
  /** Only allows writing the file */
  WriteFile = 2,
  /**
   * Allows reading and writing all files in the directory and its
   * subdirectories
   */
  DangerouslyReadWriteDirectory = 3,
  /** Allows reading all files in the directory and its subdirectories */
  ReadDirectory = 4,
  /** Allows writing all files in the directory and its subdirectories */
  DangerouslyWriteDirectory = 5
}
export interface AddressLabel {
  /** The address to label */
  address: Uint8Array
  /** The label to assign to the address */
  label: string
}
/**
 * Configuration for [`SolidityTestRunnerConfigArgs::include_traces`] that
 * controls execution trace decoding and inclusion in test results.
 */
export enum IncludeTraces {
  /** No traces will be included in any test result. */
  None = 0,
  /** Traces will be included only on the results of failed tests. */
  Failing = 1,
  /** Traces will be included in all test results. */
  All = 2
}
export declare function l1SolidityTestRunnerFactory(): SolidityTestRunnerFactory
export declare function opSolidityTestRunnerFactory(): SolidityTestRunnerFactory
/** A grouping of value snapshot entries for a test. */
export interface ValueSnapshotGroup {
  /** The group name. */
  name: string
  /** The entries in the group. */
  entries: Array<ValueSnapshotEntry>
}
/** An entry in a value snapshot group. */
export interface ValueSnapshotEntry {
  /** The name of the entry. */
  name: string
  /** The value of the entry. */
  value: string
}
/** The stack trace result */
export interface StackTrace {
  /** Enum tag for JS. */
  kind: "StackTrace"
  /** The stack trace entries */
  entries: Array<SolidityStackTraceEntry>
}
/** We couldn't generate stack traces, because an unexpected error occurred. */
export interface UnexpectedError {
  /** Enum tag for JS. */
  kind: "UnexpectedError"
  /** The error message from the unexpected error. */
  errorMessage: string
}
/**
 * We couldn't generate stack traces, because the stack trace generation
 * heuristics failed due to an unknown reason.
 */
export interface HeuristicFailed {
  /** Enum tag for JS. */
  kind: "HeuristicFailed"
}
/**
 * We couldn't generate stack traces, because the test execution is unsafe to
 * replay due to indeterminism. This can be caused by either specifying a fork
 * url without a fork block number in the test runner config or using impure
 * cheatcodes.
 */
export interface UnsafeToReplay {
  /** Enum tag for JS. */
  kind: "UnsafeToReplay"
  /**
   * Indeterminism due to specifying a fork url without a fork block number
   * in the test runner config.
   */
  globalForkLatest: boolean
  /**
   * The list of executed impure cheatcode signatures. We collect function
   * signatures instead of function names as whether a cheatcode is impure
   * can depend on the arguments it takes (e.g. `createFork` without a second
   * argument means implicitly fork from “latest”). Example signature:
   * `function createSelectFork(string calldata urlOrAlias) external returns
   * (uint256 forkId);`.
   */
  impureCheatcodes: Array<string>
}
/**The result of a test execution. */
export enum TestStatus {
  /**Test success */
  Success = 'Success',
  /**Test failure */
  Failure = 'Failure',
  /**Test skipped */
  Skipped = 'Skipped'
}
/** See [edr_solidity_tests::result::TestKind::Standard] */
export interface StandardTestKind {
  /** The gas consumed by the test. */
  readonly consumedGas: bigint
}
/** See [edr_solidity_tests::result::TestKind::Fuzz] */
export interface FuzzTestKind {
  /** See [edr_solidity_tests::result::TestKind::Fuzz] */
  readonly runs: bigint
  /** See [edr_solidity_tests::result::TestKind::Fuzz] */
  readonly meanGas: bigint
  /** See [edr_solidity_tests::result::TestKind::Fuzz] */
  readonly medianGas: bigint
}
/** See [edr_solidity_tests::fuzz::FuzzCase] */
export interface FuzzCase {
  /** The calldata used for this fuzz test */
  readonly calldata: Uint8Array
  /** Consumed gas */
  readonly gas: bigint
  /** The initial gas stipend for the transaction */
  readonly stipend: bigint
}
/** See [edr_solidity_tests::result::TestKind::Invariant] */
export interface InvariantTestKind {
  /** See [edr_solidity_tests::result::TestKind::Invariant] */
  readonly runs: bigint
  /** See [edr_solidity_tests::result::TestKind::Invariant] */
  readonly calls: bigint
  /** See [edr_solidity_tests::result::TestKind::Invariant] */
  readonly reverts: bigint
}
/**
 * Original sequence size and sequence of calls used as a counter example
 * for invariant tests.
 */
export interface CounterExampleSequence {
  /** The original sequence size before shrinking. */
  originalSequenceSize: bigint
  /** The shrunk counterexample sequence. */
  sequence: Array<BaseCounterExample>
}
/** See [edr_solidity_tests::fuzz::BaseCounterExample] */
export interface BaseCounterExample {
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::sender] */
  readonly sender?: Uint8Array
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::addr] */
  readonly address?: Uint8Array
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::calldata] */
  readonly calldata: Uint8Array
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::contract_name] */
  readonly contractName?: string
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::signature] */
  readonly signature?: string
  /** See [edr_solidity_tests::fuzz::BaseCounterExample::args] */
  readonly args?: string
}
/**
 * Object representing a call in an execution trace, including contract
 * creation.
 */
export interface CallTrace {
  /** The kind of call or contract creation this represents. */
  kind: CallKind
  /** Whether the call succeeded or reverted. */
  success: boolean
  /** Whether the call is a cheatcode. */
  isCheatcode: boolean
  /** The amount of gas that was consumed. */
  gasUsed: bigint
  /** The amount of native token that was included with the call. */
  value: bigint
  /** The target address of the call. */
  address: string
  /** The name of the contract that is the target of the call, if known. */
  contract?: string
  /**
   * The input (calldata) to the call. If it encodes a known function call,
   * it will be decoded into the function name and a list of arguments.
   * For example, `{ name: "ownerOf", arguments: ["1"] }`. Note that the
   * function name may also be any of the special `fallback` and `receive`
   * functions. Otherwise, it will be provided as a raw byte array.
   */
  inputs: DecodedTraceParameters | Uint8Array
  /**
   * The output of the call. This will be a decoded human-readable
   * representation of the value if the function is known, otherwise a
   * raw byte array.
   */
  outputs: string | Uint8Array
  /**
   * Interleaved subcalls and event logs. Use `kind` to check if each member
   * of the array is a call or log trace.
   */
  children: Array<CallTrace | LogTrace>
}
/** Object representing an event log in an execution trace. */
export interface LogTrace {
  /** A constant to help discriminate the union `CallTrace | LogTrace`. */
  kind: LogKind
  /**
   * If the log is a known event (based on its first topic), it will be
   * decoded into the event name and list of named parameters. For
   * example, `{ name: "Log", arguments: ["value: 1"] }`. Otherwise, it
   * will be provided as an array where all but the last element are the
   * log topics, and the last element is the log data.
   */
  parameters: DecodedTraceParameters | Array<Uint8Array>
}
/** The various kinds of call frames possible in the EVM. */
export enum CallKind {
  /** Regular call that may change state. */
  Call = 0,
  /**
   * Variant of `DelegateCall` that doesn't preserve sender or value in the
   * frame.
   */
  CallCode = 1,
  /** Call that executes the code of the target in the context of the caller. */
  DelegateCall = 2,
  /** Regular call that may not change state. */
  StaticCall = 3,
  /** Contract creation. */
  Create = 4
}
/** Kind marker for log traces. */
export enum LogKind {
  /** Single kind of log. */
  Log = 5
}
/** Decoded function call or event. */
export interface DecodedTraceParameters {
  /** The name of a function or an event. */
  name: string
  /**
   * The arguments of the function call or the event, in their human-readable
   * representations.
   */
  arguments: Array<string>
}
/** Configuration for subscriptions. */
export interface SubscriptionConfig {
  /** Callback to be called when a new event is received. */
  subscriptionCallback: (event: SubscriptionEvent) => void
}
export interface SubscriptionEvent {
  filterId: bigint
  result: any
}
export declare function linkHexStringBytecode(code: string, address: string, position: number): string
export declare function printStackTrace(trace: SolidityStackTrace): void
/** Represents the exit code of the EVM. */
export enum ExitCode {
  /** Execution was successful. */
  SUCCESS = 0,
  /** Execution was reverted. */
  REVERT = 1,
  /** Execution ran out of gas. */
  OUT_OF_GAS = 2,
  /** Execution encountered an internal error. */
  INTERNAL_ERROR = 3,
  /** Execution encountered an invalid opcode. */
  INVALID_OPCODE = 4,
  /** Execution encountered a stack underflow. */
  STACK_UNDERFLOW = 5,
  /** Create init code size exceeds limit (runtime). */
  CODESIZE_EXCEEDS_MAXIMUM = 6,
  /** Create collision. */
  CREATE_COLLISION = 7,
  /** Unknown halt reason. */
  UNKNOWN_HALT_REASON = 8
}
export enum ContractFunctionType {
  CONSTRUCTOR = 0,
  FUNCTION = 1,
  FALLBACK = 2,
  RECEIVE = 3,
  GETTER = 4,
  MODIFIER = 5,
  FREE_FUNCTION = 6
}
export enum StackTraceEntryType {
  CALLSTACK_ENTRY = 0,
  UNRECOGNIZED_CREATE_CALLSTACK_ENTRY = 1,
  UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY = 2,
  PRECOMPILE_ERROR = 3,
  REVERT_ERROR = 4,
  PANIC_ERROR = 5,
  CUSTOM_ERROR = 6,
  FUNCTION_NOT_PAYABLE_ERROR = 7,
  INVALID_PARAMS_ERROR = 8,
  FALLBACK_NOT_PAYABLE_ERROR = 9,
  FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR = 10,
  UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR = 11,
  MISSING_FALLBACK_OR_RECEIVE_ERROR = 12,
  RETURNDATA_SIZE_ERROR = 13,
  NONCONTRACT_ACCOUNT_CALLED_ERROR = 14,
  CALL_FAILED_ERROR = 15,
  DIRECT_LIBRARY_CALL_ERROR = 16,
  UNRECOGNIZED_CREATE_ERROR = 17,
  UNRECOGNIZED_CONTRACT_ERROR = 18,
  OTHER_EXECUTION_ERROR = 19,
  UNMAPPED_SOLC_0_6_3_REVERT_ERROR = 20,
  CONTRACT_TOO_LARGE_ERROR = 21,
  INTERNAL_FUNCTION_CALLSTACK_ENTRY = 22,
  CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR = 23,
  CHEATCODE_ERROR = 24
}
export declare function stackTraceEntryTypeToString(val: StackTraceEntryType): string
export const FALLBACK_FUNCTION_NAME: string
export const RECEIVE_FUNCTION_NAME: string
export const CONSTRUCTOR_FUNCTION_NAME: string
export const UNRECOGNIZED_FUNCTION_NAME: string
export const UNKNOWN_FUNCTION_NAME: string
export const PRECOMPILE_FUNCTION_NAME: string
export const UNRECOGNIZED_CONTRACT_NAME: string
export interface SourceReference {
  sourceName: string
  sourceContent: string
  contract?: string
  function?: string
  line: number
  range: Array<number>
}
export interface CallstackEntryStackTraceEntry {
  type: StackTraceEntryType.CALLSTACK_ENTRY
  sourceReference: SourceReference
  functionType: ContractFunctionType
}
export interface UnrecognizedCreateCallstackEntryStackTraceEntry {
  type: StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY
  sourceReference?: undefined
}
export interface UnrecognizedContractCallstackEntryStackTraceEntry {
  type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY
  address: Uint8Array
  sourceReference?: undefined
}
export interface PrecompileErrorStackTraceEntry {
  type: StackTraceEntryType.PRECOMPILE_ERROR
  precompile: number
  sourceReference?: undefined
}
export interface RevertErrorStackTraceEntry {
  type: StackTraceEntryType.REVERT_ERROR
  returnData: Uint8Array
  sourceReference: SourceReference
  isInvalidOpcodeError: boolean
}
export interface PanicErrorStackTraceEntry {
  type: StackTraceEntryType.PANIC_ERROR
  errorCode: bigint
  sourceReference?: SourceReference
}
export interface CustomErrorStackTraceEntry {
  type: StackTraceEntryType.CUSTOM_ERROR
  message: string
  sourceReference: SourceReference
}
export interface FunctionNotPayableErrorStackTraceEntry {
  type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR
  value: bigint
  sourceReference: SourceReference
}
export interface InvalidParamsErrorStackTraceEntry {
  type: StackTraceEntryType.INVALID_PARAMS_ERROR
  sourceReference: SourceReference
}
export interface FallbackNotPayableErrorStackTraceEntry {
  type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR
  value: bigint
  sourceReference: SourceReference
}
export interface FallbackNotPayableAndNoReceiveErrorStackTraceEntry {
  type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR
  value: bigint
  sourceReference: SourceReference
}
export interface UnrecognizedFunctionWithoutFallbackErrorStackTraceEntry {
  type: StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR
  sourceReference: SourceReference
}
export interface MissingFallbackOrReceiveErrorStackTraceEntry {
  type: StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR
  sourceReference: SourceReference
}
export interface ReturndataSizeErrorStackTraceEntry {
  type: StackTraceEntryType.RETURNDATA_SIZE_ERROR
  sourceReference: SourceReference
}
export interface NonContractAccountCalledErrorStackTraceEntry {
  type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR
  sourceReference: SourceReference
}
export interface CallFailedErrorStackTraceEntry {
  type: StackTraceEntryType.CALL_FAILED_ERROR
  sourceReference: SourceReference
}
export interface DirectLibraryCallErrorStackTraceEntry {
  type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR
  sourceReference: SourceReference
}
export interface UnrecognizedCreateErrorStackTraceEntry {
  type: StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR
  returnData: Uint8Array
  sourceReference?: undefined
  isInvalidOpcodeError: boolean
}
export interface UnrecognizedContractErrorStackTraceEntry {
  type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR
  address: Uint8Array
  returnData: Uint8Array
  sourceReference?: undefined
  isInvalidOpcodeError: boolean
}
export interface OtherExecutionErrorStackTraceEntry {
  type: StackTraceEntryType.OTHER_EXECUTION_ERROR
  sourceReference?: SourceReference
}
export interface UnmappedSolc063RevertErrorStackTraceEntry {
  type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR
  sourceReference?: SourceReference
}
export interface ContractTooLargeErrorStackTraceEntry {
  type: StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR
  sourceReference?: SourceReference
}
export interface InternalFunctionCallStackEntry {
  type: StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY
  pc: number
  sourceReference: SourceReference
}
export interface ContractCallRunOutOfGasError {
  type: StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR
  sourceReference?: SourceReference
}
export interface CheatcodeErrorStackTraceEntry {
  type: StackTraceEntryType.CHEATCODE_ERROR
  message: string
  sourceReference: SourceReference
}
export interface TracingMessage {
  /** Sender address */
  readonly caller: Uint8Array
  /** Recipient address. None if it is a Create message. */
  readonly to?: Uint8Array
  /** Whether it's a static call */
  readonly isStaticCall: boolean
  /** Transaction gas limit */
  readonly gasLimit: bigint
  /** Depth of the message */
  readonly depth: number
  /** Input data of the message */
  readonly data: Uint8Array
  /** Value sent in the message */
  readonly value: bigint
  /**
   * Address of the code that is being executed. Can be different from `to`
   * if a delegate call is being done.
   */
  readonly codeAddress?: Uint8Array
  /** Code of the contract that is being executed. */
  readonly code?: Uint8Array
}
export interface TracingStep {
  /** Call depth */
  readonly depth: number
  /** The program counter */
  readonly pc: bigint
  /** The executed op code */
  readonly opcode: string
  /**
   * The entries on the stack. It only contains the top element unless
   * verbose tracing is enabled. The vector is empty if there are no elements
   * on the stack.
   */
  readonly stack: Array<bigint>
  /** The memory at the step. None if verbose tracing is disabled. */
  readonly memory?: Uint8Array
}
export interface TracingMessageResult {
  /** Execution result */
  readonly executionResult: ExecutionResult
}
/**
 * Returns the latest version of solc that EDR officially
 * supports and is tested against.
 */
export declare function getLatestSupportedSolcVersion(): string
export interface Withdrawal {
  /** The index of withdrawal */
  index: bigint
  /** The index of the validator that generated the withdrawal */
  validatorIndex: bigint
  /** The recipient address for withdrawal value */
  address: Uint8Array
  /** The value contained in withdrawal */
  amount: bigint
}
export declare class EdrContext {
  /**Creates a new [`EdrContext`] instance. Should only be called once! */
  constructor()
  /**Constructs a new provider with the provided configuration. */
  createProvider(chainType: string, providerConfig: ProviderConfig, loggerConfig: LoggerConfig, subscriptionConfig: SubscriptionConfig, tracingConfig: TracingConfigWithBuffers): Promise<Provider>
  /**Registers a new provider factory for the provided chain type. */
  registerProviderFactory(chainType: string, factory: ProviderFactory): Promise<void>
  registerSolidityTestRunnerFactory(chainType: string, factory: SolidityTestRunnerFactory): Promise<void>
  /**
   *Executes Solidity tests.
   *
   *The function will return as soon as test execution is started.
   *The progress callback will be called with the results of each test
   *suite. It is up to the caller to track how many times the callback
   *is called to know when all tests are done.
   */
  runSolidityTests(chainType: string, artifacts: Array<Artifact>, testSuites: Array<ArtifactId>, configArgs: SolidityTestRunnerConfigArgs, tracingConfig: TracingConfigWithBuffers, onTestSuiteCompletedCallback: (result: SuiteResult) => void): Promise<void>
}
export declare class Precompile {
  /** Returns the address of the precompile. */
  get address(): Uint8Array
}
export declare class ProviderFactory { }
export declare class Response {
  /**Returns the response data as a JSON string or a JSON object. */
  get data(): string | any
  /**Compute the error stack trace. Return the stack trace if it can be decoded, otherwise returns none. Throws if there was an error computing the stack trace. */
  stackTrace(): SolidityStackTrace | null
  /**Returns the raw traces of executed contracts. This maybe contain zero or more traces. */
  get traces(): Array<RawTrace>
}
/** A JSON-RPC provider for Ethereum. */
export declare class Provider {
  /**
   *Adds a compilation result to the instance.
   *
   *For internal use only. Support for this method may be removed in the future.
   */
  addCompilationResult(solcVersion: string, compilerInput: any, compilerOutput: any): Promise<boolean>
  /**Handles a JSON-RPC request and returns a JSON-RPC response. */
  handleRequest(request: string): Promise<Response>
  setCallOverrideCallback(callOverrideCallback: (contract_address: ArrayBuffer, data: ArrayBuffer) => Promise<CallOverrideResult | undefined>): Promise<void>
  /**
   * Set to `true` to make the traces returned with `eth_call`,
   * `eth_estimateGas`, `eth_sendRawTransaction`, `eth_sendTransaction`,
   * `evm_mine`, `hardhat_mine` include the full stack and memory. Set to
   * `false` to disable this.
   */
  setVerboseTracing(verboseTracing: boolean): Promise<void>
}
export declare class SolidityTestRunnerFactory { }
/** See [edr_solidity_tests::result::SuiteResult] */
export declare class SuiteResult {
  /**
   * The artifact id can be used to match input to result in the progress
   * callback
   */
  readonly id: ArtifactId
  /** See [edr_solidity_tests::result::SuiteResult::duration] */
  readonly durationNs: bigint
  /** See [edr_solidity_tests::result::SuiteResult::test_results] */
  readonly testResults: Array<TestResult>
  /** See [edr_solidity_tests::result::SuiteResult::warnings] */
  readonly warnings: Array<string>
}
/** See [edr_solidity_tests::result::TestResult] */
export declare class TestResult {
  /** The name of the test. */
  readonly name: string
  /** See [edr_solidity_tests::result::TestResult::status] */
  readonly status: TestStatus
  /** See [edr_solidity_tests::result::TestResult::reason] */
  readonly reason?: string
  /** See [edr_solidity_tests::result::TestResult::counterexample] */
  readonly counterexample?: BaseCounterExample | CounterExampleSequence
  /** See [edr_solidity_tests::result::TestResult::decoded_logs] */
  readonly decodedLogs: Array<string>
  /** See [edr_solidity_tests::result::TestResult::kind] */
  readonly kind: StandardTestKind | FuzzTestKind | InvariantTestKind
  /** See [edr_solidity_tests::result::TestResult::duration] */
  readonly durationNs: bigint
  /**
   * Groups of value snapshot entries (incl. gas).
   *
   * Only present if the test runner collected scoped snapshots. Currently,
   * this is always the case.
   */
  readonly valueSnapshotGroups?: Array<ValueSnapshotGroup>
  /**
   * Compute the error stack trace.
   * The result is either the stack trace or the reason why we couldn't
   * generate the stack trace.
   * Returns null if the test status is succeeded or skipped.
   * Cannot throw.
   */
  stackTrace(): StackTrace | UnexpectedError | HeuristicFailed | UnsafeToReplay | null
  /**
   * Constructs the execution traces for the test. Returns an empty array if
   * traces for this test were not requested according to
   * [`crate::solidity_tests::config::SolidityTestRunnerConfigArgs::include_traces`]. Otherwise, returns
   * an array of the root calls of the trace, which always includes the test
   * call itself and may also include the setup call if there is one
   * (identified by the function name `setUp`).
   */
  callTraces(): Array<CallTrace>
}
export declare class Exit {
  get kind(): ExitCode
  isError(): boolean
  getReason(): string
}
/**
 * Opaque handle to the `Bytecode` struct.
 * Only used on the JS side by the `VmTraceDecoder` class.
 */
export declare class BytecodeWrapper { }
export declare class ReturnData {
  readonly value: Uint8Array
  constructor(value: Uint8Array)
  isEmpty(): boolean
  isErrorReturnData(): boolean
  isPanicReturnData(): boolean
  decodeError(): string
  decodePanic(): bigint
}
export declare class RawTrace {
  get trace(): Array<TracingMessage | TracingStep | TracingMessageResult>
}
