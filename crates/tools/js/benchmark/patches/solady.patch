diff --git a/docs/accounts/eip7702proxy.md b/docs/accounts/eip7702proxy.md
deleted file mode 100644
index 6d16e36..0000000
--- a/docs/accounts/eip7702proxy.md
+++ /dev/null
@@ -1,72 +0,0 @@
-# EIP7702Proxy
-
-Relay proxy for EIP7702 delegations.
-
-
-<b>Note:</b>
-
-This relay proxy is useful for upgradeable EIP7702 accounts
-without the need for redelegation.
-
-EOA -> EIP7702Proxy (relay) -> EIP7702 account implementation.
-
-This relay proxy also allows for correctly revealing the
-"Read as Proxy" and "Write as Proxy" tabs on Etherscan.
-
-
-
-<!-- customintro:start --><!-- customintro:end -->
-
-## Immutables
-
-### __self
-
-```solidity
-uint256 internal immutable __self = uint256(uint160(address(this)))
-```
-
-For differentiating calls on the EOA and calls on the proxy itself.
-
-### _defaultImplementation
-
-```solidity
-uint256 internal immutable _defaultImplementation
-```
-
-The default implementation. Provided for optimization.   
-Set if the `initialAdmin == address(0) && initialImplementation != address(0)`.
-
-## Storage
-
-### _ERC1967_IMPLEMENTATION_SLOT
-
-```solidity
-bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =
-    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
-```
-
-The ERC-1967 storage slot for the implementation in the proxy.   
-`uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-
-### _ERC1967_ADMIN_SLOT
-
-```solidity
-bytes32 internal constant _ERC1967_ADMIN_SLOT =
-    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
-```
-
-The ERC-1967 storage slot for the admin in the proxy.   
-`uint256(keccak256("eip1967.proxy.admin")) - 1`.
-
-### _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT
-
-```solidity
-bytes32 internal constant
-    _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT =
-        0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f
-```
-
-The transient storage slot for requesting the proxy to initialize the implementation.   
-`uint256(keccak256("eip7702.proxy.delegation.initialization.request")) - 1`.   
-While we would love to use a smaller constant, this slot is used in both the proxy   
-and the delegation, so we shall just use bytes32 in case we want to standardize this.
\ No newline at end of file
diff --git a/docs/accounts/libeip7702.md b/docs/accounts/libeip7702.md
deleted file mode 100644
index 03fea9c..0000000
--- a/docs/accounts/libeip7702.md
+++ /dev/null
@@ -1,233 +0,0 @@
-# LibEIP7702
-
-Library for EIP7702 operations.
-
-
-
-
-
-
-<!-- customintro:start --><!-- customintro:end -->
-
-## Custom Errors
-
-### DeploymentFailed()
-
-```solidity
-error DeploymentFailed()
-```
-
-Failed to deploy the EIP7702Proxy.
-
-### ProxyQueryFailed()
-
-```solidity
-error ProxyQueryFailed()
-```
-
-The proxy query has failed.
-
-### ChangeProxyAdminFailed()
-
-```solidity
-error ChangeProxyAdminFailed()
-```
-
-Failed to change the proxy admin.
-
-### UpgradeProxyFailed()
-
-```solidity
-error UpgradeProxyFailed()
-```
-
-Failed to upgrade the proxy.
-
-## Constants
-
-### ERC1967_IMPLEMENTATION_SLOT
-
-```solidity
-bytes32 internal constant ERC1967_IMPLEMENTATION_SLOT =
-    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
-```
-
-The ERC-1967 storage slot for the implementation in the proxy.   
-`uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-
-### EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT
-
-```solidity
-bytes32 internal constant
-    EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT =
-        0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f
-```
-
-The transient storage slot for requesting the proxy to initialize the implementation.   
-`uint256(keccak256("eip7702.proxy.delegation.initialization.request")) - 1`.   
-While we would love to use a smaller constant, this slot is used in both the proxy   
-and the delegation, so we shall just use bytes32 in case we want to standardize this.
-
-### EIP7702_PROXY_CREATION_CODE
-
-```solidity
-bytes internal constant EIP7702_PROXY_CREATION_CODE =
-    hex"60c06040819052306080526102d63881900390819083398101604081905261002691610096565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8290557fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103819055811515110260a0526100c7565b80516001600160a01b0381168114610091575f5ffd5b919050565b5f5f604083850312156100a7575f5ffd5b6100b08361007b565b91506100be6020840161007b565b90509250929050565b60805160a0516101f06100e65f395f602701525f600601526101f05ff3fe60016040527f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc361960601c30841861010a576001361161008657815481165f5260205ff35b5f3560e01c80635c60da1b036100a157825482165f5260205ff35b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61038163f851a440036100d65780545f5260205ff35b80543303610106578382630900f01014028183638f2839701402178015610104576004358416815560206040f35b505b5f5ffd5b815481163660010361013b5780610133575082806101335760205f5f5f885afa15610106573d5ff35b805f5260205ff35b365f5f37806101a7575082806101a7576020365f5f885afa5f5f365f36515af416610168573d5f5f3e3d5ffd5b7f94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f805c1561019e57365184548419161784555f815d5b503d5f5f3e3d5ff35b5f5f365f845af461019e573d5f5f3e3d5ffdfea2646970667358221220e8b1a2a38594baf32c154aa7dd7743c9cd741d4f386b5ab588a5dcd613c3a00e64736f6c634300081c0033"
-```
-
-The creation code for the EIP7702Proxy.   
-This is generated from [`EIP7702Proxy.sol`](accounts/eip7702proxy.md) with exact compilation settings.
-
-### EIP7702_PROXY_MINIMAL_CODE_HASH
-
-```solidity
-bytes32 internal constant EIP7702_PROXY_MINIMAL_CODE_HASH =
-    0xf8710866f390ac7c12640457f9cb9663657ac8168b7d4ce6418a982932b3043e
-```
-
-The keccak256 of runtime code for [`EIP7702Proxy.sol`](accounts/eip7702proxy.md) with exact compilation settings,   
-with immutables zeroized and without the CBOR metadata.
-
-### EIP7702_PROXY_MINIMAL_CODE_LENGTH
-
-```solidity
-uint256 internal constant EIP7702_PROXY_MINIMAL_CODE_LENGTH = 0x1ba
-```
-
-The length of the runtime code for [`EIP7702Proxy.sol`](accounts/eip7702proxy.md) with exact compilation settings,   
-with immutables zeroized and without the CBOR metadata.
-
-## Authority And Proxy Operations
-
-### delegationOf(address)
-
-```solidity
-function delegationOf(address account)
-    internal
-    view
-    returns (address result)
-```
-
-Returns the delegation of the account.   
-If the account is not an EIP7702 authority, returns `address(0)`.
-
-### delegationAndImplementationOf(address)
-
-```solidity
-function delegationAndImplementationOf(address account)
-    internal
-    view
-    returns (address delegation, address implementation)
-```
-
-Returns the delegation and the implementation of the account.   
-If the account delegation is not a valid EIP7702Proxy, returns `address(0)`.
-
-### implementationOf(address)
-
-```solidity
-function implementationOf(address target)
-    internal
-    view
-    returns (address result)
-```
-
-Returns the implementation of `target`.   
-If `target` is neither an EIP7702Proxy nor an EOA delegated to an EIP7702Proxy, returns `address(0)`.
-
-### isEIP7702Proxy(address)
-
-```solidity
-function isEIP7702Proxy(address target)
-    internal
-    view
-    returns (bool result)
-```
-
-Returns if `target` is an valid EIP7702Proxy based on a bytecode hash check.
-
-### proxyInitCode(address,address)
-
-```solidity
-function proxyInitCode(address initialImplementation, address initialAdmin)
-    internal
-    pure
-    returns (bytes memory)
-```
-
-Returns the initialization code for the EIP7702Proxy.
-
-### deployProxy(address,address)
-
-```solidity
-function deployProxy(address initialImplementation, address initialAdmin)
-    internal
-    returns (address instance)
-```
-
-Deploys an EIP7702Proxy.
-
-### deployProxyDeterministic(address,address,bytes32)
-
-```solidity
-function deployProxyDeterministic(
-    address initialImplementation,
-    address initialAdmin,
-    bytes32 salt
-) internal returns (address instance)
-```
-
-Deploys an EIP7702Proxy to a deterministic address with `salt`.
-
-### proxyAdmin(address)
-
-```solidity
-function proxyAdmin(address proxy) internal view returns (address result)
-```
-
-Returns the admin of the proxy.   
-Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-
-### changeProxyAdmin(address,address)
-
-```solidity
-function changeProxyAdmin(address proxy, address newAdmin) internal
-```
-
-Changes the admin on the proxy. The caller must be the admin.   
-Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-
-### upgradeProxy(address,address)
-
-```solidity
-function upgradeProxy(address proxy, address newImplementation) internal
-```
-
-Changes the implementation on the proxy. The caller must be the admin.   
-Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-
-## UUPS Operations
-
-### upgradeProxyDelegation(address)
-
-```solidity
-function upgradeProxyDelegation(address newImplementation) internal
-```
-
-Upgrades the implementation.   
-The new implementation will NOT be active until the next UserOp or transaction.   
-To "auto-upgrade" to the latest implementation on the proxy, pass in `address(0)` to reset   
-the implementation slot. This causes the proxy to use the latest default implementation,   
-which may be optionally reinitialized via `requestProxyDelegationInitialization()`.   
-This function is intended to be used on the authority of an EIP7702Proxy delegation.   
-The most intended usage pattern is to wrap this in an access-gated admin function.
-
-### requestProxyDelegationInitialization()
-
-```solidity
-function requestProxyDelegationInitialization() internal
-```
-
-Requests the implementation to be initialized to the latest implementation on the proxy.   
-This function is intended to be used on the authority of an EIP7702Proxy delegation.   
-The most intended usage pattern is to place it at the end of an `execute` function.
\ No newline at end of file
diff --git a/foundry.toml b/foundry.toml
index 6afdd63..f9bff14 100644
--- a/foundry.toml
+++ b/foundry.toml
@@ -5,16 +5,13 @@
 # The Default Profile
 [profile.default]
 solc_version = "0.8.30"
-evm_version = "paris" # Cancun will be tested in the CI.
+evm_version = "cancun" # Changed to Cancun as Hardhat doesn't support the skip option
 auto_detect_solc = false
 optimizer = true
 optimizer_runs = 1_000
 gas_limit = 100_000_000 # ETH is 30M, but we use a higher value.
 skip = ["*/*7702*", "*/*Transient*", "*/ext/ithaca/*", "*/ext/zksync/*"]
 fs_permissions = [{ access = "read", path = "./test/data"}]
-remappings = [
-  "forge-std=test/utils/forge-std/"
-]
 
 [profile.pre_global_structs]
 skip = ["*/g/*", "*/*7702*", "*/*Transient*", "*/ext/ithaca/*", "*/ext/zksync/*"]
diff --git a/hardhat.config.js b/hardhat.config.js
new file mode 100644
index 0000000..2bf52c4
--- /dev/null
+++ b/hardhat.config.js
@@ -0,0 +1,35 @@
+module.exports = {
+"paths": {
+  "sources": "src",
+  "tests": {
+    "solidity": "test"
+  }
+},
+"solidity": {
+  "version": "0.8.30",
+  "settings": {
+    "optimizer": {
+      "enabled": true,
+      "runs": 1000
+    },
+    "evmVersion": "cancun",
+    "viaIR": true
+  }
+},
+"solidityTest": {
+  "fsPermissions": {
+    "read": ["./test/data"],
+  },
+  "gasLimit": 100_000_000n,
+  "fuzz": {
+    "runs": 256,
+    "seed":"0x4444"
+  },
+  "invariant": {
+    "runs": 10,
+    "depth": 15,
+    "seed":"0x4444"
+  }
+}
+};
+
diff --git a/package-lock.json b/package-lock.json
index e58c913..c36865a 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "solady",
-  "version": "0.0.55",
+  "version": "0.1.24",
   "lockfileVersion": 2,
   "requires": true,
   "packages": {
     "": {
       "name": "solady",
-      "version": "0.0.55",
+      "version": "0.1.24",
       "license": "MIT"
     }
   }
diff --git a/remappings.txt b/remappings.txt
new file mode 100644
index 0000000..85ac6bb
--- /dev/null
+++ b/remappings.txt
@@ -0,0 +1,2 @@
+forge-std=test/utils/forge-std/
+src/=src/
\ No newline at end of file
diff --git a/src/accounts/EIP7702Proxy.sol b/src/accounts/EIP7702Proxy.sol
deleted file mode 100644
index 0254124..0000000
--- a/src/accounts/EIP7702Proxy.sol
+++ /dev/null
@@ -1,182 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-// solc: 0.8.28, optimization runs: 200, evm version: cancun.
-
-/// @notice Relay proxy for EIP7702 delegations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/EIP7702Proxy.sol)
-///
-/// @dev Note: This relay proxy is useful for upgradeable EIP7702 accounts
-/// without the need for redelegation.
-///
-/// EOA -> EIP7702Proxy (relay) -> EIP7702 account implementation.
-///
-/// This relay proxy also allows for correctly revealing the
-/// "Read as Proxy" and "Write as Proxy" tabs on Etherscan.
-contract EIP7702Proxy {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         IMMUTABLES                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev For differentiating calls on the EOA and calls on the proxy itself.
-    uint256 internal immutable __self = uint256(uint160(address(this)));
-
-    /// @dev The default implementation. Provided for optimization.
-    /// Set if the `initialAdmin == address(0) && initialImplementation != address(0)`.
-    uint256 internal immutable _defaultImplementation;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ERC-1967 storage slot for the implementation in the proxy.
-    /// `uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =
-        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
-
-    /// @dev The ERC-1967 storage slot for the admin in the proxy.
-    /// `uint256(keccak256("eip1967.proxy.admin")) - 1`.
-    bytes32 internal constant _ERC1967_ADMIN_SLOT =
-        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
-
-    /// @dev The transient storage slot for requesting the proxy to initialize the implementation.
-    /// `uint256(keccak256("eip7702.proxy.delegation.initialization.request")) - 1`.
-    /// While we would love to use a smaller constant, this slot is used in both the proxy
-    /// and the delegation, so we shall just use bytes32 in case we want to standardize this.
-    bytes32 internal constant _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT =
-        0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CONSTRUCTOR                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    constructor(address initialImplementation, address initialAdmin) payable {
-        uint256 defaultImplementation;
-        /// @solidity memory-safe-assembly
-        assembly {
-            // We will store the implementation in the storage regardless,
-            // to aid proxy detection on block explorers.
-            sstore(_ERC1967_IMPLEMENTATION_SLOT, initialImplementation)
-            sstore(_ERC1967_ADMIN_SLOT, initialAdmin)
-            defaultImplementation :=
-                mul(lt(initialAdmin, iszero(iszero(initialImplementation))), initialImplementation)
-        }
-        _defaultImplementation = defaultImplementation;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          FALLBACK                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    fallback() external payable virtual {
-        uint256 s = __self;
-        uint256 defaultImplementation = _defaultImplementation;
-        bytes32 implementationSlot = _ERC1967_IMPLEMENTATION_SLOT;
-        uint256 addrMask = (~msg.data.length) >> 96;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, 1)
-            // Workflow for calling on the proxy itself.
-            // We cannot put these functions in the public ABI as this proxy must
-            // fully forward all the calldata from EOAs pointing to this proxy.
-            if iszero(xor(address(), s)) {
-                if iszero(gt(calldatasize(), 1)) {
-                    mstore(0x00, and(addrMask, sload(implementationSlot)))
-                    return(0x00, 0x20)
-                }
-                let fnSel := shr(224, calldataload(0x00))
-                // `implementation()`.
-                if eq(0x5c60da1b, fnSel) {
-                    mstore(0x00, and(addrMask, sload(implementationSlot)))
-                    return(0x00, 0x20)
-                }
-                let adminSlot := _ERC1967_ADMIN_SLOT
-                // `admin()`.
-                if eq(0xf851a440, fnSel) {
-                    mstore(0x00, sload(adminSlot))
-                    return(0x00, 0x20)
-                }
-                // Admin workflow.
-                if eq(caller(), sload(adminSlot)) {
-                    let addrSlot :=
-                        or(
-                            mul(eq(0x8f283970, fnSel), adminSlot), // `changeAdmin(address)`.
-                            mul(eq(0x0900f010, fnSel), implementationSlot) // `upgrade(address)`.
-                        )
-                    if addrSlot {
-                        sstore(addrSlot, and(addrMask, calldataload(0x04)))
-                        return(0x40, 0x20) // Return `true`.
-                    }
-                    // For minimalism, we shall skip events and calldata bounds checks.
-                    // We don't need to forward any data to the new implementation.
-                    // This "proxy" is actually close to an upgradeable beacon.
-                }
-                revert(0x00, 0x00)
-            }
-            // Workflow for the EIP7702 authority (i.e. the EOA).
-            let implementation := and(addrMask, sload(implementationSlot)) // On EOA's storage.
-            // Special workflow for retrieving the implementation directly.
-            if eq(1, calldatasize()) {
-                // If the preferred implementation is `address(0)`.
-                if iszero(implementation) {
-                    implementation := defaultImplementation
-                    // If `defaultImplementation` is `address(0)`
-                    if iszero(implementation) {
-                        // Fetch the implementation from the proxy.
-                        if staticcall(gas(), s, 0x00, 0x00, 0x00, 0x20) {
-                            return(0x00, returndatasize())
-                        }
-                        revert(0x00, 0x00)
-                    }
-                }
-                mstore(0x00, implementation)
-                return(0x00, 0x20)
-            }
-            calldatacopy(0x00, 0x00, calldatasize()) // Copy the calldata for the delegatecall.
-            // If the preferred implementation is `address(0)`.
-            if iszero(implementation) {
-                implementation := defaultImplementation
-                // If `defaultImplementation` is `address(0)`, perform the initialization workflow.
-                if iszero(implementation) {
-                    if iszero(
-                        and( // The arguments of `and` are evaluated from right to left.
-                            delegatecall(
-                                gas(), mload(calldatasize()), 0x00, calldatasize(), 0x00, 0x00
-                            ),
-                            // Fetch the implementation from the proxy.
-                            staticcall(gas(), s, 0x00, 0x00, calldatasize(), 0x20)
-                        )
-                    ) {
-                        returndatacopy(0x00, 0x00, returndatasize())
-                        revert(0x00, returndatasize())
-                    }
-                    // Because we cannot reliably and efficiently tell if the call is made
-                    // via staticcall or call, we shall ask the delegation to make a proxy delegation
-                    // initialization request to signal that we should initialize the storage slot with
-                    // the actual implementation. This also gives flexibility on whether to let the
-                    // proxy auto-upgrade, or let the authority manually upgrade (via 7702 or passkey).
-                    // A non-zero value in the transient storage denotes a initialization request.
-                    let initializationRequestSlot :=
-                        _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT
-                    if tload(initializationRequestSlot) {
-                        // The `implementation` is still at `calldatasize()` in memory.
-                        // Preserve the upper 96 bits when updating in case they are used for some stuff.
-                        sstore(
-                            implementationSlot,
-                            or(and(not(addrMask), sload(implementationSlot)), mload(calldatasize()))
-                        )
-                        tstore(initializationRequestSlot, 0) // Clear.
-                    }
-                    returndatacopy(0x00, 0x00, returndatasize())
-                    return(0x00, returndatasize())
-                }
-            }
-            // Otherwise, just delegatecall and bubble up the results without initialization.
-            if iszero(delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)) {
-                returndatacopy(0x00, 0x00, returndatasize())
-                revert(0x00, returndatasize())
-            }
-            returndatacopy(0x00, 0x00, returndatasize())
-            return(0x00, returndatasize())
-        }
-    }
-}
diff --git a/src/accounts/LibEIP7702.sol b/src/accounts/LibEIP7702.sol
deleted file mode 100644
index 0280cbb..0000000
--- a/src/accounts/LibEIP7702.sol
+++ /dev/null
@@ -1,237 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-/// @notice Library for EIP7702 operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/LibEIP7702.sol)
-library LibEIP7702 {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Failed to deploy the EIP7702Proxy.
-    error DeploymentFailed();
-
-    /// @dev The proxy query has failed.
-    error ProxyQueryFailed();
-
-    /// @dev Failed to change the proxy admin.
-    error ChangeProxyAdminFailed();
-
-    /// @dev Failed to upgrade the proxy.
-    error UpgradeProxyFailed();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ERC-1967 storage slot for the implementation in the proxy.
-    /// `uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-    bytes32 internal constant ERC1967_IMPLEMENTATION_SLOT =
-        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
-
-    /// @dev The transient storage slot for requesting the proxy to initialize the implementation.
-    /// `uint256(keccak256("eip7702.proxy.delegation.initialization.request")) - 1`.
-    /// While we would love to use a smaller constant, this slot is used in both the proxy
-    /// and the delegation, so we shall just use bytes32 in case we want to standardize this.
-    bytes32 internal constant EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT =
-        0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f;
-
-    /// @dev The creation code for the EIP7702Proxy.
-    /// This is generated from `EIP7702Proxy.sol` with exact compilation settings.
-    bytes internal constant EIP7702_PROXY_CREATION_CODE =
-        hex"60c06040819052306080526102d63881900390819083398101604081905261002691610096565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8290557fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103819055811515110260a0526100c7565b80516001600160a01b0381168114610091575f5ffd5b919050565b5f5f604083850312156100a7575f5ffd5b6100b08361007b565b91506100be6020840161007b565b90509250929050565b60805160a0516101f06100e65f395f602701525f600601526101f05ff3fe60016040527f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc361960601c30841861010a576001361161008657815481165f5260205ff35b5f3560e01c80635c60da1b036100a157825482165f5260205ff35b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61038163f851a440036100d65780545f5260205ff35b80543303610106578382630900f01014028183638f2839701402178015610104576004358416815560206040f35b505b5f5ffd5b815481163660010361013b5780610133575082806101335760205f5f5f885afa15610106573d5ff35b805f5260205ff35b365f5f37806101a7575082806101a7576020365f5f885afa5f5f365f36515af416610168573d5f5f3e3d5ffd5b7f94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f805c1561019e57365184548419161784555f815d5b503d5f5f3e3d5ff35b5f5f365f845af461019e573d5f5f3e3d5ffdfea2646970667358221220e8b1a2a38594baf32c154aa7dd7743c9cd741d4f386b5ab588a5dcd613c3a00e64736f6c634300081c0033";
-
-    /// @dev The keccak256 of runtime code for `EIP7702Proxy.sol` with exact compilation settings,
-    /// with immutables zeroized and without the CBOR metadata.
-    bytes32 internal constant EIP7702_PROXY_MINIMAL_CODE_HASH =
-        0xf8710866f390ac7c12640457f9cb9663657ac8168b7d4ce6418a982932b3043e;
-
-    /// @dev The length of the runtime code for `EIP7702Proxy.sol` with exact compilation settings,
-    /// with immutables zeroized and without the CBOR metadata.
-    uint256 internal constant EIP7702_PROXY_MINIMAL_CODE_LENGTH = 0x1ba;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*               AUTHORITY AND PROXY OPERATIONS               */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the delegation of the account.
-    /// If the account is not an EIP7702 authority, returns `address(0)`.
-    function delegationOf(address account) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            extcodecopy(account, 0x00, 0x00, 0x20)
-            // Note: Checking that it starts with hex"ef01" is the most general and futureproof.
-            // 7702 bytecode is `abi.encodePacked(hex"ef01", uint8(version), address(delegation))`.
-            result := mul(shr(96, mload(0x03)), eq(0xef01, shr(240, mload(0x00))))
-        }
-    }
-
-    /// @dev Returns the delegation and the implementation of the account.
-    /// If the account delegation is not a valid EIP7702Proxy, returns `address(0)`.
-    function delegationAndImplementationOf(address account)
-        internal
-        view
-        returns (address delegation, address implementation)
-    {
-        delegation = delegationOf(account);
-        if (isEIP7702Proxy(delegation)) {
-            /// @solidity memory-safe-assembly
-            assembly {
-                mstore(0x00, 0)
-                if iszero(staticcall(gas(), account, 0x00, 0x01, 0x00, 0x20)) { revert(0x00, 0x00) }
-                implementation := mload(0x00)
-            }
-        }
-    }
-
-    /// @dev Returns the implementation of `target`.
-    /// If `target` is neither an EIP7702Proxy nor an EOA delegated to an EIP7702Proxy, returns `address(0)`.
-    function implementationOf(address target) internal view returns (address result) {
-        if (!isEIP7702Proxy(target)) if (!isEIP7702Proxy(delegationOf(target))) return address(0);
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0)
-            if iszero(staticcall(gas(), target, 0x00, 0x01, 0x00, 0x20)) { revert(0x00, 0x00) }
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Returns if `target` is an valid EIP7702Proxy based on a bytecode hash check.
-    function isEIP7702Proxy(address target) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            // Copy the runtime bytecode without the CBOR metadata.
-            extcodecopy(target, m, 0x00, EIP7702_PROXY_MINIMAL_CODE_LENGTH)
-            // Zeroize the immutables.
-            mstore(add(m, 0x06), 0) // The first `7f<immutable_word>`.
-            mstore(add(m, 0x27), 0) // The second `7f<immutable_word>`.
-            let h := keccak256(m, EIP7702_PROXY_MINIMAL_CODE_LENGTH)
-            result := eq(EIP7702_PROXY_MINIMAL_CODE_HASH, h)
-        }
-    }
-
-    /// @dev Returns the initialization code for the EIP7702Proxy.
-    function proxyInitCode(address initialImplementation, address initialAdmin)
-        internal
-        pure
-        returns (bytes memory)
-    {
-        return abi.encodePacked(
-            EIP7702_PROXY_CREATION_CODE,
-            uint256(uint160(initialImplementation)),
-            uint256(uint160(initialAdmin))
-        );
-    }
-
-    /// @dev Deploys an EIP7702Proxy.
-    function deployProxy(address initialImplementation, address initialAdmin)
-        internal
-        returns (address instance)
-    {
-        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);
-        /// @solidity memory-safe-assembly
-        assembly {
-            instance := create(0, add(initCode, 0x20), mload(initCode))
-            if iszero(instance) {
-                mstore(0x00, 0x30116425) // `DeploymentFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Deploys an EIP7702Proxy to a deterministic address with `salt`.
-    function deployProxyDeterministic(
-        address initialImplementation,
-        address initialAdmin,
-        bytes32 salt
-    ) internal returns (address instance) {
-        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);
-        /// @solidity memory-safe-assembly
-        assembly {
-            instance := create2(0, add(initCode, 0x20), mload(initCode), salt)
-            if iszero(instance) {
-                mstore(0x00, 0x30116425) // `DeploymentFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Returns the admin of the proxy.
-    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-    function proxyAdmin(address proxy) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0xf851a440) // `admin()`.
-            let t := staticcall(gas(), proxy, 0x1c, 0x04, 0x00, 0x20)
-            if iszero(and(gt(returndatasize(), 0x1f), t)) {
-                mstore(0x00, 0x26ec9b6a) // `ProxyQueryFailed()`.
-                revert(0x1c, 0x04)
-            }
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Changes the admin on the proxy. The caller must be the admin.
-    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-    function changeProxyAdmin(address proxy, address newAdmin) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x8f283970) // `changeAdmin(address)`.
-            mstore(0x20, newAdmin) // The implementation will clean the upper 96 bits.
-            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {
-                mstore(0x00, 0xc502e37e) // `ChangeProxyAdminFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Changes the implementation on the proxy. The caller must be the admin.
-    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.
-    function upgradeProxy(address proxy, address newImplementation) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x0900f010) // `upgrade(address)`.
-            mstore(0x20, newImplementation) // The implementation will clean the upper 96 bits.
-            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {
-                mstore(0x00, 0xc6edd882) // `UpgradeProxyFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      UUPS OPERATIONS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Upgrades the implementation.
-    /// The new implementation will NOT be active until the next UserOp or transaction.
-    /// To "auto-upgrade" to the latest implementation on the proxy, pass in `address(0)` to reset
-    /// the implementation slot. This causes the proxy to use the latest default implementation,
-    /// which may be optionally reinitialized via `requestProxyDelegationInitialization()`.
-    /// This function is intended to be used on the authority of an EIP7702Proxy delegation.
-    /// The most intended usage pattern is to wrap this in an access-gated admin function.
-    function upgradeProxyDelegation(address newImplementation) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let s := ERC1967_IMPLEMENTATION_SLOT
-            // Preserve the upper 96 bits when updating in case they are used for some stuff.
-            mstore(0x00, sload(s))
-            mstore(0x0c, shl(96, newImplementation))
-            sstore(s, mload(0x00))
-        }
-    }
-
-    /// @dev Requests the implementation to be initialized to the latest implementation on the proxy.
-    /// This function is intended to be used on the authority of an EIP7702Proxy delegation.
-    /// The most intended usage pattern is to place it at the end of an `execute` function.
-    function requestProxyDelegationInitialization() internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(shl(96, sload(ERC1967_IMPLEMENTATION_SLOT))) {
-                // Use a dedicated transient storage slot for better Swiss-cheese-model safety.
-                tstore(EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT, address())
-            }
-        }
-    }
-}
diff --git a/src/tokens/ext/zksync/ERC1155.sol b/src/tokens/ext/zksync/ERC1155.sol
deleted file mode 100644
index 7b16b54..0000000
--- a/src/tokens/ext/zksync/ERC1155.sol
+++ /dev/null
@@ -1,1143 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice Simple ERC1155 implementation.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ext/zksync/ERC1155.sol)
-/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)
-/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)
-///
-/// @dev Note:
-/// - The ERC1155 standard allows for self-approvals.
-///   For performance, this implementation WILL NOT revert for such actions.
-///   Please add any checks with overrides if desired.
-///
-/// If you are overriding:
-/// - Make sure all variables written to storage are properly cleaned
-//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).
-/// - Check that the overridden function is actually used in the function you want to
-///   change the behavior of. Much of the code has been manually inlined for performance.
-abstract contract ERC1155 {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The lengths of the input arrays are not the same.
-    error ArrayLengthsMismatch();
-
-    /// @dev Cannot mint or transfer to the zero address.
-    error TransferToZeroAddress();
-
-    /// @dev The recipient's balance has overflowed.
-    error AccountBalanceOverflow();
-
-    /// @dev Insufficient balance.
-    error InsufficientBalance();
-
-    /// @dev Only the token owner or an approved account can manage the tokens.
-    error NotOwnerNorApproved();
-
-    /// @dev Cannot safely transfer to a contract that does not implement
-    /// the ERC1155Receiver interface.
-    error TransferToNonERC1155ReceiverImplementer();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Emitted when `amount` of token `id` is transferred
-    /// from `from` to `to` by `operator`.
-    event TransferSingle(
-        address indexed operator,
-        address indexed from,
-        address indexed to,
-        uint256 id,
-        uint256 amount
-    );
-
-    /// @dev Emitted when `amounts` of token `ids` are transferred
-    /// from `from` to `to` by `operator`.
-    event TransferBatch(
-        address indexed operator,
-        address indexed from,
-        address indexed to,
-        uint256[] ids,
-        uint256[] amounts
-    );
-
-    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.
-    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);
-
-    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`
-    /// is updated to `value`. This event is not used in the base contract.
-    /// You may need to emit this event depending on your URI logic.
-    ///
-    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata
-    event URI(string value, uint256 indexed id);
-
-    /// @dev `keccak256(bytes("TransferSingle(address,address,address,uint256,uint256)"))`.
-    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =
-        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;
-
-    /// @dev `keccak256(bytes("TransferBatch(address,address,address,uint256[],uint256[])"))`.
-    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =
-        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;
-
-    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.
-    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =
-        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The `ownerSlotSeed` of a given owner is given by.
-    /// ```
-    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))
-    /// ```
-    ///
-    /// The balance slot of `owner` is given by.
-    /// ```
-    ///     mstore(0x20, ownerSlotSeed)
-    ///     mstore(0x00, id)
-    ///     let balanceSlot := keccak256(0x00, 0x40)
-    /// ```
-    ///
-    /// The operator approval slot of `owner` is given by.
-    /// ```
-    ///     mstore(0x20, ownerSlotSeed)
-    ///     mstore(0x00, operator)
-    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)
-    /// ```
-    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      ERC1155 METADATA                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the URI for token `id`.
-    ///
-    /// You can either return the same templated URI for all token IDs,
-    /// (e.g. "https://example.com/api/{id}.json"),
-    /// or return a unique URI for each `id`.
-    ///
-    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata
-    function uri(uint256 id) public view virtual returns (string memory);
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          ERC1155                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the amount of `id` owned by `owner`.
-    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)
-            mstore(0x14, owner)
-            mstore(0x00, id)
-            result := sload(keccak256(0x00, 0x40))
-        }
-    }
-
-    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.
-    function isApprovedForAll(address owner, address operator)
-        public
-        view
-        virtual
-        returns (bool result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)
-            mstore(0x14, owner)
-            mstore(0x00, operator)
-            result := sload(keccak256(0x0c, 0x34))
-        }
-    }
-
-    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.
-    ///
-    /// Emits a {ApprovalForAll} event.
-    function setApprovalForAll(address operator, bool isApproved) public virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Convert to 0 or 1.
-            isApproved := iszero(iszero(isApproved))
-            // Update the `isApproved` for (`msg.sender`, `operator`).
-            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)
-            mstore(0x14, caller())
-            mstore(0x00, operator)
-            sstore(keccak256(0x0c, 0x34), isApproved)
-            // Emit the {ApprovalForAll} event.
-            mstore(0x00, isApproved)
-            // forgefmt: disable-next-line
-            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))
-        }
-    }
-
-    /// @dev Transfers `amount` of `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - `from` must have at least `amount` of `id`.
-    /// - If the caller is not `from`,
-    ///   it must be approved to manage the tokens of `from`.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155Received}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferSingle} event.
-    function safeTransferFrom(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes calldata data
-    ) public virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))
-            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))
-            mstore(0x20, fromSlotSeed)
-            // Clear the upper 96 bits.
-            from := shr(96, fromSlotSeed)
-            to := shr(96, toSlotSeed)
-            // Revert if `to` is the zero address.
-            if iszero(to) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            // If the caller is not `from`, do the authorization check.
-            if iszero(eq(caller(), from)) {
-                mstore(0x00, caller())
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Subtract and store the updated balance of `from`.
-            {
-                mstore(0x00, id)
-                let fromBalanceSlot := keccak256(0x00, 0x40)
-                let fromBalance := sload(fromBalanceSlot)
-                if gt(amount, fromBalance) {
-                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(fromBalanceSlot, sub(fromBalance, amount))
-            }
-            // Increase and store the updated balance of `to`.
-            {
-                mstore(0x20, toSlotSeed)
-                let toBalanceSlot := keccak256(0x00, 0x40)
-                let toBalanceBefore := sload(toBalanceSlot)
-                let toBalanceAfter := add(toBalanceBefore, amount)
-                if lt(toBalanceAfter, toBalanceBefore) {
-                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(toBalanceSlot, toBalanceAfter)
-            }
-            // Emit a {TransferSingle} event.
-            mstore(0x20, amount)
-            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, to, _single(id), _single(amount), data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Do the {onERC1155Received} check if `to` is a smart contract.
-            if extcodesize(to) {
-                // Prepare the calldata.
-                let m := mload(0x40)
-                // `onERC1155Received(address,address,uint256,uint256,bytes)`.
-                mstore(m, 0xf23a6e61)
-                mstore(add(m, 0x20), caller())
-                mstore(add(m, 0x40), from)
-                mstore(add(m, 0x60), id)
-                mstore(add(m, 0x80), amount)
-                mstore(add(m, 0xa0), 0xa0)
-                mstore(add(m, 0xc0), data.length)
-                calldatacopy(add(m, 0xe0), data.offset, data.length)
-                // Revert if the call reverts.
-                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {
-                    if returndatasize() {
-                        // Bubble up the revert if the call reverts.
-                        returndatacopy(m, 0x00, returndatasize())
-                        revert(m, returndatasize())
-                    }
-                }
-                // Load the returndata and compare it with the function selector.
-                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {
-                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-        }
-    }
-
-    /// @dev Transfers `amounts` of `ids` from `from` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - `from` must have at least `amount` of `id`.
-    /// - `ids` and `amounts` must have the same length.
-    /// - If the caller is not `from`,
-    ///   it must be approved to manage the tokens of `from`.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155BatchReceived}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferBatch} event.
-    function safeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] calldata ids,
-        uint256[] calldata amounts,
-        bytes calldata data
-    ) public virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, to, ids, amounts, data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(eq(ids.length, amounts.length)) {
-                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.
-                revert(0x1c, 0x04)
-            }
-            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))
-            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))
-            mstore(0x20, fromSlotSeed)
-            // Clear the upper 96 bits.
-            from := shr(96, fromSlotSeed)
-            to := shr(96, toSlotSeed)
-            // Revert if `to` is the zero address.
-            if iszero(to) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            // If the caller is not `from`, do the authorization check.
-            if iszero(eq(caller(), from)) {
-                mstore(0x00, caller())
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Loop through all the `ids` and update the balances.
-            {
-                for { let i := shl(5, ids.length) } i {} {
-                    i := sub(i, 0x20)
-                    let amount := calldataload(add(amounts.offset, i))
-                    // Subtract and store the updated balance of `from`.
-                    {
-                        mstore(0x20, fromSlotSeed)
-                        mstore(0x00, calldataload(add(ids.offset, i)))
-                        let fromBalanceSlot := keccak256(0x00, 0x40)
-                        let fromBalance := sload(fromBalanceSlot)
-                        if gt(amount, fromBalance) {
-                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(fromBalanceSlot, sub(fromBalance, amount))
-                    }
-                    // Increase and store the updated balance of `to`.
-                    {
-                        mstore(0x20, toSlotSeed)
-                        let toBalanceSlot := keccak256(0x00, 0x40)
-                        let toBalanceBefore := sload(toBalanceSlot)
-                        let toBalanceAfter := add(toBalanceBefore, amount)
-                        if lt(toBalanceAfter, toBalanceBefore) {
-                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(toBalanceSlot, toBalanceAfter)
-                    }
-                }
-            }
-            // Emit a {TransferBatch} event.
-            {
-                let m := mload(0x40)
-                // Copy the `ids`.
-                mstore(m, 0x40)
-                let n := shl(5, ids.length)
-                mstore(add(m, 0x40), ids.length)
-                calldatacopy(add(m, 0x60), ids.offset, n)
-                // Copy the `amounts`.
-                mstore(add(m, 0x20), add(0x60, n))
-                let o := add(add(m, n), 0x60)
-                mstore(o, ids.length)
-                calldatacopy(add(o, 0x20), amounts.offset, n)
-                // Do the emit.
-                log4(m, add(add(n, n), 0x80), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)
-            }
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransferCalldata(from, to, ids, amounts, data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.
-            if extcodesize(to) {
-                mstore(0x00, to) // Cache `to` to prevent stack too deep.
-                let m := mload(0x40)
-                // Prepare the calldata.
-                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.
-                mstore(m, 0xbc197c81)
-                mstore(add(m, 0x20), caller())
-                mstore(add(m, 0x40), from)
-                // Copy the `ids`.
-                mstore(add(m, 0x60), 0xa0)
-                let n := shl(5, ids.length)
-                mstore(add(m, 0xc0), ids.length)
-                calldatacopy(add(m, 0xe0), ids.offset, n)
-                // Copy the `amounts`.
-                mstore(add(m, 0x80), add(0xc0, n))
-                let o := add(add(m, n), 0xe0)
-                mstore(o, ids.length)
-                calldatacopy(add(o, 0x20), amounts.offset, n)
-                // Copy the `data`.
-                mstore(add(m, 0xa0), add(add(0xe0, n), n))
-                o := add(add(o, n), 0x20)
-                mstore(o, data.length)
-                calldatacopy(add(o, 0x20), data.offset, data.length)
-                let nAll := add(0x104, add(data.length, add(n, n)))
-                // Revert if the call reverts.
-                if iszero(call(gas(), mload(0x00), 0, add(mload(0x40), 0x1c), nAll, m, 0x20)) {
-                    if returndatasize() {
-                        // Bubble up the revert if the call reverts.
-                        returndatacopy(m, 0x00, returndatasize())
-                        revert(m, returndatasize())
-                    }
-                }
-                // Load the returndata and compare it with the function selector.
-                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {
-                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-        }
-    }
-
-    /// @dev Returns the amounts of `ids` for `owners.
-    ///
-    /// Requirements:
-    /// - `owners` and `ids` must have the same length.
-    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)
-        public
-        view
-        virtual
-        returns (uint256[] memory balances)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(eq(ids.length, owners.length)) {
-                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.
-                revert(0x1c, 0x04)
-            }
-            balances := mload(0x40)
-            mstore(balances, ids.length)
-            let o := add(balances, 0x20)
-            let i := shl(5, ids.length)
-            mstore(0x40, add(i, o))
-            // Loop through all the `ids` and load the balances.
-            for {} i {} {
-                i := sub(i, 0x20)
-                let owner := calldataload(add(owners.offset, i))
-                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))
-                mstore(0x00, calldataload(add(ids.offset, i)))
-                mstore(add(o, i), sload(keccak256(0x00, 0x40)))
-            }
-        }
-    }
-
-    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.
-    /// See: https://eips.ethereum.org/EIPS/eip-165
-    /// This function call must use less than 30000 gas.
-    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let s := shr(224, interfaceId)
-            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.
-            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  INTERNAL MINT FUNCTIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Mints `amount` of `id` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155Received}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferSingle} event.
-    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            let to_ := shl(96, to)
-            // Revert if `to` is the zero address.
-            if iszero(to_) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            // Increase and store the updated balance of `to`.
-            {
-                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)
-                mstore(0x14, to)
-                mstore(0x00, id)
-                let toBalanceSlot := keccak256(0x00, 0x40)
-                let toBalanceBefore := sload(toBalanceSlot)
-                let toBalanceAfter := add(toBalanceBefore, amount)
-                if lt(toBalanceAfter, toBalanceBefore) {
-                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(toBalanceSlot, toBalanceAfter)
-            }
-            // Emit a {TransferSingle} event.
-            mstore(0x20, amount)
-            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);
-        }
-        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);
-    }
-
-    /// @dev Mints `amounts` of `ids` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - `ids` and `amounts` must have the same length.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155BatchReceived}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferBatch} event.
-    function _batchMint(
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(address(0), to, ids, amounts, data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            if iszero(eq(mload(ids), mload(amounts))) {
-                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.
-                revert(0x1c, 0x04)
-            }
-            let to_ := shl(96, to)
-            // Revert if `to` is the zero address.
-            if iszero(to_) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            // Loop through all the `ids` and update the balances.
-            {
-                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))
-                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {
-                    let amount := mload(add(amounts, i))
-                    // Increase and store the updated balance of `to`.
-                    {
-                        mstore(0x00, mload(add(ids, i)))
-                        let toBalanceSlot := keccak256(0x00, 0x40)
-                        let toBalanceBefore := sload(toBalanceSlot)
-                        let toBalanceAfter := add(toBalanceBefore, amount)
-                        if lt(toBalanceAfter, toBalanceBefore) {
-                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(toBalanceSlot, toBalanceAfter)
-                    }
-                }
-            }
-            // Emit a {TransferBatch} event.
-            {
-                let m := mload(0x40)
-                // Copy the `ids`.
-                mstore(m, 0x40)
-                let n := add(0x20, shl(5, mload(ids)))
-                let o := add(m, 0x40)
-                copy(o, ids, n)
-                // Copy the `amounts`.
-                mstore(add(m, 0x20), add(0x40, n))
-                o := add(o, n)
-                n := add(0x20, shl(5, mload(amounts)))
-                copy(o, amounts, n)
-                n := sub(add(o, n), m)
-                // Do the emit.
-                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))
-            }
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(address(0), to, ids, amounts, data);
-        }
-        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  INTERNAL BURN FUNCTIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.
-    function _burn(address from, uint256 id, uint256 amount) internal virtual {
-        _burn(address(0), from, id, amount);
-    }
-
-    /// @dev Destroys `amount` of `id` from `from`.
-    ///
-    /// Requirements:
-    /// - `from` must have at least `amount` of `id`.
-    /// - If `by` is not the zero address, it must be either `from`,
-    ///   or approved to manage the tokens of `from`.
-    ///
-    /// Emits a {TransferSingle} event.
-    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), "");
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            let from_ := shl(96, from)
-            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))
-            // If `by` is not the zero address, and not equal to `from`,
-            // check if it is approved to manage all the tokens of `from`.
-            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {
-                mstore(0x00, by)
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Decrease and store the updated balance of `from`.
-            {
-                mstore(0x00, id)
-                let fromBalanceSlot := keccak256(0x00, 0x40)
-                let fromBalance := sload(fromBalanceSlot)
-                if gt(amount, fromBalance) {
-                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(fromBalanceSlot, sub(fromBalance, amount))
-            }
-            // Emit a {TransferSingle} event.
-            mstore(0x20, amount)
-            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, address(0), _single(id), _single(amount), "");
-        }
-    }
-
-    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.
-    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)
-        internal
-        virtual
-    {
-        _batchBurn(address(0), from, ids, amounts);
-    }
-
-    /// @dev Destroys `amounts` of `ids` from `from`.
-    ///
-    /// Requirements:
-    /// - `ids` and `amounts` must have the same length.
-    /// - `from` must have at least `amounts` of `ids`.
-    /// - If `by` is not the zero address, it must be either `from`,
-    ///   or approved to manage the tokens of `from`.
-    ///
-    /// Emits a {TransferBatch} event.
-    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)
-        internal
-        virtual
-    {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, address(0), ids, amounts, "");
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            if iszero(eq(mload(ids), mload(amounts))) {
-                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.
-                revert(0x1c, 0x04)
-            }
-            let from_ := shl(96, from)
-            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))
-            // If `by` is not the zero address, and not equal to `from`,
-            // check if it is approved to manage all the tokens of `from`.
-            let by_ := shl(96, by)
-            if iszero(or(iszero(by_), eq(by_, from_))) {
-                mstore(0x00, by)
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Loop through all the `ids` and update the balances.
-            {
-                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {
-                    let amount := mload(add(amounts, i))
-                    // Decrease and store the updated balance of `from`.
-                    {
-                        mstore(0x00, mload(add(ids, i)))
-                        let fromBalanceSlot := keccak256(0x00, 0x40)
-                        let fromBalance := sload(fromBalanceSlot)
-                        if gt(amount, fromBalance) {
-                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(fromBalanceSlot, sub(fromBalance, amount))
-                    }
-                }
-            }
-            // Emit a {TransferBatch} event.
-            {
-                let m := mload(0x40)
-                // Copy the `ids`.
-                mstore(m, 0x40)
-                let n := add(0x20, shl(5, mload(ids)))
-                let o := add(m, 0x40)
-                copy(o, ids, n)
-                // Copy the `amounts`.
-                mstore(add(m, 0x20), add(0x40, n))
-                o := add(o, n)
-                n := add(0x20, shl(5, mload(amounts)))
-                copy(o, amounts, n)
-                n := sub(add(o, n), m)
-                // Do the emit.
-                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)
-            }
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, address(0), ids, amounts, "");
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                INTERNAL APPROVAL FUNCTIONS                 */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Approve or remove the `operator` as an operator for `by`,
-    /// without authorization checks.
-    ///
-    /// Emits a {ApprovalForAll} event.
-    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Convert to 0 or 1.
-            isApproved := iszero(iszero(isApproved))
-            // Update the `isApproved` for (`by`, `operator`).
-            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)
-            mstore(0x14, by)
-            mstore(0x00, operator)
-            sstore(keccak256(0x0c, 0x34), isApproved)
-            // Emit the {ApprovalForAll} event.
-            mstore(0x00, isApproved)
-            let m := shr(96, not(0))
-            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                INTERNAL TRANSFER FUNCTIONS                 */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.
-    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)
-        internal
-        virtual
-    {
-        _safeTransfer(address(0), from, to, id, amount, data);
-    }
-
-    /// @dev Transfers `amount` of `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - `from` must have at least `amount` of `id`.
-    /// - If `by` is not the zero address, it must be either `from`,
-    ///   or approved to manage the tokens of `from`.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155Received}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferSingle} event.
-    function _safeTransfer(
-        address by,
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes memory data
-    ) internal virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            let from_ := shl(96, from)
-            let to_ := shl(96, to)
-            // Revert if `to` is the zero address.
-            if iszero(to_) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))
-            // If `by` is not the zero address, and not equal to `from`,
-            // check if it is approved to manage all the tokens of `from`.
-            let by_ := shl(96, by)
-            if iszero(or(iszero(by_), eq(by_, from_))) {
-                mstore(0x00, by)
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Subtract and store the updated balance of `from`.
-            {
-                mstore(0x00, id)
-                let fromBalanceSlot := keccak256(0x00, 0x40)
-                let fromBalance := sload(fromBalanceSlot)
-                if gt(amount, fromBalance) {
-                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(fromBalanceSlot, sub(fromBalance, amount))
-            }
-            // Increase and store the updated balance of `to`.
-            {
-                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))
-                let toBalanceSlot := keccak256(0x00, 0x40)
-                let toBalanceBefore := sload(toBalanceSlot)
-                let toBalanceAfter := add(toBalanceBefore, amount)
-                if lt(toBalanceAfter, toBalanceBefore) {
-                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                    revert(0x1c, 0x04)
-                }
-                sstore(toBalanceSlot, toBalanceAfter)
-            }
-            // Emit a {TransferSingle} event.
-            mstore(0x20, amount)
-            // forgefmt: disable-next-line
-            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, to, _single(id), _single(amount), data);
-        }
-        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);
-    }
-
-    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.
-    function _safeBatchTransfer(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {
-        _safeBatchTransfer(address(0), from, to, ids, amounts, data);
-    }
-
-    /// @dev Transfers `amounts` of `ids` from `from` to `to`.
-    ///
-    /// Requirements:
-    /// - `to` cannot be the zero address.
-    /// - `ids` and `amounts` must have the same length.
-    /// - `from` must have at least `amounts` of `ids`.
-    /// - If `by` is not the zero address, it must be either `from`,
-    ///   or approved to manage the tokens of `from`.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {ERC1155-onERC1155BatchReceived}, which is called upon a batch transfer.
-    ///
-    /// Emits a {TransferBatch} event.
-    function _safeBatchTransfer(
-        address by,
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {
-        if (_useBeforeTokenTransfer()) {
-            _beforeTokenTransfer(from, to, ids, amounts, data);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            if iszero(eq(mload(ids), mload(amounts))) {
-                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.
-                revert(0x1c, 0x04)
-            }
-            let from_ := shl(96, from)
-            let to_ := shl(96, to)
-            // Revert if `to` is the zero address.
-            if iszero(to_) {
-                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)
-            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)
-            mstore(0x20, fromSlotSeed)
-            // If `by` is not the zero address, and not equal to `from`,
-            // check if it is approved to manage all the tokens of `from`.
-            let by_ := shl(96, by)
-            if iszero(or(iszero(by_), eq(by_, from_))) {
-                mstore(0x00, by)
-                if iszero(sload(keccak256(0x0c, 0x34))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Loop through all the `ids` and update the balances.
-            {
-                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {
-                    let amount := mload(add(amounts, i))
-                    // Subtract and store the updated balance of `from`.
-                    {
-                        mstore(0x20, fromSlotSeed)
-                        mstore(0x00, mload(add(ids, i)))
-                        let fromBalanceSlot := keccak256(0x00, 0x40)
-                        let fromBalance := sload(fromBalanceSlot)
-                        if gt(amount, fromBalance) {
-                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(fromBalanceSlot, sub(fromBalance, amount))
-                    }
-                    // Increase and store the updated balance of `to`.
-                    {
-                        mstore(0x20, toSlotSeed)
-                        let toBalanceSlot := keccak256(0x00, 0x40)
-                        let toBalanceBefore := sload(toBalanceSlot)
-                        let toBalanceAfter := add(toBalanceBefore, amount)
-                        if lt(toBalanceAfter, toBalanceBefore) {
-                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.
-                            revert(0x1c, 0x04)
-                        }
-                        sstore(toBalanceSlot, toBalanceAfter)
-                    }
-                }
-            }
-            // Emit a {TransferBatch} event.
-            {
-                let m := mload(0x40)
-                // Copy the `ids`.
-                mstore(m, 0x40)
-                let n := add(0x20, shl(5, mload(ids)))
-                let o := add(m, 0x40)
-                copy(o, ids, n)
-                // Copy the `amounts`.
-                mstore(add(m, 0x20), add(0x40, n))
-                o := add(o, n)
-                n := add(0x20, shl(5, mload(amounts)))
-                copy(o, amounts, n)
-                n := sub(add(o, n), m)
-                // Do the emit.
-                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))
-            }
-        }
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, to, ids, amounts, data);
-        }
-        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                    HOOKS FOR OVERRIDING                    */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.
-    /// This is to help the compiler avoid producing dead bytecode.
-    function _useBeforeTokenTransfer() internal view virtual returns (bool) {
-        return false;
-    }
-
-    /// @dev Hook that is called before any token transfer.
-    /// This includes minting and burning, as well as batched variants.
-    ///
-    /// The same hook is called on both single and batched variants.
-    /// For single transfers, the length of the `id` and `amount` arrays are 1.
-    function _beforeTokenTransfer(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {}
-
-    /// @dev Override this function to return true if `_afterTokenTransfer` is used.
-    /// This is to help the compiler avoid producing dead bytecode.
-    function _useAfterTokenTransfer() internal view virtual returns (bool) {
-        return false;
-    }
-
-    /// @dev Hook that is called after any token transfer.
-    /// This includes minting and burning, as well as batched variants.
-    ///
-    /// The same hook is called on both single and batched variants.
-    /// For single transfers, the length of the `id` and `amount` arrays are 1.
-    function _afterTokenTransfer(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {}
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Helper for calling the `_afterTokenTransfer` hook.
-    /// This is to help the compiler avoid producing dead bytecode.
-    function _afterTokenTransferCalldata(
-        address from,
-        address to,
-        uint256[] calldata ids,
-        uint256[] calldata amounts,
-        bytes calldata data
-    ) private {
-        if (_useAfterTokenTransfer()) {
-            _afterTokenTransfer(from, to, ids, amounts, data);
-        }
-    }
-
-    /// @dev Returns if `a` has bytecode of non-zero length.
-    function _hasCode(address a) private view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := extcodesize(a) // Can handle dirty upper bits.
-        }
-    }
-
-    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.
-    /// Reverts if the target does not support the function correctly.
-    function _checkOnERC1155Received(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes memory data
-    ) private {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            // Prepare the calldata.
-            let m := mload(0x40)
-            // `onERC1155Received(address,address,uint256,uint256,bytes)`.
-            mstore(m, 0xf23a6e61)
-            mstore(add(m, 0x20), caller())
-            mstore(add(m, 0x40), shr(96, shl(96, from)))
-            mstore(add(m, 0x60), id)
-            mstore(add(m, 0x80), amount)
-            mstore(add(m, 0xa0), 0xa0)
-            let n := mload(data)
-            mstore(add(m, 0xc0), n)
-            copy(add(m, 0xe0), add(data, 0x20), n)
-            // Revert if the call reverts.
-            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {
-                if returndatasize() {
-                    // Bubble up the revert if the call reverts.
-                    returndatacopy(m, 0x00, returndatasize())
-                    revert(m, returndatasize())
-                }
-            }
-            // Load the returndata and compare it with the function selector.
-            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {
-                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.
-    /// Reverts if the target does not support the function correctly.
-    function _checkOnERC1155BatchReceived(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) private {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            // Prepare the calldata.
-            let m := mload(0x40)
-            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.
-            mstore(m, 0xbc197c81)
-            mstore(add(m, 0x20), caller())
-            mstore(add(m, 0x40), shr(96, shl(96, from)))
-            // Copy the `ids`.
-            mstore(add(m, 0x60), 0xa0)
-            let n := add(0x20, shl(5, mload(ids)))
-            let o := add(m, 0xc0)
-            copy(o, ids, n)
-            // Copy the `amounts`.
-            let s := add(0xa0, n)
-            mstore(add(m, 0x80), s)
-            o := add(o, n)
-            n := add(0x20, shl(5, mload(amounts)))
-            copy(o, amounts, n)
-            // Copy the `data`.
-            mstore(add(m, 0xa0), add(s, n))
-            o := add(o, n)
-            n := add(0x20, mload(data))
-            copy(o, data, n)
-            n := sub(add(o, n), add(m, 0x1c))
-            // Revert if the call reverts.
-            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {
-                if returndatasize() {
-                    // Bubble up the revert if the call reverts.
-                    returndatacopy(m, 0x00, returndatasize())
-                    revert(m, returndatasize())
-                }
-            }
-            // Load the returndata and compare it with the function selector.
-            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {
-                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Returns `x` in an array with a single element.
-    function _single(uint256 x) private pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(0x40, add(result, 0x40))
-            mstore(result, 1)
-            mstore(add(result, 0x20), x)
-        }
-    }
-}
diff --git a/src/tokens/ext/zksync/ERC721.sol b/src/tokens/ext/zksync/ERC721.sol
deleted file mode 100644
index d736848..0000000
--- a/src/tokens/ext/zksync/ERC721.sol
+++ /dev/null
@@ -1,916 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice Simple ERC721 implementation with storage hitchhiking.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ext/zksync/ERC721.sol)
-/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
-/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)
-///
-/// @dev Note:
-/// - The ERC721 standard allows for self-approvals.
-///   For performance, this implementation WILL NOT revert for such actions.
-///   Please add any checks with overrides if desired.
-/// - For performance, methods are made payable where permitted by the ERC721 standard.
-///
-/// If you are overriding:
-/// - NEVER violate the ERC721 invariant:
-///   the balance of an owner MUST always be equal to their number of ownership slots.
-///   The transfer functions do not have an underflow guard for user token balances.
-/// - Make sure all variables written to storage are properly cleaned
-///   (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).
-/// - Check that the overridden function is actually used in the function you want to
-///   change the behavior of. Much of the code has been manually inlined for performance.
-abstract contract ERC721 {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev An account can hold up to 4294967295 tokens.
-    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Only the token owner or an approved account can manage the token.
-    error NotOwnerNorApproved();
-
-    /// @dev The token does not exist.
-    error TokenDoesNotExist();
-
-    /// @dev The token already exists.
-    error TokenAlreadyExists();
-
-    /// @dev Cannot query the balance for the zero address.
-    error BalanceQueryForZeroAddress();
-
-    /// @dev Cannot mint or transfer to the zero address.
-    error TransferToZeroAddress();
-
-    /// @dev The token must be owned by `from`.
-    error TransferFromIncorrectOwner();
-
-    /// @dev The recipient's balance has overflowed.
-    error AccountBalanceOverflow();
-
-    /// @dev Cannot safely transfer to a contract that does not implement
-    /// the ERC721Receiver interface.
-    error TransferToNonERC721ReceiverImplementer();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Emitted when token `id` is transferred from `from` to `to`.
-    event Transfer(address indexed from, address indexed to, uint256 indexed id);
-
-    /// @dev Emitted when `owner` enables `account` to manage the `id` token.
-    event Approval(address indexed owner, address indexed account, uint256 indexed id);
-
-    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.
-    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);
-
-    /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.
-    uint256 private constant _TRANSFER_EVENT_SIGNATURE =
-        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;
-
-    /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.
-    uint256 private constant _APPROVAL_EVENT_SIGNATURE =
-        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;
-
-    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.
-    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =
-        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ownership data slot of `id` is given by:
-    /// ```
-    ///     mstore(0x00, id)
-    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-    /// ```
-    /// Bits Layout:
-    /// - [0..159]   `addr`
-    /// - [160..255] `extraData`
-    ///
-    /// The approved address slot is given by: `add(1, ownershipSlot)`.
-    ///
-    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip
-    ///
-    /// The balance slot of `owner` is given by:
-    /// ```
-    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-    ///     mstore(0x00, owner)
-    ///     let balanceSlot := keccak256(0x0c, 0x1c)
-    /// ```
-    /// Bits Layout:
-    /// - [0..31]   `balance`
-    /// - [32..255] `aux`
-    ///
-    /// The `operator` approval slot of `owner` is given by:
-    /// ```
-    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))
-    ///     mstore(0x00, owner)
-    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)
-    /// ```
-    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;
-
-    /// @dev Pre-shifted and pre-masked constant.
-    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      ERC721 METADATA                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the token collection name.
-    function name() public view virtual returns (string memory);
-
-    /// @dev Returns the token collection symbol.
-    function symbol() public view virtual returns (string memory);
-
-    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.
-    function tokenURI(uint256 id) public view virtual returns (string memory);
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           ERC721                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the owner of token `id`.
-    ///
-    /// Requirements:
-    /// - Token `id` must exist.
-    function ownerOf(uint256 id) public view virtual returns (address result) {
-        result = _ownerOf(id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(result) {
-                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Returns the number of tokens owned by `owner`.
-    ///
-    /// Requirements:
-    /// - `owner` must not be the zero address.
-    function balanceOf(address owner) public view virtual returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Revert if the `owner` is the zero address.
-            if iszero(owner) {
-                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            mstore(0x00, owner)
-            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)
-        }
-    }
-
-    /// @dev Returns the account approved to manage token `id`.
-    ///
-    /// Requirements:
-    /// - Token `id` must exist.
-    function getApproved(uint256 id) public view virtual returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            if iszero(shl(96, sload(ownershipSlot))) {
-                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.
-                revert(0x1c, 0x04)
-            }
-            result := sload(add(1, ownershipSlot))
-        }
-    }
-
-    /// @dev Sets `account` as the approved account to manage token `id`.
-    ///
-    /// Requirements:
-    /// - Token `id` must exist.
-    /// - The caller must be the owner of the token,
-    ///   or an approved operator for the token owner.
-    ///
-    /// Emits an {Approval} event.
-    function approve(address account, uint256 id) public payable virtual {
-        _approve(msg.sender, account, id);
-    }
-
-    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.
-    function isApprovedForAll(address owner, address operator)
-        public
-        view
-        virtual
-        returns (bool result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x1c, operator)
-            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)
-            mstore(0x00, owner)
-            result := sload(keccak256(0x0c, 0x30))
-        }
-    }
-
-    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.
-    ///
-    /// Emits an {ApprovalForAll} event.
-    function setApprovalForAll(address operator, bool isApproved) public virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Convert to 0 or 1.
-            isApproved := iszero(iszero(isApproved))
-            // Update the `isApproved` for (`msg.sender`, `operator`).
-            mstore(0x1c, operator)
-            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)
-            mstore(0x00, caller())
-            sstore(keccak256(0x0c, 0x30), isApproved)
-            // Emit the {ApprovalForAll} event.
-            mstore(0x00, isApproved)
-            // forgefmt: disable-next-item
-            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))
-        }
-    }
-
-    /// @dev Transfers token `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - `from` must be the owner of the token.
-    /// - `to` cannot be the zero address.
-    /// - The caller must be the owner of the token, or be approved to manage the token.
-    ///
-    /// Emits a {Transfer} event.
-    function transferFrom(address from, address to, uint256 id) public payable virtual {
-        _beforeTokenTransfer(from, to, id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            let bitmaskAddress := shr(96, not(0))
-            from := and(bitmaskAddress, from)
-            to := and(bitmaskAddress, to)
-            // Load the ownership data.
-            mstore(0x00, id)
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let ownershipPacked := sload(ownershipSlot)
-            let owner := and(bitmaskAddress, ownershipPacked)
-            // Revert if the token does not exist, or if `from` is not the owner.
-            if iszero(mul(owner, eq(owner, from))) {
-                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.
-                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)
-                revert(0x1c, 0x04)
-            }
-            // Load, check, and update the token approval.
-            {
-                mstore(0x00, from)
-                let approvedAddress := sload(add(1, ownershipSlot))
-                // Revert if the caller is not the owner, nor approved.
-                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {
-                    if iszero(sload(keccak256(0x0c, 0x30))) {
-                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                        revert(0x1c, 0x04)
-                    }
-                }
-                // Delete the approved address if any.
-                if approvedAddress { sstore(add(1, ownershipSlot), 0) }
-            }
-            // Update with the new owner.
-            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))
-            // Decrement the balance of `from`.
-            {
-                let fromBalanceSlot := keccak256(0x0c, 0x1c)
-                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))
-            }
-            // Increment the balance of `to`.
-            {
-                mstore(0x00, to)
-                let toBalanceSlot := keccak256(0x0c, 0x1c)
-                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)
-                // Revert if `to` is the zero address, or if the account balance overflows.
-                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {
-                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.
-                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)
-                    revert(0x1c, 0x04)
-                }
-                sstore(toBalanceSlot, toBalanceSlotPacked)
-            }
-            // Emit the {Transfer} event.
-            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)
-        }
-        _afterTokenTransfer(from, to, id);
-    }
-
-    /// @dev Equivalent to `safeTransferFrom(from, to, id, "")`.
-    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {
-        transferFrom(from, to, id);
-        if (_hasCode(to)) _checkOnERC721Received(from, to, id, "");
-    }
-
-    /// @dev Transfers token `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - `from` must be the owner of the token.
-    /// - `to` cannot be the zero address.
-    /// - The caller must be the owner of the token, or be approved to manage the token.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
-    ///
-    /// Emits a {Transfer} event.
-    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)
-        public
-        payable
-        virtual
-    {
-        transferFrom(from, to, id);
-        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);
-    }
-
-    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.
-    /// See: https://eips.ethereum.org/EIPS/eip-165
-    /// This function call must use less than 30000 gas.
-    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let s := shr(224, interfaceId)
-            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.
-            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  INTERNAL QUERY FUNCTIONS                  */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns if token `id` exists.
-    function _exists(uint256 id) internal view virtual returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))
-        }
-    }
-
-    /// @dev Returns the owner of token `id`.
-    /// Returns the zero address instead of reverting if the token does not exist.
-    function _ownerOf(uint256 id) internal view virtual returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // For performance, no events are emitted for the hitchhiking setters.
-    // Please emit your own events if required.
-
-    /// @dev Returns the auxiliary data for `owner`.
-    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.
-    /// Auxiliary data can be set for any address, even if it does not have any tokens.
-    function _getAux(address owner) internal view virtual returns (uint224 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            mstore(0x00, owner)
-            result := shr(32, sload(keccak256(0x0c, 0x1c)))
-        }
-    }
-
-    /// @dev Set the auxiliary data for `owner` to `value`.
-    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.
-    /// Auxiliary data can be set for any address, even if it does not have any tokens.
-    function _setAux(address owner, uint224 value) internal virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            mstore(0x00, owner)
-            let balanceSlot := keccak256(0x0c, 0x1c)
-            let packed := sload(balanceSlot)
-            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))
-        }
-    }
-
-    /// @dev Returns the extra data for token `id`.
-    /// Minting, transferring, burning a token will not change the extra data.
-    /// The extra data can be set on a non-existent token.
-    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))
-        }
-    }
-
-    /// @dev Sets the extra data for token `id` to `value`.
-    /// Minting, transferring, burning a token will not change the extra data.
-    /// The extra data can be set on a non-existent token.
-    function _setExtraData(uint256 id, uint96 value) internal virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let packed := sload(ownershipSlot)
-            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  INTERNAL MINT FUNCTIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Mints token `id` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must not exist.
-    /// - `to` cannot be the zero address.
-    ///
-    /// Emits a {Transfer} event.
-    function _mint(address to, uint256 id) internal virtual {
-        _beforeTokenTransfer(address(0), to, id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            to := shr(96, shl(96, to))
-            // Load the ownership data.
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let ownershipPacked := sload(ownershipSlot)
-            // Revert if the token already exists.
-            if shl(96, ownershipPacked) {
-                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.
-                revert(0x1c, 0x04)
-            }
-            // Update with the owner.
-            sstore(ownershipSlot, or(ownershipPacked, to))
-            // Increment the balance of the owner.
-            {
-                mstore(0x00, to)
-                let balanceSlot := keccak256(0x0c, 0x1c)
-                let balanceSlotPacked := add(sload(balanceSlot), 1)
-                // Revert if `to` is the zero address, or if the account balance overflows.
-                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {
-                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.
-                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)
-                    revert(0x1c, 0x04)
-                }
-                sstore(balanceSlot, balanceSlotPacked)
-            }
-            // Emit the {Transfer} event.
-            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)
-        }
-        _afterTokenTransfer(address(0), to, id);
-    }
-
-    /// @dev Mints token `id` to `to`, and updates the extra data for token `id` to `value`.
-    /// Does NOT check if token `id` already exists (assumes `id` is auto-incrementing).
-    ///
-    /// Requirements:
-    ///
-    /// - `to` cannot be the zero address.
-    ///
-    /// Emits a {Transfer} event.
-    function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {
-        _beforeTokenTransfer(address(0), to, id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            to := shr(96, shl(96, to))
-            // Update with the owner and extra data.
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))
-            // Increment the balance of the owner.
-            {
-                mstore(0x00, to)
-                let balanceSlot := keccak256(0x0c, 0x1c)
-                let balanceSlotPacked := add(sload(balanceSlot), 1)
-                // Revert if `to` is the zero address, or if the account balance overflows.
-                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {
-                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.
-                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)
-                    revert(0x1c, 0x04)
-                }
-                sstore(balanceSlot, balanceSlotPacked)
-            }
-            // Emit the {Transfer} event.
-            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)
-        }
-        _afterTokenTransfer(address(0), to, id);
-    }
-
-    /// @dev Equivalent to `_safeMint(to, id, "")`.
-    function _safeMint(address to, uint256 id) internal virtual {
-        _safeMint(to, id, "");
-    }
-
-    /// @dev Mints token `id` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must not exist.
-    /// - `to` cannot be the zero address.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
-    ///
-    /// Emits a {Transfer} event.
-    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
-        _mint(to, id);
-        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  INTERNAL BURN FUNCTIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Equivalent to `_burn(address(0), id)`.
-    function _burn(uint256 id) internal virtual {
-        _burn(address(0), id);
-    }
-
-    /// @dev Destroys token `id`, using `by`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - If `by` is not the zero address,
-    ///   it must be the owner of the token, or be approved to manage the token.
-    ///
-    /// Emits a {Transfer} event.
-    function _burn(address by, uint256 id) internal virtual {
-        address owner = ownerOf(id);
-        _beforeTokenTransfer(owner, address(0), id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            by := shr(96, shl(96, by))
-            // Load the ownership data.
-            mstore(0x00, id)
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let ownershipPacked := sload(ownershipSlot)
-            // Reload the owner in case it is changed in `_beforeTokenTransfer`.
-            owner := shr(96, shl(96, ownershipPacked))
-            // Revert if the token does not exist.
-            if iszero(owner) {
-                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.
-                revert(0x1c, 0x04)
-            }
-            // Load and check the token approval.
-            {
-                mstore(0x00, owner)
-                let approvedAddress := sload(add(1, ownershipSlot))
-                // If `by` is not the zero address, do the authorization check.
-                // Revert if the `by` is not the owner, nor approved.
-                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {
-                    if iszero(sload(keccak256(0x0c, 0x30))) {
-                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                        revert(0x1c, 0x04)
-                    }
-                }
-                // Delete the approved address if any.
-                if approvedAddress { sstore(add(1, ownershipSlot), 0) }
-            }
-            // Clear the owner.
-            sstore(ownershipSlot, xor(ownershipPacked, owner))
-            // Decrement the balance of `owner`.
-            {
-                let balanceSlot := keccak256(0x0c, 0x1c)
-                sstore(balanceSlot, sub(sload(balanceSlot), 1))
-            }
-            // Emit the {Transfer} event.
-            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)
-        }
-        _afterTokenTransfer(owner, address(0), id);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                INTERNAL APPROVAL FUNCTIONS                 */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns whether `account` is the owner of token `id`, or is approved to manage it.
-    ///
-    /// Requirements:
-    /// - Token `id` must exist.
-    function _isApprovedOrOwner(address account, uint256 id)
-        internal
-        view
-        virtual
-        returns (bool result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := 1
-            // Clear the upper 96 bits.
-            account := shr(96, shl(96, account))
-            // Load the ownership data.
-            mstore(0x00, id)
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let owner := shr(96, shl(96, sload(ownershipSlot)))
-            // Revert if the token does not exist.
-            if iszero(owner) {
-                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.
-                revert(0x1c, 0x04)
-            }
-            // Check if `account` is the `owner`.
-            if iszero(eq(account, owner)) {
-                mstore(0x00, owner)
-                // Check if `account` is approved to manage the token.
-                if iszero(sload(keccak256(0x0c, 0x30))) {
-                    result := eq(account, sload(add(1, ownershipSlot)))
-                }
-            }
-        }
-    }
-
-    /// @dev Returns the account approved to manage token `id`.
-    /// Returns the zero address instead of reverting if the token does not exist.
-    function _getApproved(uint256 id) internal view virtual returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))
-        }
-    }
-
-    /// @dev Equivalent to `_approve(address(0), account, id)`.
-    function _approve(address account, uint256 id) internal virtual {
-        _approve(address(0), account, id);
-    }
-
-    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.
-    ///
-    /// Requirements:
-    /// - Token `id` must exist.
-    /// - If `by` is not the zero address, `by` must be the owner
-    ///   or an approved operator for the token owner.
-    ///
-    /// Emits a {Approval} event.
-    function _approve(address by, address account, uint256 id) internal virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            let bitmaskAddress := shr(96, not(0))
-            account := and(bitmaskAddress, account)
-            by := and(bitmaskAddress, by)
-            // Load the owner of the token.
-            mstore(0x00, id)
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let owner := and(bitmaskAddress, sload(ownershipSlot))
-            // Revert if the token does not exist.
-            if iszero(owner) {
-                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.
-                revert(0x1c, 0x04)
-            }
-            // If `by` is not the zero address, do the authorization check.
-            // Revert if `by` is not the owner, nor approved.
-            if iszero(or(iszero(by), eq(by, owner))) {
-                mstore(0x00, owner)
-                if iszero(sload(keccak256(0x0c, 0x30))) {
-                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            // Sets `account` as the approved account to manage `id`.
-            sstore(add(1, ownershipSlot), account)
-            // Emit the {Approval} event.
-            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)
-        }
-    }
-
-    /// @dev Approve or remove the `operator` as an operator for `by`,
-    /// without authorization checks.
-    ///
-    /// Emits an {ApprovalForAll} event.
-    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            by := shr(96, shl(96, by))
-            operator := shr(96, shl(96, operator))
-            // Convert to 0 or 1.
-            isApproved := iszero(iszero(isApproved))
-            // Update the `isApproved` for (`by`, `operator`).
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))
-            mstore(0x00, by)
-            sstore(keccak256(0x0c, 0x30), isApproved)
-            // Emit the {ApprovalForAll} event.
-            mstore(0x00, isApproved)
-            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                INTERNAL TRANSFER FUNCTIONS                 */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.
-    function _transfer(address from, address to, uint256 id) internal virtual {
-        _transfer(address(0), from, to, id);
-    }
-
-    /// @dev Transfers token `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - `from` must be the owner of the token.
-    /// - `to` cannot be the zero address.
-    /// - If `by` is not the zero address,
-    ///   it must be the owner of the token, or be approved to manage the token.
-    ///
-    /// Emits a {Transfer} event.
-    function _transfer(address by, address from, address to, uint256 id) internal virtual {
-        _beforeTokenTransfer(from, to, id);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clear the upper 96 bits.
-            let bitmaskAddress := shr(96, not(0))
-            from := and(bitmaskAddress, from)
-            to := and(bitmaskAddress, to)
-            by := and(bitmaskAddress, by)
-            // Load the ownership data.
-            mstore(0x00, id)
-            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))
-            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))
-            let ownershipPacked := sload(ownershipSlot)
-            let owner := and(bitmaskAddress, ownershipPacked)
-            // Revert if the token does not exist, or if `from` is not the owner.
-            if iszero(mul(owner, eq(owner, from))) {
-                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.
-                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)
-                revert(0x1c, 0x04)
-            }
-            // Load, check, and update the token approval.
-            {
-                mstore(0x00, from)
-                let approvedAddress := sload(add(1, ownershipSlot))
-                // If `by` is not the zero address, do the authorization check.
-                // Revert if the `by` is not the owner, nor approved.
-                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {
-                    if iszero(sload(keccak256(0x0c, 0x30))) {
-                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.
-                        revert(0x1c, 0x04)
-                    }
-                }
-                // Delete the approved address if any.
-                if approvedAddress { sstore(add(1, ownershipSlot), 0) }
-            }
-            // Update with the new owner.
-            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))
-            // Decrement the balance of `from`.
-            {
-                let fromBalanceSlot := keccak256(0x0c, 0x1c)
-                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))
-            }
-            // Increment the balance of `to`.
-            {
-                mstore(0x00, to)
-                let toBalanceSlot := keccak256(0x0c, 0x1c)
-                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)
-                // Revert if `to` is the zero address, or if the account balance overflows.
-                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {
-                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.
-                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)
-                    revert(0x1c, 0x04)
-                }
-                sstore(toBalanceSlot, toBalanceSlotPacked)
-            }
-            // Emit the {Transfer} event.
-            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)
-        }
-        _afterTokenTransfer(from, to, id);
-    }
-
-    /// @dev Equivalent to `_safeTransfer(from, to, id, "")`.
-    function _safeTransfer(address from, address to, uint256 id) internal virtual {
-        _safeTransfer(from, to, id, "");
-    }
-
-    /// @dev Transfers token `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - `from` must be the owner of the token.
-    /// - `to` cannot be the zero address.
-    /// - The caller must be the owner of the token, or be approved to manage the token.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
-    ///
-    /// Emits a {Transfer} event.
-    function _safeTransfer(address from, address to, uint256 id, bytes memory data)
-        internal
-        virtual
-    {
-        _transfer(address(0), from, to, id);
-        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);
-    }
-
-    /// @dev Equivalent to `_safeTransfer(by, from, to, id, "")`.
-    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {
-        _safeTransfer(by, from, to, id, "");
-    }
-
-    /// @dev Transfers token `id` from `from` to `to`.
-    ///
-    /// Requirements:
-    ///
-    /// - Token `id` must exist.
-    /// - `from` must be the owner of the token.
-    /// - `to` cannot be the zero address.
-    /// - If `by` is not the zero address,
-    ///   it must be the owner of the token, or be approved to manage the token.
-    /// - If `to` refers to a smart contract, it must implement
-    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
-    ///
-    /// Emits a {Transfer} event.
-    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)
-        internal
-        virtual
-    {
-        _transfer(by, from, to, id);
-        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                    HOOKS FOR OVERRIDING                    */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Hook that is called before any token transfers, including minting and burning.
-    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}
-
-    /// @dev Hook that is called after any token transfers, including minting and burning.
-    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns if `a` has bytecode of non-zero length.
-    function _hasCode(address a) private view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := extcodesize(a) // Can handle dirty upper bits.
-        }
-    }
-
-    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.
-    /// Reverts if the target does not support the function correctly.
-    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)
-        private
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            // Prepare the calldata.
-            let m := mload(0x40)
-            let onERC721ReceivedSelector := 0x150b7a02
-            mstore(m, onERC721ReceivedSelector)
-            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.
-            mstore(add(m, 0x40), shr(96, shl(96, from)))
-            mstore(add(m, 0x60), id)
-            mstore(add(m, 0x80), 0x80)
-            let n := mload(data)
-            mstore(add(m, 0xa0), n)
-            copy(add(m, 0xc0), add(data, 0x20), n)
-            // Revert if the call reverts.
-            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {
-                if returndatasize() {
-                    // Bubble up the revert if the call reverts.
-                    returndatacopy(m, 0x00, returndatasize())
-                    revert(m, returndatasize())
-                }
-            }
-            // Load the returndata and compare it.
-            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {
-                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-}
diff --git a/src/utils/LibTransient.sol b/src/utils/LibTransient.sol
deleted file mode 100644
index b7151a4..0000000
--- a/src/utils/LibTransient.sol
+++ /dev/null
@@ -1,963 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice Library for transient storage operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibTransient.sol)
-/// @author Modified from Transient Goodies by Philogy (https://github.com/Philogy/transient-goodies/blob/main/src/TransientBytesLib.sol)
-///
-/// @dev Note: The functions postfixed with `Compat` will only use transient storage on L1.
-/// L2s are super cheap anyway.
-/// For best safety, always clear the storage after use.
-library LibTransient {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STRUCTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Pointer struct to a `uint256` in transient storage.
-    struct TUint256 {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a `int256` in transient storage.
-    struct TInt256 {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a `bytes32` in transient storage.
-    struct TBytes32 {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a `address` in transient storage.
-    struct TAddress {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a `bool` in transient storage.
-    struct TBool {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a `bytes` in transient storage.
-    struct TBytes {
-        uint256 _spacer;
-    }
-
-    /// @dev Pointer struct to a stack pointer generator in transient storage.
-    /// This stack does not directly take in values. Instead, it generates pointers
-    /// that can be casted to any of the other transient storage pointer struct.
-    struct TStack {
-        uint256 _spacer;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The transient stack is empty.
-    error StackIsEmpty();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The storage slot seed for converting a transient slot to a storage slot.
-    /// `bytes4(keccak256("_LIB_TRANSIENT_COMPAT_SLOT_SEED"))`.
-    uint256 private constant _LIB_TRANSIENT_COMPAT_SLOT_SEED = 0x5a0b45f2;
-
-    /// @dev Multiplier to stack base slot, so that in the case where two stacks
-    /// share consecutive base slots, their pointers will likely not overlap. A prime.
-    uint256 private constant _STACK_BASE_SALT = 0x9e076501211e1371b;
-
-    /// @dev The canonical address of the transient registry.
-    /// See: https://gist.github.com/Vectorized/4ab665d7a234ef5aaaff2e5091ec261f
-    address internal constant REGISTRY = 0x000000000000297f64C7F8d9595e43257908F170;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     UINT256 OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `uint256` in transient storage.
-    function tUint256(bytes32 tSlot) internal pure returns (TUint256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `uint256` in transient storage.
-    function tUint256(uint256 tSlot) internal pure returns (TUint256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TUint256 storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TUint256 storage ptr) internal view returns (uint256 result) {
-        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer;
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TUint256 storage ptr, uint256 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TUint256 storage ptr, uint256 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = value;
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TUint256 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TUint256 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function inc(TUint256 storage ptr) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function incCompat(TUint256 storage ptr) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function inc(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) + delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function dec(TUint256 storage ptr) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TUint256 storage ptr) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function dec(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) - delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := tload(ptr.slot)
-            newValue := add(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            tstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incSignedCompat(TUint256 storage ptr, int256 delta)
-        internal
-        returns (uint256 newValue)
-    {
-        if (block.chainid == 1) return incSigned(ptr, delta);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := sload(ptr.slot)
-            newValue := add(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            sstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := tload(ptr.slot)
-            newValue := sub(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            tstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decSignedCompat(TUint256 storage ptr, int256 delta)
-        internal
-        returns (uint256 newValue)
-    {
-        if (block.chainid == 1) return decSigned(ptr, delta);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := sload(ptr.slot)
-            newValue := sub(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            sstore(ptr.slot, newValue)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     INT256 OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `int256` in transient storage.
-    function tInt256(bytes32 tSlot) internal pure returns (TInt256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `int256` in transient storage.
-    function tInt256(uint256 tSlot) internal pure returns (TInt256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TInt256 storage ptr) internal view returns (int256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TInt256 storage ptr) internal view returns (int256 result) {
-        result = block.chainid == 1 ? get(ptr) : int256(_compat(ptr)._spacer);
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TInt256 storage ptr, int256 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TInt256 storage ptr, int256 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint256(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TInt256 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TInt256 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function inc(TInt256 storage ptr) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function incCompat(TInt256 storage ptr) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function inc(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) + delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function dec(TInt256 storage ptr) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function decCompat(TInt256 storage ptr) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function dec(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) - delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - delta);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     BYTES32 OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bytes32` in transient storage.
-    function tBytes32(bytes32 tSlot) internal pure returns (TBytes32 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bytes32` in transient storage.
-    function tBytes32(uint256 tSlot) internal pure returns (TBytes32 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TBytes32 storage ptr) internal view returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TBytes32 storage ptr) internal view returns (bytes32 result) {
-        result = block.chainid == 1 ? get(ptr) : bytes32(_compat(ptr)._spacer);
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBytes32 storage ptr, bytes32 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBytes32 storage ptr, bytes32 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint256(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBytes32 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBytes32 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     ADDRESS OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `address` in transient storage.
-    function tAddress(bytes32 tSlot) internal pure returns (TAddress storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `address` in transient storage.
-    function tAddress(uint256 tSlot) internal pure returns (TAddress storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TAddress storage ptr) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TAddress storage ptr) internal view returns (address result) {
-        result = block.chainid == 1 ? get(ptr) : address(uint160(_compat(ptr)._spacer));
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TAddress storage ptr, address value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, shr(96, shl(96, value)))
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TAddress storage ptr, address value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint160(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TAddress storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TAddress storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      BOOL OPERATIONS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bool` in transient storage.
-    function tBool(bytes32 tSlot) internal pure returns (TBool storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bool` in transient storage.
-    function tBool(uint256 tSlot) internal pure returns (TBool storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TBool storage ptr) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TBool storage ptr) internal view returns (bool result) {
-        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer != 0;
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBool storage ptr, bool value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, iszero(iszero(value)))
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBool storage ptr, bool value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, iszero(iszero(value)))
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBool storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBool storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      BYTES OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bytes` in transient storage.
-    function tBytes(bytes32 tSlot) internal pure returns (TBytes storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bytes` in transient storage.
-    function tBytes(uint256 tSlot) internal pure returns (TBytes storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the length of the bytes stored at transient `ptr`.
-    function length(TBytes storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(224, tload(ptr.slot))
-        }
-    }
-
-    /// @dev Returns the length of the bytes stored at transient `ptr`.
-    function lengthCompat(TBytes storage ptr) internal view returns (uint256 result) {
-        if (block.chainid == 1) return length(ptr);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(224, sload(ptr.slot))
-        }
-    }
-
-    /// @dev Returns the bytes stored at transient `ptr`.
-    function get(TBytes storage ptr) internal view returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 0x00)
-            mstore(add(result, 0x1c), tload(ptr.slot)) // Length and first `0x1c` bytes.
-            let n := mload(result)
-            let e := add(add(result, 0x20), n)
-            if iszero(lt(n, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let d := sub(keccak256(0x00, 0x20), result)
-                for { let o := add(result, 0x3c) } 1 {} {
-                    mstore(o, tload(add(o, d)))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-            mstore(e, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(0x20, e)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns the bytes stored at transient `ptr`.
-    function getCompat(TBytes storage ptr) internal view returns (bytes memory result) {
-        if (block.chainid == 1) return get(ptr);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 0x00)
-            mstore(add(result, 0x1c), sload(ptr.slot)) // Length and first `0x1c` bytes.
-            let n := mload(result)
-            let e := add(add(result, 0x20), n)
-            if iszero(lt(n, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let d := sub(keccak256(0x00, 0x20), result)
-                for { let o := add(result, 0x3c) } 1 {} {
-                    mstore(o, sload(add(o, d)))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-            mstore(e, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(0x20, e)) // Allocate memory.
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBytes storage ptr, bytes memory value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, mload(add(value, 0x1c)))
-            if iszero(lt(mload(value), 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(add(value, 0x20), mload(value))
-                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)
-                for { let o := add(value, 0x3c) } 1 {} {
-                    tstore(add(o, d), mload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBytes storage ptr, bytes memory value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, mload(add(value, 0x1c)))
-            if iszero(lt(mload(value), 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(add(value, 0x20), mload(value))
-                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)
-                for { let o := add(value, 0x3c) } 1 {} {
-                    sstore(add(o, d), mload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCalldata(TBytes storage ptr, bytes calldata value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))
-            if iszero(lt(value.length, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(value.offset, value.length)
-                // forgefmt: disable-next-item
-                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),
-                    value.offset), 0x20)
-                for { let o := add(value.offset, 0x1c) } 1 {} {
-                    tstore(add(o, d), calldataload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal {
-        if (block.chainid == 1) return setCalldata(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))
-            if iszero(lt(value.length, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(value.offset, value.length)
-                // forgefmt: disable-next-item
-                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),
-                    value.offset), 0x20)
-                for { let o := add(value.offset, 0x1c) } 1 {} {
-                    sstore(add(o, d), calldataload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBytes storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBytes storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      STACK OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a stack in transient storage.
-    function tStack(bytes32 tSlot) internal pure returns (TStack storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a stack in transient storage.
-    function tStack(uint256 tSlot) internal pure returns (TStack storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the number of elements in the stack.
-    function length(TStack storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(160, shl(128, tload(ptr.slot))) // Removes the base offset and stride.
-        }
-    }
-
-    /// @dev Clears the stack at `ptr`.
-    /// Note: Future usage of the stack will point to a fresh transient storage region.
-    function clear(TStack storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clears the length and increments the base pointer by `1 << 128`.
-            tstore(ptr.slot, shl(128, add(1, shr(128, tload(ptr.slot)))))
-        }
-    }
-
-    /// @dev Increments the stack length by 1, and returns a pointer to the top element.
-    /// We don't want to call this `push` as it does not take in an element value.
-    /// Note: The value pointed to might not be cleared from previous usage.
-    function place(TStack storage ptr) internal returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            topPtr := add(0x100000000, tload(ptr.slot)) // Increments by a stride.
-            tstore(ptr.slot, topPtr)
-            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)
-        }
-    }
-
-    /// @dev Returns a pointer to the top element. Returns the zero pointer if the stack is empty.
-    /// This method can help avoid an additional `TLOAD`, but you MUST check if the
-    /// returned pointer is zero. And if it is, please DO NOT read / write to it.
-    function peek(TStack storage ptr) internal view returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let t := tload(ptr.slot)
-            topPtr := mul(iszero(iszero(shl(128, t))), add(mul(_STACK_BASE_SALT, ptr.slot), t))
-        }
-    }
-
-    /// @dev Returns a pointer to the top element. Reverts if the stack is empty.
-    function top(TStack storage ptr) internal view returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            topPtr := tload(ptr.slot)
-            if iszero(topPtr) {
-                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)
-        }
-    }
-
-    /// @dev Decrements the stack length by 1, returns a pointer to the top element
-    /// before the popping. Reverts if the stack is empty.
-    /// Note: Popping from the stack does NOT auto-clear the top value.
-    function pop(TStack storage ptr) internal returns (bytes32 lastTopPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            lastTopPtr := tload(ptr.slot)
-            if iszero(lastTopPtr) {
-                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            tstore(ptr.slot, sub(lastTopPtr, 0x100000000)) // Decrements by a stride.
-            lastTopPtr := add(mul(_STACK_BASE_SALT, ptr.slot), lastTopPtr)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*               TRANSIENT REGISTRY OPERATIONS                */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Sets the value for the key.
-    /// If the key does not exist, its admin will be set to the caller.
-    /// If the key already exist, its value will be overwritten,
-    /// and the caller must be the current admin for the key.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registrySet(bytes32 key, bytes memory value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(m, 0xaac438c0) // `set(bytes32,bytes)`.
-            mstore(add(m, 0x20), key)
-            mstore(add(m, 0x40), 0x40)
-            let n := mload(value)
-            mstore(add(m, 0x60), n)
-            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {
-                mstore(add(add(m, 0x80), i), mload(add(add(value, 0x20), i)))
-            }
-            if iszero(
-                mul(
-                    returndatasize(),
-                    call(gas(), REGISTRY, 0, add(m, 0x1c), add(n, 0x64), 0x00, 0x20)
-                )
-            ) { revert(0x00, returndatasize()) }
-        }
-    }
-
-    /// @dev Returns the value for the key.
-    /// Reverts if the key does not exist.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryGet(bytes32 key) internal view returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(0x00, 0x8eaa6ac0) // `get(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            // We can safely assume that the bytes will be containing the 0x20 offset.
-            returndatacopy(result, 0x20, sub(returndatasize(), 0x20))
-            mstore(0x40, add(result, returndatasize())) // Allocate memory.
-        }
-    }
-
-    /// @dev Clears the admin and the value for the key.
-    /// The caller must be the current admin of the key.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryClear(bytes32 key) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x97040a45) // `clear(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-        }
-    }
-
-    /// @dev Returns the admin of the key.
-    /// Returns `address(0)` if the key does not exist.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryAdminOf(bytes32 key) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0xc5344411) // `adminOf(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Changes the admin of the key.
-    /// The caller must be the current admin of the key.
-    /// The new admin must not be `address(0)`.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryChangeAdmin(bytes32 key, address newAdmin) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40) // Cache the free memory pointer.
-            mstore(0x00, 0x053b1ca3) // `changeAdmin(bytes32,address)`.
-            mstore(0x20, key)
-            mstore(0x40, shr(96, shl(96, newAdmin)))
-            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x44, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TUint256 storage ptr) private pure returns (TUint256 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TInt256 storage ptr) private pure returns (TInt256 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBytes32 storage ptr) private pure returns (TBytes32 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TAddress storage ptr) private pure returns (TAddress storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBool storage ptr) private pure returns (TBool storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBytes storage ptr) private pure returns (TBytes storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-}
diff --git a/src/utils/ReentrancyGuardTransient.sol b/src/utils/ReentrancyGuardTransient.sol
deleted file mode 100644
index 3192549..0000000
--- a/src/utils/ReentrancyGuardTransient.sol
+++ /dev/null
@@ -1,123 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-/// @notice Reentrancy guard mixin (transient storage variant).
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuardTransient.sol)
-///
-/// @dev Note: This implementation utilizes the `TSTORE` and `TLOAD` opcodes.
-/// Please ensure that the chain you are deploying on supports them.
-abstract contract ReentrancyGuardTransient {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Unauthorized reentrant call.
-    error Reentrancy();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Equivalent to: `uint32(bytes4(keccak256("Reentrancy()"))) | 1 << 71`.
-    /// 9 bytes is large enough to avoid collisions in practice,
-    /// but not too large to result in excessive bytecode bloat.
-    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x8000000000ab143c06;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      REENTRANCY GUARD                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Guards a function from reentrancy.
-    modifier nonReentrant() virtual {
-        if (_useTransientReentrancyGuardOnlyOnMainnet()) {
-            uint256 s = _REENTRANCY_GUARD_SLOT;
-            if (block.chainid == 1) {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    if tload(s) {
-                        mstore(0x00, s) // `Reentrancy()`.
-                        revert(0x1c, 0x04)
-                    }
-                    tstore(s, address())
-                }
-            } else {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    if eq(sload(s), address()) {
-                        mstore(0x00, s) // `Reentrancy()`.
-                        revert(0x1c, 0x04)
-                    }
-                    sstore(s, address())
-                }
-            }
-        } else {
-            /// @solidity memory-safe-assembly
-            assembly {
-                if tload(_REENTRANCY_GUARD_SLOT) {
-                    mstore(0x00, 0xab143c06) // `Reentrancy()`.
-                    revert(0x1c, 0x04)
-                }
-                tstore(_REENTRANCY_GUARD_SLOT, address())
-            }
-        }
-        _;
-        if (_useTransientReentrancyGuardOnlyOnMainnet()) {
-            uint256 s = _REENTRANCY_GUARD_SLOT;
-            if (block.chainid == 1) {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    tstore(s, 0)
-                }
-            } else {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    sstore(s, s)
-                }
-            }
-        } else {
-            /// @solidity memory-safe-assembly
-            assembly {
-                tstore(_REENTRANCY_GUARD_SLOT, 0)
-            }
-        }
-    }
-
-    /// @dev Guards a view function from read-only reentrancy.
-    modifier nonReadReentrant() virtual {
-        if (_useTransientReentrancyGuardOnlyOnMainnet()) {
-            uint256 s = _REENTRANCY_GUARD_SLOT;
-            if (block.chainid == 1) {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    if tload(s) {
-                        mstore(0x00, s) // `Reentrancy()`.
-                        revert(0x1c, 0x04)
-                    }
-                }
-            } else {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    if eq(sload(s), address()) {
-                        mstore(0x00, s) // `Reentrancy()`.
-                        revert(0x1c, 0x04)
-                    }
-                }
-            }
-        } else {
-            /// @solidity memory-safe-assembly
-            assembly {
-                if tload(_REENTRANCY_GUARD_SLOT) {
-                    mstore(0x00, 0xab143c06) // `Reentrancy()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-        }
-        _;
-    }
-
-    /// @dev For widespread compatibility with L2s.
-    /// Only Ethereum mainnet is expensive anyways.
-    function _useTransientReentrancyGuardOnlyOnMainnet() internal view virtual returns (bool) {
-        return true;
-    }
-}
diff --git a/src/utils/ext/ithaca/BLS.sol b/src/utils/ext/ithaca/BLS.sol
deleted file mode 100644
index 8c21ad9..0000000
--- a/src/utils/ext/ithaca/BLS.sol
+++ /dev/null
@@ -1,354 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-/// @notice BLS wrapper.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/BLS.sol)
-/// @author Ithaca (https://github.com/ithacaxyz/odyssey-examples/blob/main/chapter1/contracts/src/libraries/BLS.sol)
-///
-/// @dev Precompile addresses come from the BLS addresses submodule in AlphaNet, see
-/// See: (https://github.com/paradigmxyz/alphanet/blob/main/crates/precompile/src/addresses.rs)
-///
-/// Note:
-/// - This implementation uses `mcopy`, since any chain that is edgy enough to
-///   implement the BLS precompiles will definitely have implemented cancun.
-/// - For efficiency, we use the legacy `staticcall` to call the precompiles.
-///   For the intended use case in an entry points that requires gas-introspection,
-///   which requires legacy bytecode, this won't be a blocker.
-library BLS {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STRUCTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // We use flattened structs to make encoding more efficient.
-    // All structs use Big endian encoding.
-    // See: https://eips.ethereum.org/EIPS/eip-2537
-
-    /// @dev A representation of a base field element (Fp) in the BLS12-381 curve.
-    /// Due to the size of `p`,
-    /// `0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab`
-    /// the top 16 bytes are always zeroes.
-    struct Fp {
-        bytes32 a; // Upper 32 bytes.
-        bytes32 b; // Lower 32 bytes.
-    }
-
-    /// @dev A representation of an extension field element (Fp2) in the BLS12-381 curve.
-    struct Fp2 {
-        bytes32 c0_a;
-        bytes32 c0_b;
-        bytes32 c1_a;
-        bytes32 c1_b;
-    }
-
-    /// @dev A representation of a point on the G1 curve of BLS12-381.
-    struct G1Point {
-        bytes32 x_a;
-        bytes32 x_b;
-        bytes32 y_a;
-        bytes32 y_b;
-    }
-
-    /// @dev A representation of a point on the G2 curve of BLS12-381.
-    struct G2Point {
-        bytes32 x_c0_a;
-        bytes32 x_c0_b;
-        bytes32 x_c1_a;
-        bytes32 x_c1_b;
-        bytes32 y_c0_a;
-        bytes32 y_c0_b;
-        bytes32 y_c1_a;
-        bytes32 y_c1_b;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                    PRECOMPILE ADDRESSES                    */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev For addition of two points on the BLS12-381 G1 curve,
-    address internal constant BLS12_G1ADD = 0x000000000000000000000000000000000000000b;
-
-    /// @dev For multi-scalar multiplication (MSM) on the BLS12-381 G1 curve.
-    address internal constant BLS12_G1MSM = 0x000000000000000000000000000000000000000C;
-
-    /// @dev For addition of two points on the BLS12-381 G2 curve.
-    address internal constant BLS12_G2ADD = 0x000000000000000000000000000000000000000d;
-
-    /// @dev For multi-scalar multiplication (MSM) on the BLS12-381 G2 curve.
-    address internal constant BLS12_G2MSM = 0x000000000000000000000000000000000000000E;
-
-    /// @dev For performing a pairing check on the BLS12-381 curve.
-    address internal constant BLS12_PAIRING_CHECK = 0x000000000000000000000000000000000000000F;
-
-    /// @dev For mapping a Fp to a point on the BLS12-381 G1 curve.
-    address internal constant BLS12_MAP_FP_TO_G1 = 0x0000000000000000000000000000000000000010;
-
-    /// @dev For mapping a Fp2 to a point on the BLS12-381 G2 curve.
-    address internal constant BLS12_MAP_FP2_TO_G2 = 0x0000000000000000000000000000000000000011;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CUSTOM ERRORS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // A custom error for each precompile helps us in debugging which precompile has failed.
-
-    /// @dev The G1Add operation failed.
-    error G1AddFailed();
-
-    /// @dev The G1MSM operation failed.
-    error G1MSMFailed();
-
-    /// @dev The G2Add operation failed.
-    error G2AddFailed();
-
-    /// @dev The G2MSM operation failed.
-    error G2MSMFailed();
-
-    /// @dev The pairing operation failed.
-    error PairingFailed();
-
-    /// @dev The MapFpToG1 operation failed.
-    error MapFpToG1Failed();
-
-    /// @dev The MapFpToG2 operation failed.
-    error MapFp2ToG2Failed();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Adds two G1 points. Returns a new G1 point.
-    function add(G1Point memory point0, G1Point memory point1)
-        internal
-        view
-        returns (G1Point memory result)
-    {
-        assembly ("memory-safe") {
-            mcopy(result, point0, 0x80)
-            mcopy(add(result, 0x80), point1, 0x80)
-            if iszero(
-                and(
-                    eq(returndatasize(), 0x80),
-                    staticcall(gas(), BLS12_G1ADD, result, 0x100, result, 0x80)
-                )
-            ) {
-                mstore(0x00, 0xd6cc76eb) // `G1AddFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Multi-scalar multiplication of G1 points with scalars. Returns a new G1 point.
-    function msm(G1Point[] memory points, bytes32[] memory scalars)
-        internal
-        view
-        returns (G1Point memory result)
-    {
-        assembly ("memory-safe") {
-            let k := mload(points)
-            let d := sub(scalars, points)
-            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {
-                points := add(points, 0x20)
-                let o := add(result, mul(0xa0, i))
-                mcopy(o, mload(points), 0x80)
-                mstore(add(o, 0x80), mload(add(points, d)))
-            }
-            if iszero(
-                and(
-                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x80)),
-                    staticcall(gas(), BLS12_G1MSM, result, mul(0xa0, k), result, 0x80)
-                )
-            ) {
-                mstore(0x00, 0x5f776986) // `G1MSMFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Adds two G2 points. Returns a new G2 point.
-    function add(G2Point memory point0, G2Point memory point1)
-        internal
-        view
-        returns (G2Point memory result)
-    {
-        assembly ("memory-safe") {
-            mcopy(result, point0, 0x100)
-            mcopy(add(result, 0x100), point1, 0x100)
-            if iszero(
-                and(
-                    eq(returndatasize(), 0x100),
-                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)
-                )
-            ) {
-                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Multi-scalar multiplication of G2 points with scalars. Returns a new G2 point.
-    function msm(G2Point[] memory points, bytes32[] memory scalars)
-        internal
-        view
-        returns (G2Point memory result)
-    {
-        assembly ("memory-safe") {
-            let k := mload(points)
-            let d := sub(scalars, points)
-            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {
-                points := add(points, 0x20)
-                let o := add(result, mul(0x120, i))
-                mcopy(o, mload(points), 0x100)
-                mstore(add(o, 0x100), mload(add(d, points)))
-            }
-            if iszero(
-                and(
-                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x100)),
-                    staticcall(gas(), BLS12_G2MSM, result, mul(0x120, k), result, 0x100)
-                )
-            ) {
-                mstore(0x00, 0xe3dc5425) // `G2MSMFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Checks the pairing of G1 points with G2 points. Returns whether the pairing is valid.
-    function pairing(G1Point[] memory g1Points, G2Point[] memory g2Points)
-        internal
-        view
-        returns (bool result)
-    {
-        assembly ("memory-safe") {
-            let k := mload(g1Points)
-            let m := mload(0x40)
-            let d := sub(g2Points, g1Points)
-            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {
-                g1Points := add(g1Points, 0x20)
-                let o := add(m, mul(0x180, i))
-                mcopy(o, mload(g1Points), 0x80)
-                mcopy(add(o, 0x80), mload(add(d, g1Points)), 0x100)
-            }
-            if iszero(
-                and(
-                    and(eq(k, mload(g2Points)), eq(returndatasize(), 0x20)),
-                    staticcall(gas(), BLS12_PAIRING_CHECK, m, mul(0x180, k), 0x00, 0x20)
-                )
-            ) {
-                mstore(0x00, 0x4df45e2f) // `PairingFailed()`.
-                revert(0x1c, 0x04)
-            }
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Maps a Fp element to a G1 point.
-    function toG1(Fp memory element) internal view returns (G1Point memory result) {
-        assembly ("memory-safe") {
-            if iszero(
-                and(
-                    eq(returndatasize(), 0x80),
-                    staticcall(gas(), BLS12_MAP_FP_TO_G1, element, 0x40, result, 0x80)
-                )
-            ) {
-                mstore(0x00, 0x24a289fc) // `MapFpToG1Failed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Maps a Fp2 element to a G2 point.
-    function toG2(Fp2 memory element) internal view returns (G2Point memory result) {
-        assembly ("memory-safe") {
-            if iszero(
-                and(
-                    eq(returndatasize(), 0x100),
-                    staticcall(gas(), BLS12_MAP_FP2_TO_G2, element, 0x80, result, 0x100)
-                )
-            ) {
-                mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Computes a point in G2 from a message.
-    function hashToG2(bytes memory message) internal view returns (G2Point memory result) {
-        assembly ("memory-safe") {
-            function dstPrime(o_, i_) -> _o {
-                mstore8(o_, i_) // 1.
-                mstore(add(o_, 0x01), "BLS_SIG_BLS12381G2_XMD:SHA-256_S") // 32.
-                mstore(add(o_, 0x21), "SWU_RO_NUL_\x2b") // 12.
-                _o := add(0x2d, o_)
-            }
-
-            function sha2(data_, n_) -> _h {
-                if iszero(
-                    and(eq(returndatasize(), 0x20), staticcall(gas(), 2, data_, n_, 0x00, 0x20))
-                ) { revert(calldatasize(), 0x00) }
-                _h := mload(0x00)
-            }
-
-            function modfield(s_, b_) {
-                mcopy(add(s_, 0x60), b_, 0x40)
-                if iszero(
-                    and(eq(returndatasize(), 0x40), staticcall(gas(), 5, s_, 0x100, b_, 0x40))
-                ) { revert(calldatasize(), 0x00) }
-            }
-
-            function mapToG2(s_, r_) {
-                if iszero(
-                    and(
-                        eq(returndatasize(), 0x100),
-                        staticcall(gas(), BLS12_MAP_FP2_TO_G2, s_, 0x80, r_, 0x100)
-                    )
-                ) {
-                    mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-
-            let b := mload(0x40)
-            let s := add(b, 0x100)
-            calldatacopy(s, calldatasize(), 0x40)
-            mcopy(add(0x40, s), add(0x20, message), mload(message))
-            let o := add(add(0x40, s), mload(message))
-            mstore(o, shl(240, 256))
-            let b0 := sha2(s, sub(dstPrime(add(0x02, o), 0), s))
-            mstore(0x20, b0)
-            mstore(s, b0)
-            mstore(b, sha2(s, sub(dstPrime(add(0x20, s), 1), s)))
-            let j := b
-            for { let i := 2 } 1 {} {
-                mstore(s, xor(b0, mload(j)))
-                j := add(j, 0x20)
-                mstore(j, sha2(s, sub(dstPrime(add(0x20, s), i), s)))
-                i := add(i, 1)
-                if eq(i, 9) { break }
-            }
-
-            mstore(add(s, 0x00), 0x40)
-            mstore(add(s, 0x20), 0x20)
-            mstore(add(s, 0x40), 0x40)
-            mstore(add(s, 0xa0), 1)
-            mstore(add(s, 0xc0), 0x000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd7)
-            mstore(add(s, 0xe0), 0x64774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)
-            modfield(s, add(b, 0x00))
-            modfield(s, add(b, 0x40))
-            modfield(s, add(b, 0x80))
-            modfield(s, add(b, 0xc0))
-
-            mapToG2(b, result)
-            mapToG2(add(0x80, b), add(0x100, result))
-
-            if iszero(
-                and(
-                    eq(returndatasize(), 0x100),
-                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)
-                )
-            ) {
-                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/ERC1967BeaconProxy.sol b/src/utils/ext/zksync/ERC1967BeaconProxy.sol
deleted file mode 100644
index ad7f5fe..0000000
--- a/src/utils/ext/zksync/ERC1967BeaconProxy.sol
+++ /dev/null
@@ -1,78 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice A sufficiently minimal ERC1967 beacon proxy tailor-made for ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967BeaconProxy.sol)
-contract ERC1967BeaconProxy {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Emitted when the proxy's beacon is upgraded.
-    event BeaconUpgraded(address indexed beacon);
-
-    /// @dev `keccak256(bytes("BeaconUpgraded(address)"))`.
-    uint256 private constant _BEACON_UPGRADED_EVENT_SIGNATURE =
-        0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ERC-1967 storage slot for the implementation in the proxy.
-    /// `uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-    bytes32 internal constant _ERC1967_BEACON_SLOT =
-        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
-
-    /// @dev The storage slot for the deployer.
-    /// `uint256(keccak256("ERC1967BeaconProxy.deployer")) - 1`.
-    bytes32 internal constant _ERC1967_BEACON_PROXY_DEPLOYER_SLOT =
-        0xabc1f855dddf3277214739f5a08d8b9db61505a97fd0c09e835a2d800705b3bc;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CONSTRUCTOR                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    constructor() payable {
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT, caller())
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          FALLBACK                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    fallback() external payable virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.
-            // For the special case of 1-byte calldata, return the implementation.
-            if eq(calldatasize(), 1) {
-                mstore(0x00, 0x5c60da1b) // `implementation()`.
-                let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)
-                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }
-                return(0x00, 0x20) // Return the implementation.
-            }
-            // Deployer workflow.
-            if eq(caller(), sload(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT)) {
-                sstore(_ERC1967_BEACON_SLOT, calldataload(0x00))
-                // Emit the {Upgraded} event.
-                log2(0x00, 0x00, _BEACON_UPGRADED_EVENT_SIGNATURE, calldataload(0x00))
-                stop() // End the context.
-            }
-            // Query the beacon.
-            mstore(0x00, 0x5c60da1b) // `implementation()`.
-            let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)
-            if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }
-            let implementation := mload(0x00)
-            // Perform the delegatecall.
-            calldatacopy(0x00, 0x00, calldatasize())
-            s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)
-            returndatacopy(0x00, 0x00, returndatasize())
-            if iszero(s) { revert(0x00, returndatasize()) }
-            return(0x00, returndatasize())
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/ERC1967Factory.sol b/src/utils/ext/zksync/ERC1967Factory.sol
deleted file mode 100644
index 4637e6f..0000000
--- a/src/utils/ext/zksync/ERC1967Factory.sol
+++ /dev/null
@@ -1,457 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import {ERC1967Proxy} from "./ERC1967Proxy.sol";
-import {UpgradeableBeacon} from "./UpgradeableBeacon.sol";
-import {ERC1967BeaconProxy} from "./ERC1967BeaconProxy.sol";
-
-/// @notice A factory for deploying minimal ERC1967 proxies on ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967Factory.sol)
-///
-/// @dev This factory can be used in one of the following ways:
-/// 1. Deploying a fresh copy with each contract.
-///    Easier to test. In ZKsync VM, factory dependency bytecode is not included in the
-///    factory bytecode, so you do not need to worry too much about bytecode size limits.
-/// 2. Loading it from a storage variable which is set to the canonical address.
-///    See: ERC1967FactoryConstants.ADDRESS.
-///
-/// This factory is crafted to be compatible with both ZKsync VM and regular EVM.
-/// This is so that when ZKsync achieves full EVM equivalence,
-/// this factory can still be used via the fresh copy per contract way.
-contract ERC1967Factory {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The caller is not authorized to call the function.
-    error Unauthorized();
-
-    /// @dev The proxy deployment failed.
-    error DeploymentFailed();
-
-    /// @dev The upgrade failed.
-    error UpgradeFailed();
-
-    /// @dev The salt does not start with the caller.
-    error SaltDoesNotStartWithCaller();
-
-    /// @dev No initialization code hash exists for the instance hash.
-    error NoInitCodeHashFound();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The admin of a `instance` has been changed. Applies to both proxies and beacons.
-    event AdminChanged(address indexed instance, address indexed admin);
-
-    /// @dev The implementation for `instance` has been upgraded. Applies to both proxies and beacons.
-    event Upgraded(address indexed instance, address indexed implementation);
-
-    /// @dev A proxy has been deployed.
-    event ProxyDeployed(
-        address indexed proxy, address indexed implementation, address indexed admin
-    );
-
-    /// @dev A beacon has been deployed.
-    event BeaconDeployed(
-        address indexed beacon, address indexed implementation, address indexed admin
-    );
-
-    /// @dev A beacon proxy has been deployed.
-    event BeaconProxyDeployed(address indexed beaconProxy, address indexed beacon);
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The hash of the proxy.
-    bytes32 public proxyHash;
-
-    /// @dev The hash of the upgradeable beacon.
-    bytes32 public beaconHash;
-
-    /// @dev The hash of the beacon proxy.
-    bytes32 public beaconProxyHash;
-
-    /// @dev Whether to use the CREATE2 address prediction workflow for ZKsync VM.
-    bool internal _useZKsyncCreate2Prediction;
-
-    /// @dev Maps the instance hash to the initialization code hash.
-    mapping(bytes32 => bytes32) internal _initCodeHashes;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CONSTRUCTOR                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    constructor() payable {
-        bytes32 proxySalt = keccak256(abi.encode(address(this), bytes32("proxySalt")));
-        address proxyAddress = address(new ERC1967Proxy{salt: proxySalt}());
-
-        proxyHash = _extcodehash(proxyAddress);
-        beaconHash = _extcodehash(address(new UpgradeableBeacon()));
-        beaconProxyHash = _extcodehash(address(new ERC1967BeaconProxy()));
-
-        if (_predictDeterministicAddressZKsync(proxyHash, proxySalt) == proxyAddress) {
-            _useZKsyncCreate2Prediction = true;
-        } else {
-            _initCodeHashes[proxyHash] = keccak256(type(ERC1967Proxy).creationCode);
-            _initCodeHashes[beaconHash] = keccak256(type(UpgradeableBeacon).creationCode);
-            _initCodeHashes[beaconProxyHash] = keccak256(type(ERC1967BeaconProxy).creationCode);
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      ADMIN FUNCTIONS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the admin of the `instance`.
-    /// Returns `address(0)` if `instance` is a beacon proxy.
-    /// Works for both proxies and beacons.
-    function adminOf(address instance) public view returns (address admin) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            admin := mul(sload(instance), gt(instance, 0xff))
-        }
-    }
-
-    /// @dev Sets the admin of the `instance`.
-    /// The caller of this function must be the admin of `instance`.
-    /// Works for both proxies and beacons.
-    function changeAdmin(address instance, address admin) public {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(eq(sload(instance), caller())) {
-                mstore(0x00, 0x82b42900) // `Unauthorized()`.
-                revert(0x1c, 0x04)
-            }
-            sstore(instance, admin)
-        }
-        emit AdminChanged(instance, admin);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     UPGRADE FUNCTIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Upgrades `instance` to point to `implementation`.
-    /// The caller of this function must be the admin of `instance`.
-    /// Works for both proxies and beacons.
-    function upgrade(address instance, address implementation) public payable {
-        upgradeAndCall(instance, implementation, _emptyData());
-    }
-
-    /// @dev Upgrades `instance` to point to `implementation`.
-    /// Then, calls it with abi encoded `data`.
-    /// The caller of this function must be the admin of `instance`.
-    /// Works for both proxies and beacons.
-    function upgradeAndCall(address instance, address implementation, bytes calldata data)
-        public
-        payable
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(eq(sload(instance), caller())) {
-                mstore(0x00, 0x82b42900) // `Unauthorized()`.
-                revert(0x1c, 0x04)
-            }
-            let m := mload(0x40)
-            mstore(m, implementation)
-            calldatacopy(add(m, 0x20), data.offset, data.length)
-            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {
-                if iszero(returndatasize()) {
-                    mstore(0x00, 0x55299b49) // `UpgradeFailed()`.
-                    revert(0x1c, 0x04)
-                }
-                returndatacopy(0x00, 0x00, returndatasize())
-                revert(0x00, returndatasize())
-            }
-        }
-        emit Upgraded(instance, implementation);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PROXY DEPLOYMENT                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Deploys a proxy for `implementation`, with `admin`, and returns its address.
-    /// The value passed into this function will be forwarded to the proxu.
-    function deployProxy(address implementation, address admin) public payable returns (address) {
-        return deployProxyAndCall(implementation, admin, _emptyData());
-    }
-
-    /// @dev Deploys a proxy for `implementation`, with `admin`, and returns its address.
-    /// The value passed into this function will be forwarded to the proxu.
-    /// Then, calls the proxy with abi encoded `data`.
-    function deployProxyAndCall(address implementation, address admin, bytes calldata data)
-        public
-        payable
-        returns (address)
-    {
-        return _deploy(0, uint160(implementation), uint160(admin), "", false, data);
-    }
-
-    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,
-    /// and returns its deterministic address.
-    /// The value passed into this function will be forwarded to the proxy.
-    function deployProxyDeterministic(address implementation, address admin, bytes32 salt)
-        public
-        payable
-        returns (address)
-    {
-        return deployProxyDeterministicAndCall(implementation, admin, salt, _emptyData());
-    }
-
-    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,
-    /// and returns its deterministic address.
-    /// The value passed into this function will be forwarded to the proxy.
-    /// Then, calls the proxy with abi encoded `data`.
-    function deployProxyDeterministicAndCall(
-        address implementation,
-        address admin,
-        bytes32 salt,
-        bytes calldata data
-    ) public payable returns (address) {
-        return _deploy(0, uint160(implementation), uint160(admin), salt, true, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     BEACON DEPLOYMENT                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Deploys a beacon with `implementation` and `admin`, and returns its address.
-    function deployBeacon(address implementation, address admin) public returns (address) {
-        return _deploy(1, uint160(implementation), uint160(admin), "", false, _emptyData());
-    }
-
-    /// @dev Deploys a beacon with `implementation` and `admin`, with `salt`,
-    /// and returns its deterministic address.
-    function deployBeaconDeterministic(address implementation, address admin, bytes32 salt)
-        public
-        payable
-        returns (address)
-    {
-        return _deploy(1, uint160(implementation), uint160(admin), salt, true, _emptyData());
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  BEACON PROXY DEPLOYMENT                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Deploys a beacon proxy referring to `beacon`, and returns its address.
-    /// The value passed into this function will be forwarded to the beacon proxy.
-    function deployBeaconProxy(address beacon) public payable returns (address) {
-        return deployBeaconProxyAndCall(beacon, _emptyData());
-    }
-
-    /// @dev Deploys a beacon proxy referring to `beacon`, and returns its address.
-    /// The value passed into this function will be forwarded to the beacon proxy.
-    /// Then, calls the beacon proxy with abi encoded `data`.
-    function deployBeaconProxyAndCall(address beacon, bytes calldata data)
-        public
-        payable
-        returns (address)
-    {
-        return _deploy(2, uint160(beacon), 0, "", false, data);
-    }
-
-    /// @dev Deploys a beacon proxy referring to `beacon`, with `salt`,
-    /// and returns its deterministic address.
-    /// The value passed into this function will be forwarded to the beacon proxy.
-    function deployBeaconProxyDeterministic(address beacon, bytes32 salt)
-        public
-        payable
-        returns (address)
-    {
-        return deployBeaconProxyDeterministicAndCall(beacon, salt, _emptyData());
-    }
-
-    /// @dev Deploys a beacon proxy referring to `beacon`, with `salt`,
-    /// and returns its deterministic address.
-    /// The value passed into this function will be forwarded to the beacon proxy.
-    /// Then, calls the beacon proxy with abi encoded `data`.
-    function deployBeaconProxyDeterministicAndCall(
-        address beacon,
-        bytes32 salt,
-        bytes calldata data
-    ) public payable returns (address) {
-        return _deploy(2, uint160(beacon), 0, salt, true, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       PUBLIC HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the address of the instance deployed with `salt`.
-    /// `instanceHash` is one of `proxyHash`, `beaconProxyHash`, `beaconHash`.
-    function predictDeterministicAddress(bytes32 instanceHash, bytes32 salt)
-        public
-        view
-        returns (address)
-    {
-        if (_useZKsyncCreate2Prediction) {
-            return _predictDeterministicAddressZKsync(instanceHash, salt);
-        }
-        return _predictDeterministicAddressRegularEVM(instanceHash, salt);
-    }
-
-    /// @dev Returns the implementation of `instance`.
-    /// If `instance` is not deployed, returns `address(0)`.
-    function implementationOf(address instance) public view returns (address result) {
-        bytes32 h = _extcodehash(instance);
-        if (h == proxyHash || h == beaconProxyHash) {
-            /// @solidity memory-safe-assembly
-            assembly {
-                let s := staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20)
-                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }
-                result := mload(0x00)
-            }
-        } else if (h == beaconHash) {
-            /// @solidity memory-safe-assembly
-            assembly {
-                mstore(0x00, 0x5c60da1b) // `implementation()`.
-                let s := staticcall(gas(), instance, 0x1c, 0x04, 0x00, 0x20)
-                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }
-                result := mload(0x00)
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      INTERNAL HELPERS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Validates the salt and returns it.
-    function _validateSalt(bytes32 salt) internal view returns (bytes32) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // If the salt does not start with the zero address or the caller.
-            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {
-                mstore(0x00, 0x2f634836) // `SaltDoesNotStartWithCaller()`.
-                revert(0x1c, 0x04)
-            }
-        }
-        return salt;
-    }
-
-    /// @dev Performs the deployment optionality to deploy deterministically with a `salt`.
-    function _deploy(
-        uint256 codeType,
-        uint256 target,
-        uint256 admin,
-        bytes32 salt,
-        bool useSalt,
-        bytes calldata data
-    ) internal returns (address instance) {
-        if (codeType == 0) {
-            instance = address(
-                useSalt ? new ERC1967Proxy{salt: _validateSalt(salt)}() : new ERC1967Proxy()
-            );
-            /// @solidity memory-safe-assembly
-            assembly {
-                sstore(instance, admin)
-            }
-            emit ProxyDeployed(instance, address(uint160(target)), address(uint160(admin)));
-        } else if (codeType == 1) {
-            instance = address(
-                useSalt
-                    ? new UpgradeableBeacon{salt: _validateSalt(salt)}()
-                    : new UpgradeableBeacon()
-            );
-            /// @solidity memory-safe-assembly
-            assembly {
-                sstore(instance, admin)
-            }
-            emit BeaconDeployed(instance, address(uint160(target)), address(uint160(admin)));
-        } else {
-            instance = address(
-                useSalt
-                    ? new ERC1967BeaconProxy{salt: _validateSalt(salt)}()
-                    : new ERC1967BeaconProxy()
-            );
-            emit BeaconProxyDeployed(instance, address(uint160(target)));
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Revert if the creation fails.
-            if iszero(instance) {
-                mstore(0x00, 0x30116425) // `DeploymentFailed()`.
-                revert(0x1c, 0x04)
-            }
-            // Make the initialization call.
-            let m := mload(0x40)
-            mstore(m, target)
-            calldatacopy(add(m, 0x20), data.offset, data.length)
-            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {
-                // Revert with the `DeploymentFailed` selector if there is no error returndata.
-                if iszero(returndatasize()) {
-                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.
-                    revert(0x1c, 0x04)
-                }
-                // Otherwise, bubble up the returned error.
-                returndatacopy(0x00, 0x00, returndatasize())
-                revert(0x00, returndatasize())
-            }
-        }
-    }
-
-    /// @dev Returns the `extcodehash` of `instance`.
-    function _extcodehash(address instance) internal view returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := extcodehash(instance)
-        }
-    }
-
-    /// @dev Helper function to return an empty bytes calldata.
-    function _emptyData() internal pure returns (bytes calldata data) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            data.length := 0
-        }
-    }
-
-    /// @dev Returns the predicted `CREATE2` address on ZKsync VM.
-    function _predictDeterministicAddressZKsync(bytes32 instanceHash, bytes32 salt)
-        internal
-        view
-        returns (address predicted)
-    {
-        bytes32 prefix = keccak256("zksyncCreate2");
-        bytes32 emptyStringHash = keccak256("");
-        /// @solidity memory-safe-assembly
-        assembly {
-            // The following is `keccak256(abi.encode(...))`.
-            let m := mload(0x40)
-            mstore(m, prefix)
-            mstore(add(m, 0x20), address())
-            mstore(add(m, 0x40), salt)
-            mstore(add(m, 0x60), instanceHash)
-            mstore(add(m, 0x80), emptyStringHash)
-            predicted := keccak256(m, 0xa0)
-        }
-    }
-
-    /// @dev Returns the predicted `CREATE2` address on regular EVM.
-    function _predictDeterministicAddressRegularEVM(bytes32 instanceHash, bytes32 salt)
-        internal
-        view
-        returns (address predicted)
-    {
-        bytes32 initCodeHash = _initCodeHashes[instanceHash];
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(initCodeHash) {
-                mstore(0x00, 0xa3a58d1c) // `NoInitCodeHashFound()`.
-                revert(0x1c, 0x04)
-            }
-            // The following is `keccak256(abi.encodePacked(...))`.
-            mstore8(0x00, 0xff) // Write the prefix.
-            mstore(0x35, initCodeHash)
-            mstore(0x01, shl(96, address()))
-            mstore(0x15, salt)
-            predicted := keccak256(0x00, 0x55)
-            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/ERC1967FactoryConstants.sol b/src/utils/ext/zksync/ERC1967FactoryConstants.sol
deleted file mode 100644
index 5a46fe0..0000000
--- a/src/utils/ext/zksync/ERC1967FactoryConstants.sol
+++ /dev/null
@@ -1,9 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice The canonical address of the ERC1967Factory for ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967FactoryConstants.sol)
-library ERC1967FactoryConstants {
-    /// @dev The canonical address for ERC1967Factory for ZKsync.
-    address internal constant ADDRESS = 0xc4151FeCa42Df507F158D1FBC4Eb5C145D9CE16B;
-}
diff --git a/src/utils/ext/zksync/ERC1967Proxy.sol b/src/utils/ext/zksync/ERC1967Proxy.sol
deleted file mode 100644
index 3c63458..0000000
--- a/src/utils/ext/zksync/ERC1967Proxy.sol
+++ /dev/null
@@ -1,82 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice A sufficiently minimal ERC1967 proxy tailor-made for ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/ERC1967Proxy.sol)
-contract ERC1967Proxy {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Emitted when the proxy's implementation is upgraded.
-    event Upgraded(address indexed implementation);
-
-    /// @dev `keccak256(bytes("Upgraded(address)"))`.
-    uint256 private constant _UPGRADED_EVENT_SIGNATURE =
-        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ERC-1967 storage slot for the implementation in the proxy.
-    /// `uint256(keccak256("eip1967.proxy.implementation")) - 1`.
-    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =
-        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
-
-    /// @dev The storage slot for the deployer.
-    /// `uint256(keccak256("ERC1967Proxy.deployer")) - 1`.
-    bytes32 internal constant _ERC1967_PROXY_DEPLOYER_SLOT =
-        0xc20b8dda59e1f49cae9bbc6c3744edc7900ba02880cd7b33b5b82a96197202ba;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CONSTRUCTOR                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    constructor() payable {
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(_ERC1967_PROXY_DEPLOYER_SLOT, caller())
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          FALLBACK                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    fallback() external payable virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.
-            // For the special case of 1-byte calldata, return the implementation.
-            if eq(calldatasize(), 1) {
-                mstore(0x00, sload(_ERC1967_IMPLEMENTATION_SLOT))
-                return(0x00, 0x20)
-            }
-            // Deployer workflow.
-            if eq(caller(), sload(_ERC1967_PROXY_DEPLOYER_SLOT)) {
-                let newImplementation := calldataload(0x00)
-                sstore(_ERC1967_IMPLEMENTATION_SLOT, newImplementation)
-                if gt(calldatasize(), 0x20) {
-                    let n := sub(calldatasize(), 0x20)
-                    calldatacopy(0x00, 0x20, n)
-                    if iszero(delegatecall(gas(), newImplementation, 0x00, n, 0x00, 0x00)) {
-                        // Bubble up the revert if the call reverts.
-                        returndatacopy(0x00, 0x00, returndatasize())
-                        revert(0x00, returndatasize())
-                    }
-                }
-                // Emit the {Upgraded} event.
-                log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)
-                stop() // End the context.
-            }
-            // Perform the delegatecall.
-            let implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)
-            calldatacopy(0x00, 0x00, calldatasize())
-            let s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)
-            returndatacopy(0x00, 0x00, returndatasize())
-            if iszero(s) { revert(0x00, returndatasize()) }
-            return(0x00, returndatasize())
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/SafeTransferLib.sol b/src/utils/ext/zksync/SafeTransferLib.sol
deleted file mode 100644
index a968359..0000000
--- a/src/utils/ext/zksync/SafeTransferLib.sol
+++ /dev/null
@@ -1,387 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import {SingleUseETHVault} from "./SingleUseETHVault.sol";
-
-/// @notice Library for force safe transferring ETH and ERC20s in ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/SafeTransferLib.sol)
-library SafeTransferLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev A single use ETH vault has been created for `to`, with `amount`.
-    event SingleUseETHVaultCreated(address indexed to, uint256 amount, address vault);
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The ETH transfer has failed.
-    error ETHTransferFailed();
-
-    /// @dev The ERC20 `transferFrom` has failed.
-    error TransferFromFailed();
-
-    /// @dev The ERC20 `transfer` has failed.
-    error TransferFailed();
-
-    /// @dev The ERC20 `approve` has failed.
-    error ApproveFailed();
-
-    /// @dev The ERC20 `totalSupply` query has failed.
-    error TotalSupplyQueryFailed();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Suggested gas stipend for contract receiving ETH to perform a few
-    /// storage reads and writes, but low enough to prevent griefing.
-    uint256 internal constant GAS_STIPEND_NO_GRIEF = 1000000;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       ETH OPERATIONS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.
-    //
-    // The regular variants:
-    // - Forwards all remaining gas to the target.
-    // - Reverts if the target reverts.
-    // - Reverts if the current contract has insufficient balance.
-    //
-    // The force variants:
-    // - Forwards with an optional gas stipend
-    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).
-    // - If the target reverts, or if the gas stipend is exhausted,
-    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.
-    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.
-    // - Reverts if the current contract has insufficient balance.
-    //
-    // The try variants:
-    // - Forwards with a mandatory gas stipend.
-    // - Instead of reverting, returns whether the transfer succeeded.
-
-    /// @dev Sends `amount` (in wei) ETH to `to`.
-    function safeTransferETH(address to, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {
-                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Sends all the ETH in the current contract to `to`.
-    function safeTransferAllETH(address to) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Transfer all the ETH and check if it succeeded or not.
-            if iszero(call(gas(), to, selfbalance(), 0x00, 0x00, 0x00, 0x00)) {
-                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
-    /// If force transfer is used, returns the vault. Else returns `address(0)`.
-    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend)
-        internal
-        returns (address vault)
-    {
-        if (amount == uint256(0)) return address(0); // Early return if `amount` is zero.
-        uint256 selfBalanceBefore = address(this).balance;
-        /// @solidity memory-safe-assembly
-        assembly {
-            if lt(selfBalanceBefore, amount) {
-                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
-                revert(0x1c, 0x04)
-            }
-            pop(call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00))
-        }
-        if (address(this).balance == selfBalanceBefore) {
-            vault = address(new SingleUseETHVault());
-            /// @solidity memory-safe-assembly
-            assembly {
-                mstore(0x00, shr(96, shl(96, to)))
-                if iszero(call(gas(), vault, amount, 0x00, 0x20, 0x00, 0x00)) { revert(0x00, 0x00) }
-            }
-            emit SingleUseETHVaultCreated(to, amount, vault);
-        }
-    }
-
-    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.
-    /// If force transfer is used, returns the vault. Else returns `address(0)`.
-    function forceSafeTransferAllETH(address to, uint256 gasStipend)
-        internal
-        returns (address vault)
-    {
-        vault = forceSafeTransferETH(to, address(this).balance, gasStipend);
-    }
-
-    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.
-    /// If force transfer is used, returns the vault. Else returns `address(0)`.
-    function forceSafeTransferETH(address to, uint256 amount) internal returns (address vault) {
-        vault = forceSafeTransferETH(to, amount, GAS_STIPEND_NO_GRIEF);
-    }
-
-    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.
-    /// If force transfer is used, returns the vault. Else returns `address(0)`.
-    function forceSafeTransferAllETH(address to) internal returns (address vault) {
-        vault = forceSafeTransferETH(to, address(this).balance, GAS_STIPEND_NO_GRIEF);
-    }
-
-    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
-    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)
-        internal
-        returns (bool success)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            success := call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)
-        }
-    }
-
-    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.
-    function trySafeTransferAllETH(address to, uint256 gasStipend)
-        internal
-        returns (bool success)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            success := call(gasStipend, to, selfbalance(), 0x00, 0x00, 0x00, 0x00)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      ERC20 OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
-    /// Reverts upon failure.
-    ///
-    /// The `from` account must have at least `amount` approved for
-    /// the current contract to manage.
-    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40) // Cache the free memory pointer.
-            mstore(0x60, amount) // Store the `amount` argument.
-            mstore(0x40, to) // Store the `to` argument.
-            mstore(0x2c, shl(96, from)) // Store the `from` argument.
-            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.
-            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            mstore(0x60, 0) // Restore the zero slot to zero.
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
-    ///
-    /// The `from` account must have at least `amount` approved for the current contract to manage.
-    function trySafeTransferFrom(address token, address from, address to, uint256 amount)
-        internal
-        returns (bool success)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40) // Cache the free memory pointer.
-            mstore(0x60, amount) // Store the `amount` argument.
-            mstore(0x40, to) // Store the `to` argument.
-            mstore(0x2c, shl(96, from)) // Store the `from` argument.
-            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.
-            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)
-            }
-            mstore(0x60, 0) // Restore the zero slot to zero.
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /// @dev Sends all of ERC20 `token` from `from` to `to`.
-    /// Reverts upon failure.
-    ///
-    /// The `from` account must have their entire balance approved for the current contract to manage.
-    function safeTransferAllFrom(address token, address from, address to)
-        internal
-        returns (uint256 amount)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40) // Cache the free memory pointer.
-            mstore(0x40, to) // Store the `to` argument.
-            mstore(0x2c, shl(96, from)) // Store the `from` argument.
-            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
-            // Read the balance, reverting upon failure.
-            if iszero(
-                and( // The arguments of `and` are evaluated from right to left.
-                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.
-                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)
-                )
-            ) {
-                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.
-            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.
-            // Perform the transfer, reverting upon failure.
-            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            mstore(0x60, 0) // Restore the zero slot to zero.
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.
-    /// Reverts upon failure.
-    function safeTransfer(address token, address to, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x14, to) // Store the `to` argument.
-            mstore(0x34, amount) // Store the `amount` argument.
-            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
-            // Perform the transfer, reverting upon failure.
-            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
-        }
-    }
-
-    /// @dev Sends all of ERC20 `token` from the current contract to `to`.
-    /// Reverts upon failure.
-    function safeTransferAll(address token, address to) internal returns (uint256 amount) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.
-            mstore(0x20, address()) // Store the address of the current contract.
-            // Read the balance, reverting upon failure.
-            if iszero(
-                and( // The arguments of `and` are evaluated from right to left.
-                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.
-                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)
-                )
-            ) {
-                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x14, to) // Store the `to` argument.
-            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.
-            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
-            // Perform the transfer, reverting upon failure.
-            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
-        }
-    }
-
-    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
-    /// Reverts upon failure.
-    function safeApprove(address token, address to, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x14, to) // Store the `to` argument.
-            mstore(0x34, amount) // Store the `amount` argument.
-            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
-            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
-        }
-    }
-
-    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
-    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,
-    /// then retries the approval again (some tokens, e.g. USDT, requires this).
-    /// Reverts upon failure.
-    function safeApproveWithRetry(address token, address to, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x14, to) // Store the `to` argument.
-            mstore(0x34, amount) // Store the `amount` argument.
-            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
-            // Perform the approval, retrying upon failure.
-            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
-            if iszero(and(eq(mload(0x00), 1), success)) {
-                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                    mstore(0x34, 0) // Store 0 for the `amount`.
-                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
-                    pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00)) // Reset the approval.
-                    mstore(0x34, amount) // Store back the original `amount`.
-                    // Retry the approval, reverting upon failure.
-                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
-                    if iszero(and(eq(mload(0x00), 1), success)) {
-                        // Check the `extcodesize` again just in case the token selfdestructs lol.
-                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
-                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
-                            revert(0x1c, 0x04)
-                        }
-                    }
-                }
-            }
-            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
-        }
-    }
-
-    /// @dev Returns the amount of ERC20 `token` owned by `account`.
-    /// Returns zero if the `token` does not exist.
-    function balanceOf(address token, address account) internal view returns (uint256 amount) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x14, account) // Store the `account` argument.
-            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
-            amount :=
-                mul( // The arguments of `mul` are evaluated from right to left.
-                    mload(0x20),
-                    and( // The arguments of `and` are evaluated from right to left.
-                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.
-                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)
-                    )
-                )
-        }
-    }
-
-    /// @dev Returns the total supply of the `token`.
-    /// Reverts if the token does not exist or does not implement `totalSupply()`.
-    function totalSupply(address token) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x18160ddd) // `totalSupply()`.
-            if iszero(
-                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))
-            ) {
-                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.
-                revert(0x1c, 0x04)
-            }
-            result := mload(0x00)
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/SignatureCheckerLib.sol b/src/utils/ext/zksync/SignatureCheckerLib.sol
deleted file mode 100644
index 6120e87..0000000
--- a/src/utils/ext/zksync/SignatureCheckerLib.sol
+++ /dev/null
@@ -1,367 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice Signature verification helper that supports both ECDSA signatures from EOAs
-/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/SignatureCheckerLib.sol)
-/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)
-///
-/// @dev Note:
-/// - The signature checking functions use the ecrecover precompile (0x1).
-/// - Unlike ECDSA signatures, contract signatures are revocable.
-/// - As of Solady version 0.0.134, all `bytes signature` variants accept both
-///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.
-///   See: https://eips.ethereum.org/EIPS/eip-2098
-///   This is for calldata efficiency on smart accounts prevalent on L2s.
-///
-/// WARNING! Do NOT use signatures as unique identifiers:
-/// - Use a nonce in the digest to prevent replay attacks on the same contract.
-/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.
-///   EIP-712 also enables readable signing of typed data for better user safety.
-/// This implementation does NOT check if a signature is non-malleable.
-library SignatureCheckerLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*               SIGNATURE CHECKING OPERATIONS                */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns whether `signature` is valid for `signer` and `hash`.
-    /// If `signer.code.length == 0`, then validate with `ecrecover`, else
-    /// it will validate with ERC1271 on `signer`.
-    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)
-        internal
-        view
-        returns (bool isValid)
-    {
-        if (signer == address(0)) return isValid;
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            let m := mload(0x40)
-            for {} 1 {} {
-                if iszero(extcodesize(signer)) {
-                    switch mload(signature)
-                    case 64 {
-                        let vs := mload(add(signature, 0x40))
-                        mstore(0x20, add(shr(255, vs), 27)) // `v`.
-                        mstore(0x60, shr(1, shl(1, vs))) // `s`.
-                    }
-                    case 65 {
-                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.
-                        mstore(0x60, mload(add(signature, 0x40))) // `s`.
-                    }
-                    default { break }
-                    mstore(0x00, hash)
-                    mstore(0x40, mload(add(signature, 0x20))) // `r`.
-                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))
-                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))
-                    mstore(0x60, 0) // Restore the zero slot.
-                    mstore(0x40, m) // Restore the free memory pointer.
-                    break
-                }
-                let f := shl(224, 0x1626ba7e)
-                mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-                mstore(add(m, 0x04), hash)
-                let d := add(m, 0x24)
-                mstore(d, 0x40) // The offset of the `signature` in the calldata.
-                // Copy the `signature` over.
-                let n := add(0x20, mload(signature))
-                copy(add(m, 0x44), signature, n)
-                isValid := staticcall(gas(), signer, m, add(n, 0x44), d, 0x20)
-                isValid := and(eq(mload(d), f), isValid)
-                break
-            }
-        }
-    }
-
-    /// @dev Returns whether `signature` is valid for `signer` and `hash`.
-    /// If `signer.code.length == 0`, then validate with `ecrecover`, else
-    /// it will validate with ERC1271 on `signer`.
-    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)
-        internal
-        view
-        returns (bool isValid)
-    {
-        if (signer == address(0)) return isValid;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            for {} 1 {} {
-                if iszero(extcodesize(signer)) {
-                    switch signature.length
-                    case 64 {
-                        let vs := calldataload(add(signature.offset, 0x20))
-                        mstore(0x20, add(shr(255, vs), 27)) // `v`.
-                        mstore(0x40, calldataload(signature.offset)) // `r`.
-                        mstore(0x60, shr(1, shl(1, vs))) // `s`.
-                    }
-                    case 65 {
-                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.
-                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.
-                    }
-                    default { break }
-                    mstore(0x00, hash)
-                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))
-                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))
-                    mstore(0x60, 0) // Restore the zero slot.
-                    mstore(0x40, m) // Restore the free memory pointer.
-                    break
-                }
-                let f := shl(224, 0x1626ba7e)
-                mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-                mstore(add(m, 0x04), hash)
-                let d := add(m, 0x24)
-                mstore(d, 0x40) // The offset of the `signature` in the calldata.
-                mstore(add(m, 0x44), signature.length)
-                // Copy the `signature` over.
-                calldatacopy(add(m, 0x64), signature.offset, signature.length)
-                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)
-                isValid := and(eq(mload(d), f), isValid)
-                break
-            }
-        }
-    }
-
-    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.
-    /// If `signer.code.length == 0`, then validate with `ecrecover`, else
-    /// it will validate with ERC1271 on `signer`.
-    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)
-        internal
-        view
-        returns (bool isValid)
-    {
-        if (signer == address(0)) return isValid;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            for {} 1 {} {
-                if iszero(extcodesize(signer)) {
-                    mstore(0x00, hash)
-                    mstore(0x20, add(shr(255, vs), 27)) // `v`.
-                    mstore(0x40, r) // `r`.
-                    mstore(0x60, shr(1, shl(1, vs))) // `s`.
-                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))
-                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))
-                    mstore(0x60, 0) // Restore the zero slot.
-                    mstore(0x40, m) // Restore the free memory pointer.
-                    break
-                }
-                let f := shl(224, 0x1626ba7e)
-                mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-                mstore(add(m, 0x04), hash)
-                let d := add(m, 0x24)
-                mstore(d, 0x40) // The offset of the `signature` in the calldata.
-                mstore(add(m, 0x44), 65) // Length of the signature.
-                mstore(add(m, 0x64), r) // `r`.
-                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.
-                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.
-                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)
-                isValid := and(eq(mload(d), f), isValid)
-                break
-            }
-        }
-    }
-
-    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.
-    /// If `signer.code.length == 0`, then validate with `ecrecover`, else
-    /// it will validate with ERC1271 on `signer`.
-    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)
-        internal
-        view
-        returns (bool isValid)
-    {
-        if (signer == address(0)) return isValid;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            for {} 1 {} {
-                if iszero(extcodesize(signer)) {
-                    mstore(0x00, hash)
-                    mstore(0x20, and(v, 0xff)) // `v`.
-                    mstore(0x40, r) // `r`.
-                    mstore(0x60, s) // `s`.
-                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))
-                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))
-                    mstore(0x60, 0) // Restore the zero slot.
-                    mstore(0x40, m) // Restore the free memory pointer.
-                    break
-                }
-                let f := shl(224, 0x1626ba7e)
-                mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-                mstore(add(m, 0x04), hash)
-                let d := add(m, 0x24)
-                mstore(d, 0x40) // The offset of the `signature` in the calldata.
-                mstore(add(m, 0x44), 65) // Length of the signature.
-                mstore(add(m, 0x64), r) // `r`.
-                mstore(add(m, 0x84), s) // `s`.
-                mstore8(add(m, 0xa4), v) // `v`.
-                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)
-                isValid := and(eq(mload(d), f), isValid)
-                break
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     ERC1271 OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Note: These ERC1271 operations do NOT have an ECDSA fallback.
-
-    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.
-    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)
-        internal
-        view
-        returns (bool isValid)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copy(dst_, src_, n_) {
-                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {
-                    mstore(add(dst_, i_), mload(add(src_, i_)))
-                }
-            }
-            let m := mload(0x40)
-            let f := shl(224, 0x1626ba7e)
-            mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-            mstore(add(m, 0x04), hash)
-            let d := add(m, 0x24)
-            mstore(d, 0x40) // The offset of the `signature` in the calldata.
-            // Copy the `signature` over.
-            let n := add(0x20, mload(signature))
-            copy(add(m, 0x44), signature, n)
-            isValid := staticcall(gas(), signer, m, add(n, 0x44), d, 0x20)
-            isValid := and(eq(mload(d), f), isValid)
-        }
-    }
-
-    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.
-    function isValidERC1271SignatureNowCalldata(
-        address signer,
-        bytes32 hash,
-        bytes calldata signature
-    ) internal view returns (bool isValid) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            let f := shl(224, 0x1626ba7e)
-            mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-            mstore(add(m, 0x04), hash)
-            let d := add(m, 0x24)
-            mstore(d, 0x40) // The offset of the `signature` in the calldata.
-            mstore(add(m, 0x44), signature.length)
-            // Copy the `signature` over.
-            calldatacopy(add(m, 0x64), signature.offset, signature.length)
-            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)
-            isValid := and(eq(mload(d), f), isValid)
-        }
-    }
-
-    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`
-    /// for an ERC1271 `signer` contract.
-    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)
-        internal
-        view
-        returns (bool isValid)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            let f := shl(224, 0x1626ba7e)
-            mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-            mstore(add(m, 0x04), hash)
-            let d := add(m, 0x24)
-            mstore(d, 0x40) // The offset of the `signature` in the calldata.
-            mstore(add(m, 0x44), 65) // Length of the signature.
-            mstore(add(m, 0x64), r) // `r`.
-            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.
-            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.
-            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)
-            isValid := and(eq(mload(d), f), isValid)
-        }
-    }
-
-    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`
-    /// for an ERC1271 `signer` contract.
-    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)
-        internal
-        view
-        returns (bool isValid)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            let f := shl(224, 0x1626ba7e)
-            mstore(m, f) // `bytes4(keccak256("isValidSignature(bytes32,bytes)"))`.
-            mstore(add(m, 0x04), hash)
-            let d := add(m, 0x24)
-            mstore(d, 0x40) // The offset of the `signature` in the calldata.
-            mstore(add(m, 0x44), 65) // Length of the signature.
-            mstore(add(m, 0x64), r) // `r`.
-            mstore(add(m, 0x84), s) // `s`.
-            mstore8(add(m, 0xa4), v) // `v`.
-            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)
-            isValid := and(eq(mload(d), f), isValid)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     HASHING OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns an Ethereum Signed Message, created from a `hash`.
-    /// This produces a hash corresponding to the one signed with the
-    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)
-    /// JSON-RPC method as part of EIP-191.
-    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, hash) // Store into scratch space for keccak256.
-            mstore(0x00, "\x00\x00\x00\x00\x19Ethereum Signed Message:\n32") // 28 bytes.
-            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.
-        }
-    }
-
-    /// @dev Returns an Ethereum Signed Message, created from `s`.
-    /// This produces a hash corresponding to the one signed with the
-    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)
-    /// JSON-RPC method as part of EIP-191.
-    /// Note: Supports lengths of `s` up to 999999 bytes.
-    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let sLength := mload(s)
-            let o := 0x20
-            mstore(o, "\x19Ethereum Signed Message:\n") // 26 bytes, zero-right-padded.
-            mstore(0x00, 0x00)
-            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.
-            for { let temp := sLength } 1 {} {
-                o := sub(o, 1)
-                mstore8(o, add(48, mod(temp, 10)))
-                temp := div(temp, 10)
-                if iszero(temp) { break }
-            }
-            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.
-            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.
-            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))
-            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.
-            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))
-            mstore(s, sLength) // Restore the length.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                   EMPTY CALLDATA HELPERS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns an empty calldata bytes.
-    function emptySignature() internal pure returns (bytes calldata signature) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            signature.length := 0
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/SingleUseETHVault.sol b/src/utils/ext/zksync/SingleUseETHVault.sol
deleted file mode 100644
index 8dbb0b0..0000000
--- a/src/utils/ext/zksync/SingleUseETHVault.sol
+++ /dev/null
@@ -1,50 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice A single-use vault that allows a designated caller to withdraw all ETH in it.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/SingleUseETHVault.sol)
-contract SingleUseETHVault {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Unable to withdraw all.
-    error WithdrawAllFailed();
-
-    /// @dev Not authorized.
-    error Unauthorized();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        WITHDRAW ALL                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    fallback() external payable virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.
-            let owner := sload(0)
-            // Initialization.
-            if iszero(owner) {
-                sstore(0, calldataload(0x00)) // Store the owner.
-                return(0x00, 0x00) // Early return.
-            }
-            // Authorization check.
-            if iszero(eq(caller(), owner)) {
-                mstore(0x00, 0x82b42900) // `Unauthorized()`.
-                revert(0x1c, 0x04)
-            }
-            let to := calldataload(0x00)
-            // If the calldata is less than 32 bytes, zero-left-pad it to 32 bytes.
-            // Then use the rightmost 20 bytes of the word as the `to` address.
-            // This allows for the calldata to be `abi.encode(to)` or `abi.encodePacked(to)`.
-            to := shr(mul(lt(calldatasize(), 0x20), shl(3, sub(0x20, calldatasize()))), to)
-            // If `to` is `address(0)`, set it to `msg.sender`.
-            to := xor(mul(xor(to, caller()), iszero(to)), to)
-            // Transfers the whole balance to `to`.
-            if iszero(call(gas(), to, selfbalance(), 0x00, 0x00, 0x00, 0x00)) {
-                mstore(0x00, 0x651aee10) // `WithdrawAllFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/UpgradeableBeacon.sol b/src/utils/ext/zksync/UpgradeableBeacon.sol
deleted file mode 100644
index cdbfa0e..0000000
--- a/src/utils/ext/zksync/UpgradeableBeacon.sol
+++ /dev/null
@@ -1,62 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice A sufficiently minimal upgradeable beacon tailor-made for ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/UpgradeableBeacon.sol)
-contract UpgradeableBeacon {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                           EVENTS                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Emitted when the proxy's implementation is upgraded.
-    event Upgraded(address indexed implementation);
-
-    /// @dev `keccak256(bytes("Upgraded(address)"))`.
-    uint256 private constant _UPGRADED_EVENT_SIGNATURE =
-        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                          STORAGE                           */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev To store the implementation.
-    uint256 private __implementation;
-
-    /// @dev For upgrades / initialization.
-    uint256 private __deployer;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CONSTRUCTOR                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    constructor() payable {
-        __deployer = uint256(uint160(msg.sender));
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*               UPGRADEABLE BEACON OPERATIONS                */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the implementation stored in the beacon.
-    /// See: https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address
-    function implementation() public view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := sload(__implementation.slot)
-        }
-    }
-
-    fallback() external virtual {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.
-            let newImplementation := calldataload(0x00)
-            // Revert if the caller is not the deployer. We will still allow the implementation
-            // to be set to an empty contract for simplicity.
-            if iszero(eq(caller(), sload(__deployer.slot))) { revert(0x00, 0x00) }
-            sstore(__implementation.slot, newImplementation)
-            // Emit the {Upgraded} event.
-            log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)
-        }
-    }
-}
diff --git a/src/utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol b/src/utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol
deleted file mode 100644
index 88b0736..0000000
--- a/src/utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol
+++ /dev/null
@@ -1,301 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-/// @notice Library for efficient querying of the delegate registry on ZKsync.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol)
-library DelegateCheckerLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The canonical delegate registry V2 on ZKsync.
-    /// There's no V1 on ZKsync.
-    /// See: https://sepolia.abscan.org/address/0x0000000059A24EB229eED07Ac44229DB56C5d797
-    address internal constant DELEGATE_REGISTRY_V2 = 0x0000000059A24EB229eED07Ac44229DB56C5d797;
-
-    /// @dev The storage slot to store an override address for the `DELEGATE_REGISTRY_V2`.
-    /// If the address is non-zero, it will be used instead.
-    /// This is so that you can avoid using `vm.etch` in ZKsync Foundry,
-    /// and instead use `vm.store` instead.
-    bytes32 internal constant DELEGATE_REGISTRY_V2_OVERRIDE_SLOT =
-        0x04ecb0522ab37ca0b278a89c6884dfdbcde83c177150fc939ab02e069068bdef;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                DELEGATE CHECKING OPERATIONS                */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Note:
-    // - `to` is the delegate. Typically called the "hot wallet".
-    // - `from` is the grantor of the delegate rights. Typically called the "cold vault".
-
-    /// @dev Returns if `to` is a delegate of `from`.
-    /// ```
-    ///     v2.checkDelegateForAll(to, from, "")
-    /// ```
-    function checkDelegateForAll(address to, address from) internal view returns (bool isValid) {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            // `0x60` is already 0.
-            mstore(0x40, from)
-            mstore(0x2c, shl(96, to))
-            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.
-            isValid := eq(mload(staticcall(gas(), v2, 0x1c, 0x64, 0x01, 0x20)), 1)
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /// @dev Returns if `to` is a delegate of `from`.
-    /// ```
-    ///     v2.checkDelegateForAll(to, from, rights)
-    /// ```
-    function checkDelegateForAll(address to, address from, bytes32 rights)
-        internal
-        view
-        returns (bool isValid)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(0x60, rights)
-            mstore(0x40, from)
-            mstore(0x2c, shl(96, to))
-            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.
-            isValid := eq(mload(staticcall(gas(), v2, 0x1c, 0x64, 0x01, 0x20)), 1)
-            mstore(0x40, m) // Restore the free memory pointer.
-            mstore(0x60, 0) // Restore the zero pointer.
-        }
-    }
-
-    /// @dev Returns if `to` is a delegate of `from` for the specified `contract_`.
-    /// ```
-    ///     v2.checkDelegateForContract(to, from, contract_, "")
-    /// ```
-    /// Returns true if `checkDelegateForAll(to, from)` returns true.
-    function checkDelegateForContract(address to, address from, address contract_)
-        internal
-        view
-        returns (bool isValid)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(add(0x80, m), 0)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForContract(address,address,address,bytes32)`.
-            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)
-            isValid := staticcall(gas(), v2, add(m, 0x1c), 0x84, m, 0x20)
-            isValid := and(eq(mload(m), 1), isValid)
-        }
-    }
-
-    /// @dev Returns if `to` is a delegate of `from` for the specified `contract_`.
-    /// ```
-    ///     v2.checkDelegateForContract(to, from, contract_, rights)
-    /// ```
-    /// Returns true if `checkDelegateForAll(to, from, rights)` returns true.
-    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)
-        internal
-        view
-        returns (bool isValid)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(add(0x80, m), rights)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForContract(address,address,address,bytes32)`.
-            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)
-            isValid := staticcall(gas(), v2, add(m, 0x1c), 0x84, m, 0x20)
-            isValid := and(eq(mload(m), 1), isValid)
-        }
-    }
-
-    /// @dev Returns if `to` is a delegate of `from` for the specified `contract_` and token `id`.
-    /// ```
-    ///     v2.checkDelegateForERC721(to, from, contract_, id, "")
-    /// ```
-    /// Returns true if `checkDelegateForContract(to, from, contract_)` returns true.
-    function checkDelegateForERC721(address to, address from, address contract_, uint256 id)
-        internal
-        view
-        returns (bool isValid)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(add(0xa0, m), 0)
-            mstore(add(0x80, m), id)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.
-            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)
-            isValid := staticcall(gas(), v2, add(m, 0x1c), 0xa4, m, 0x20)
-            isValid := and(eq(mload(m), 1), isValid)
-        }
-    }
-
-    /// @dev Returns if `to` is a delegate of `from` for the specified `contract_` and token `id`.
-    /// ```
-    ///     v2.checkDelegateForERC721(to, from, contract_, id, rights)
-    /// ```
-    /// Returns true if `checkDelegateForContract(to, from, contract_, rights)` returns true.
-    function checkDelegateForERC721(
-        address to,
-        address from,
-        address contract_,
-        uint256 id,
-        bytes32 rights
-    ) internal view returns (bool isValid) {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(add(0xa0, m), rights)
-            mstore(add(0x80, m), id)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.
-            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)
-            isValid := staticcall(gas(), v2, add(m, 0x1c), 0xa4, m, 0x20)
-            isValid := and(eq(mload(m), 1), isValid)
-        }
-    }
-
-    /// @dev Returns the amount of an ERC20 token for `contract_`
-    /// that `to` is granted rights to act on the behalf of `from`.
-    /// ```
-    ///     v2.checkDelegateForERC20(to, from, contract_, "")
-    /// ```
-    /// Returns `type(uint256).max` if `checkDelegateForContract(to, from, contract_)` returns true.
-    function checkDelegateForERC20(address to, address from, address contract_)
-        internal
-        view
-        returns (uint256 amount)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            let o := add(0x80, m)
-            mstore(o, 0)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC20(address,address,address,bytes32)`.
-            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)
-            amount := staticcall(gas(), v2, add(m, 0x1c), 0x84, o, 0x20)
-            amount := mul(mload(o), amount)
-        }
-    }
-
-    /// @dev Returns the amount of an ERC20 token for `contract_`
-    /// that `to` is granted rights to act on the behalf of `from`.
-    /// ```
-    ///     v2.checkDelegateForERC20(to, from, contract_, rights)
-    /// ```
-    /// Returns `type(uint256).max` if `checkDelegateForContract(to, from, contract_, rights)` returns true.
-    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)
-        internal
-        view
-        returns (uint256 amount)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(0x00, 0)
-            mstore(add(0x80, m), rights)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC20(address,address,address,bytes32)`.
-            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)
-            amount := staticcall(gas(), v2, add(m, 0x1c), 0x84, 0x00, 0x20)
-            amount := mul(mload(0x00), amount)
-        }
-    }
-
-    /// @dev Returns the amount of an ERC1155 token `id` for `contract_`
-    /// that `to` is granted rights to act on the behalf of `from`.
-    /// ```
-    ///     v2.checkDelegateForERC1155(to, from, contract_, id, "")
-    /// ```
-    /// Returns `type(uint256).max` if `checkDelegateForContract(to, from, contract_)` returns true.
-    function checkDelegateForERC1155(address to, address from, address contract_, uint256 id)
-        internal
-        view
-        returns (uint256 amount)
-    {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            let o := add(0xa0, m)
-            mstore(o, 0)
-            mstore(add(0x80, m), id)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.
-            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)
-            amount := staticcall(gas(), v2, add(m, 0x1c), 0xa4, o, 0x20)
-            amount := mul(mload(o), amount)
-        }
-    }
-
-    /// @dev Returns the amount of an ERC1155 token `id` for `contract_`
-    /// that `to` is granted rights to act on the behalf of `from`.
-    /// ```
-    ///     v2.checkDelegateForERC1155(to, from, contract_, id, rights)
-    /// ```
-    /// Returns `type(uint256).max` if `checkDelegateForContract(to, from, contract_, rights)` returns true.
-    function checkDelegateForERC1155(
-        address to,
-        address from,
-        address contract_,
-        uint256 id,
-        bytes32 rights
-    ) internal view returns (uint256 amount) {
-        address v2 = _delegateRegistryV2();
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(0x00, 0)
-            mstore(add(0xa0, m), rights)
-            mstore(add(0x80, m), id)
-            mstore(add(0x60, m), contract_)
-            mstore(add(0x4c, m), shl(96, from))
-            mstore(add(0x2c, m), shl(96, to))
-            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.
-            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)
-            amount := staticcall(gas(), v2, add(m, 0x1c), 0xa4, 0x00, 0x20)
-            amount := mul(mload(0x00), amount)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the address of the delegate registry V2.
-    function _delegateRegistryV2() private view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Don't worry about it, storage read is cheap on ZKsync VM.
-            result := shr(96, shl(96, sload(DELEGATE_REGISTRY_V2_OVERRIDE_SLOT)))
-            result := or(mul(DELEGATE_REGISTRY_V2, iszero(result)), result)
-        }
-    }
-}
diff --git a/src/utils/g/DynamicArrayLib.sol b/src/utils/g/DynamicArrayLib.sol
deleted file mode 100644
index 61cbd51..0000000
--- a/src/utils/g/DynamicArrayLib.sol
+++ /dev/null
@@ -1,1024 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Type to represent a dynamic array in memory.
-/// You can directly assign to `data`, and the `p` function will
-/// take care of the memory allocation.
-struct DynamicArray {
-    uint256[] data;
-}
-
-using DynamicArrayLib for DynamicArray global;
-
-/// @notice Library for memory arrays with automatic capacity resizing.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/DynamicArrayLib.sol)
-library DynamicArrayLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The constant returned when the element is not found in the array.
-    uint256 internal constant NOT_FOUND = type(uint256).max;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  UINT256 ARRAY OPERATIONS                  */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Low level minimalist uint256 array operations.
-    // If you don't need syntax sugar, it's recommended to use these.
-    // Some of these functions return the same array for function chaining.
-    // e.g. `array.set(0, 1).set(1, 2)`.
-
-    /// @dev Returns a uint256 array with `n` elements. The elements are not zeroized.
-    function malloc(uint256 n) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := or(sub(0, shr(32, n)), mload(0x40))
-            mstore(result, n)
-            mstore(0x40, add(add(result, 0x20), shl(5, n)))
-        }
-    }
-
-    /// @dev Zeroizes all the elements of `a`.
-    function zeroize(uint256[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-            calldatacopy(add(result, 0x20), calldatasize(), shl(5, mload(result)))
-        }
-    }
-
-    /// @dev Returns the element at `a[i]`, without bounds checking.
-    function get(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a[i]`, without bounds checking.
-    function getUint256(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a[i]`, without bounds checking.
-    function getAddress(uint256[] memory a, uint256 i) internal pure returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a[i]`, without bounds checking.
-    function getBool(uint256[] memory a, uint256 i) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a[i]`, without bounds checking.
-    function getBytes32(uint256[] memory a, uint256 i) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(uint256[] memory a, uint256 i, uint256 data)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(result, 0x20), shl(5, i)), data)
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(uint256[] memory a, uint256 i, address data)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(result, 0x20), shl(5, i)), shr(96, shl(96, data)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(uint256[] memory a, uint256 i, bool data)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(result, 0x20), shl(5, i)), iszero(iszero(data)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(uint256[] memory a, uint256 i, bytes32 data)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(result, 0x20), shl(5, i)), data)
-        }
-    }
-
-    /// @dev Casts `a` to `address[]`.
-    function asAddressArray(uint256[] memory a) internal pure returns (address[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Casts `a` to `bool[]`.
-    function asBoolArray(uint256[] memory a) internal pure returns (bool[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Casts `a` to `bytes32[]`.
-    function asBytes32Array(uint256[] memory a) internal pure returns (bytes32[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Casts `a` to `uint256[]`.
-    function toUint256Array(address[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Casts `a` to `uint256[]`.
-    function toUint256Array(bool[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Casts `a` to `uint256[]`.
-    function toUint256Array(bytes32[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Reduces the size of `a` to `n`.
-    /// If `n` is greater than the size of `a`, this will be a no-op.
-    function truncate(uint256[] memory a, uint256 n)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-            mstore(mul(lt(n, mload(result)), result), n)
-        }
-    }
-
-    /// @dev Clears the array and attempts to free the memory if possible.
-    function free(uint256[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-            let n := mload(result)
-            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), result), mload(0x40)))), result)
-            mstore(result, 0)
-        }
-    }
-
-    /// @dev Equivalent to `keccak256(abi.encodePacked(a))`.
-    function hash(uint256[] memory a) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := keccak256(add(a, 0x20), shl(5, mload(a)))
-        }
-    }
-
-    /// @dev Returns a copy of `a` sliced from `start` to `end` (exclusive).
-    function slice(uint256[] memory a, uint256 start, uint256 end)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let arrayLen := mload(a)
-            if iszero(gt(arrayLen, end)) { end := arrayLen }
-            if iszero(gt(arrayLen, start)) { start := arrayLen }
-            if lt(start, end) {
-                result := mload(0x40)
-                let resultLen := sub(end, start)
-                mstore(result, resultLen)
-                a := add(a, shl(5, start))
-                // Copy the `a` one word at a time, backwards.
-                let o := shl(5, resultLen)
-                mstore(0x40, add(add(result, o), 0x20)) // Allocate memory.
-                for {} 1 {} {
-                    mstore(add(result, o), mload(add(a, o)))
-                    o := sub(o, 0x20)
-                    if iszero(o) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Returns a copy of `a` sliced from `start` to the end of the array.
-    function slice(uint256[] memory a, uint256 start)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        result = slice(a, start, type(uint256).max);
-    }
-
-    /// @dev Returns a copy of the array.
-    function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let end := add(add(result, 0x20), shl(5, mload(a)))
-            let o := result
-            for { let d := sub(a, result) } 1 {} {
-                mstore(o, mload(add(o, d)))
-                o := add(0x20, o)
-                if eq(o, end) { break }
-            }
-            mstore(0x40, o)
-        }
-    }
-
-    /// @dev Returns if `needle` is in `a`.
-    function contains(uint256[] memory a, uint256 needle) internal pure returns (bool) {
-        return ~indexOf(a, needle, 0) != 0;
-    }
-
-    /// @dev Returns the first index of `needle`, scanning forward from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(uint256[] memory a, uint256 needle, uint256 from)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := not(0)
-            if lt(from, mload(a)) {
-                let o := add(a, shl(5, from))
-                let end := add(shl(5, add(1, mload(a))), a)
-                let c := mload(end) // Cache the word after the array.
-                for { mstore(end, needle) } 1 {} {
-                    o := add(o, 0x20)
-                    if eq(mload(o), needle) { break }
-                }
-                mstore(end, c) // Restore the word after the array.
-                if iszero(eq(o, end)) { result := shr(5, sub(o, add(0x20, a))) }
-            }
-        }
-    }
-
-    /// @dev Returns the first index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(uint256[] memory a, uint256 needle) internal pure returns (uint256 result) {
-        result = indexOf(a, needle, 0);
-    }
-
-    /// @dev Returns the last index of `needle`, scanning backwards from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(uint256[] memory a, uint256 needle, uint256 from)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := not(0)
-            let n := mload(a)
-            if n {
-                if iszero(lt(from, n)) { from := sub(n, 1) }
-                let o := add(shl(5, add(2, from)), a)
-                for { mstore(a, needle) } 1 {} {
-                    o := sub(o, 0x20)
-                    if eq(mload(o), needle) { break }
-                }
-                mstore(a, n) // Restore the length.
-                if iszero(eq(o, a)) { result := shr(5, sub(o, add(0x20, a))) }
-            }
-        }
-    }
-
-    /// @dev Returns the first index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(uint256[] memory a, uint256 needle)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        result = lastIndexOf(a, needle, NOT_FOUND);
-    }
-
-    /// @dev Directly returns `a` without copying.
-    function directReturn(uint256[] memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let retStart := sub(a, 0x20)
-            mstore(retStart, 0x20)
-            return(retStart, add(0x40, shl(5, mload(a))))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  DYNAMIC ARRAY OPERATIONS                  */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Some of these functions return the same array for function chaining.
-    // e.g. `a.p("1").p("2")`.
-
-    /// @dev Shorthand for `a.data.length`.
-    function length(DynamicArray memory a) internal pure returns (uint256) {
-        return a.data.length;
-    }
-
-    /// @dev Wraps `a` in a dynamic array struct.
-    function wrap(uint256[] memory a) internal pure returns (DynamicArray memory result) {
-        result.data = a;
-    }
-
-    /// @dev Wraps `a` in a dynamic array struct.
-    function wrap(address[] memory a) internal pure returns (DynamicArray memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, a)
-        }
-    }
-
-    /// @dev Wraps `a` in a dynamic array struct.
-    function wrap(bool[] memory a) internal pure returns (DynamicArray memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, a)
-        }
-    }
-
-    /// @dev Wraps `a` in a dynamic array struct.
-    function wrap(bytes32[] memory a) internal pure returns (DynamicArray memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, a)
-        }
-    }
-
-    /// @dev Clears the array without deallocating the memory.
-    function clear(DynamicArray memory a) internal pure returns (DynamicArray memory result) {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(mload(result), 0)
-        }
-    }
-
-    /// @dev Clears the array and attempts to free the memory if possible.
-    function free(DynamicArray memory a) internal pure returns (DynamicArray memory result) {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let arrData := mload(result)
-            if iszero(eq(arrData, 0x60)) {
-                let prime := 8188386068317523
-                let cap := mload(sub(arrData, 0x20))
-                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.
-                cap := mul(div(cap, prime), iszero(mod(cap, prime)))
-                // If `cap` is non-zero and the memory is contiguous, we can free it.
-                if lt(iszero(cap), eq(mload(0x40), add(arrData, add(0x20, cap)))) {
-                    mstore(0x40, sub(arrData, 0x20))
-                }
-                mstore(result, 0x60)
-            }
-        }
-    }
-
-    /// @dev Resizes the array to contain `n` elements. New elements will be zeroized.
-    function resize(DynamicArray memory a, uint256 n)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        reserve(result, n);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let arrData := mload(result)
-            let arrLen := mload(arrData)
-            if iszero(lt(n, arrLen)) {
-                calldatacopy(
-                    add(arrData, shl(5, add(1, arrLen))), calldatasize(), shl(5, sub(n, arrLen))
-                )
-            }
-            mstore(arrData, n)
-        }
-    }
-
-    /// @dev Increases the size of `a` to `n`.
-    /// If `n` is less than the size of `a`, this will be a no-op.
-    /// This method does not zeroize any newly created elements.
-    function expand(DynamicArray memory a, uint256 n)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        if (n >= a.data.length) {
-            reserve(result, n);
-            /// @solidity memory-safe-assembly
-            assembly {
-                mstore(mload(result), n)
-            }
-        }
-    }
-
-    /// @dev Reduces the size of `a` to `n`.
-    /// If `n` is greater than the size of `a`, this will be a no-op.
-    function truncate(DynamicArray memory a, uint256 n)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(mul(lt(n, mload(mload(result))), mload(result)), n)
-        }
-    }
-
-    /// @dev Reserves at least `minimum` amount of contiguous memory.
-    function reserve(DynamicArray memory a, uint256 minimum)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(lt(minimum, 0xffffffff)) { invalid() } // For extra safety.
-            for { let arrData := mload(a) } 1 {} {
-                // Some random prime number to multiply `cap`, so that
-                // we know that the `cap` is for a dynamic array.
-                // Selected to be larger than any memory pointer realistically.
-                let prime := 8188386068317523
-                // Special case for `arrData` pointing to zero pointer.
-                if eq(arrData, 0x60) {
-                    let newCap := shl(5, add(1, minimum))
-                    let capSlot := mload(0x40)
-                    mstore(capSlot, mul(prime, newCap)) // Store the capacity.
-                    let newArrData := add(0x20, capSlot)
-                    mstore(newArrData, 0) // Store the length.
-                    mstore(0x40, add(newArrData, add(0x20, newCap))) // Allocate memory.
-                    mstore(a, newArrData)
-                    break
-                }
-                let w := not(0x1f)
-                let cap := mload(add(arrData, w)) // `mload(sub(arrData, w))`.
-                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.
-                cap := mul(div(cap, prime), iszero(mod(cap, prime)))
-                let newCap := shl(5, minimum)
-                // If we don't need to grow the memory.
-                if iszero(and(gt(minimum, mload(arrData)), gt(newCap, cap))) { break }
-                // If the memory is contiguous, we can simply expand it.
-                if eq(mload(0x40), add(arrData, add(0x20, cap))) {
-                    mstore(add(arrData, w), mul(prime, newCap)) // Store the capacity.
-                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.
-                    break
-                }
-                let capSlot := mload(0x40)
-                let newArrData := add(capSlot, 0x20)
-                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.
-                mstore(a, newArrData) // Store the `newArrData`.
-                // Copy `arrData` one word at a time, backwards.
-                for { let o := add(0x20, shl(5, mload(arrData))) } 1 {} {
-                    mstore(add(newArrData, o), mload(add(arrData, o)))
-                    o := add(o, w) // `sub(o, 0x20)`.
-                    if iszero(o) { break }
-                }
-                mstore(capSlot, mul(prime, newCap)) // Store the capacity.
-                mstore(newArrData, mload(arrData)) // Store the length.
-                break
-            }
-        }
-    }
-
-    /// @dev Appends `data` to `a`.
-    function p(DynamicArray memory a, uint256 data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let arrData := mload(a)
-            let newArrLen := add(mload(arrData), 1)
-            let newArrBytesLen := shl(5, newArrLen)
-            // Some random prime number to multiply `cap`, so that
-            // we know that the `cap` is for a dynamic array.
-            // Selected to be larger than any memory pointer realistically.
-            let prime := 8188386068317523
-            let cap := mload(sub(arrData, 0x20))
-            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.
-            cap := mul(div(cap, prime), iszero(mod(cap, prime)))
-
-            // Expand / Reallocate memory if required.
-            // Note that we need to allocate an extra word for the length.
-            for {} iszero(lt(newArrBytesLen, cap)) {} {
-                // Approximately more than double the capacity to ensure more than enough space.
-                let newCap := add(cap, or(cap, newArrBytesLen))
-                // If the memory is contiguous, we can simply expand it.
-                if iszero(or(xor(mload(0x40), add(arrData, add(0x20, cap))), iszero(cap))) {
-                    mstore(sub(arrData, 0x20), mul(prime, newCap)) // Store the capacity.
-                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.
-                    break
-                }
-                // Set the `newArrData` to point to the word after `cap`.
-                let newArrData := add(mload(0x40), 0x20)
-                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.
-                mstore(a, newArrData) // Store the `newArrData`.
-                let w := not(0x1f)
-                // Copy `arrData` one word at a time, backwards.
-                for { let o := newArrBytesLen } 1 {} {
-                    mstore(add(newArrData, o), mload(add(arrData, o)))
-                    o := add(o, w) // `sub(o, 0x20)`.
-                    if iszero(o) { break }
-                }
-                mstore(add(newArrData, w), mul(prime, newCap)) // Store the memory.
-                arrData := newArrData // Assign `newArrData` to `arrData`.
-                break
-            }
-            mstore(add(arrData, newArrBytesLen), data) // Append `data`.
-            mstore(arrData, newArrLen) // Store the length.
-        }
-    }
-
-    /// @dev Appends `data` to `a`.
-    function p(DynamicArray memory a, address data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = p(a, uint256(uint160(data)));
-    }
-
-    /// @dev Appends `data` to `a`.
-    function p(DynamicArray memory a, bool data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = p(a, _toUint(data));
-    }
-
-    /// @dev Appends `data` to `a`.
-    function p(DynamicArray memory a, bytes32 data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = p(a, uint256(data));
-    }
-
-    /// @dev Shorthand for returning an empty array.
-    function p() internal pure returns (DynamicArray memory result) {}
-
-    /// @dev Shorthand for `p(p(), data)`.
-    function p(uint256 data) internal pure returns (DynamicArray memory result) {
-        p(result, uint256(data));
-    }
-
-    /// @dev Shorthand for `p(p(), data)`.
-    function p(address data) internal pure returns (DynamicArray memory result) {
-        p(result, uint256(uint160(data)));
-    }
-
-    /// @dev Shorthand for `p(p(), data)`.
-    function p(bool data) internal pure returns (DynamicArray memory result) {
-        p(result, _toUint(data));
-    }
-
-    /// @dev Shorthand for `p(p(), data)`.
-    function p(bytes32 data) internal pure returns (DynamicArray memory result) {
-        p(result, uint256(data));
-    }
-
-    /// @dev Removes and returns the last element of `a`.
-    /// Returns 0 and does not pop anything if the array is empty.
-    function pop(DynamicArray memory a) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := mload(a)
-            let n := mload(o)
-            result := mload(add(o, shl(5, n)))
-            mstore(o, sub(n, iszero(iszero(n))))
-        }
-    }
-
-    /// @dev Removes and returns the last element of `a`.
-    /// Returns 0 and does not pop anything if the array is empty.
-    function popUint256(DynamicArray memory a) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := mload(a)
-            let n := mload(o)
-            result := mload(add(o, shl(5, n)))
-            mstore(o, sub(n, iszero(iszero(n))))
-        }
-    }
-
-    /// @dev Removes and returns the last element of `a`.
-    /// Returns 0 and does not pop anything if the array is empty.
-    function popAddress(DynamicArray memory a) internal pure returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := mload(a)
-            let n := mload(o)
-            result := mload(add(o, shl(5, n)))
-            mstore(o, sub(n, iszero(iszero(n))))
-        }
-    }
-
-    /// @dev Removes and returns the last element of `a`.
-    /// Returns 0 and does not pop anything if the array is empty.
-    function popBool(DynamicArray memory a) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := mload(a)
-            let n := mload(o)
-            result := mload(add(o, shl(5, n)))
-            mstore(o, sub(n, iszero(iszero(n))))
-        }
-    }
-
-    /// @dev Removes and returns the last element of `a`.
-    /// Returns 0 and does not pop anything if the array is empty.
-    function popBytes32(DynamicArray memory a) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := mload(a)
-            let n := mload(o)
-            result := mload(add(o, shl(5, n)))
-            mstore(o, sub(n, iszero(iszero(n))))
-        }
-    }
-
-    /// @dev Returns the element at `a.data[i]`, without bounds checking.
-    function get(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(mload(a), 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a.data[i]`, without bounds checking.
-    function getUint256(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(mload(a), 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a.data[i]`, without bounds checking.
-    function getAddress(DynamicArray memory a, uint256 i) internal pure returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(mload(a), 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a.data[i]`, without bounds checking.
-    function getBool(DynamicArray memory a, uint256 i) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(mload(a), 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Returns the element at `a.data[i]`, without bounds checking.
-    function getBytes32(DynamicArray memory a, uint256 i) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(mload(a), 0x20), shl(5, i)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(DynamicArray memory a, uint256 i, uint256 data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(mload(result), 0x20), shl(5, i)), data)
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(DynamicArray memory a, uint256 i, address data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(mload(result), 0x20), shl(5, i)), shr(96, shl(96, data)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(DynamicArray memory a, uint256 i, bool data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(mload(result), 0x20), shl(5, i)), iszero(iszero(data)))
-        }
-    }
-
-    /// @dev Sets `a.data[i]` to `data`, without bounds checking.
-    function set(DynamicArray memory a, uint256 i, bytes32 data)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        _deallocate(result);
-        result = a;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(add(add(mload(result), 0x20), shl(5, i)), data)
-        }
-    }
-
-    /// @dev Returns the underlying array as a `uint256[]`.
-    function asUint256Array(DynamicArray memory a)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(a)
-        }
-    }
-
-    /// @dev Returns the underlying array as a `address[]`.
-    function asAddressArray(DynamicArray memory a)
-        internal
-        pure
-        returns (address[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(a)
-        }
-    }
-
-    /// @dev Returns the underlying array as a `bool[]`.
-    function asBoolArray(DynamicArray memory a) internal pure returns (bool[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(a)
-        }
-    }
-
-    /// @dev Returns the underlying array as a `bytes32[]`.
-    function asBytes32Array(DynamicArray memory a)
-        internal
-        pure
-        returns (bytes32[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(a)
-        }
-    }
-
-    /// @dev Returns a copy of `a` sliced from `start` to `end` (exclusive).
-    function slice(DynamicArray memory a, uint256 start, uint256 end)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        result.data = slice(a.data, start, end);
-    }
-
-    /// @dev Returns a copy of `a` sliced from `start` to the end of the array.
-    function slice(DynamicArray memory a, uint256 start)
-        internal
-        pure
-        returns (DynamicArray memory result)
-    {
-        result.data = slice(a.data, start, type(uint256).max);
-    }
-
-    /// @dev Returns a copy of `a`.
-    function copy(DynamicArray memory a) internal pure returns (DynamicArray memory result) {
-        result.data = copy(a.data);
-    }
-
-    /// @dev Returns if `needle` is in `a`.
-    function contains(DynamicArray memory a, uint256 needle) internal pure returns (bool) {
-        return ~indexOf(a.data, needle, 0) != 0;
-    }
-
-    /// @dev Returns if `needle` is in `a`.
-    function contains(DynamicArray memory a, address needle) internal pure returns (bool) {
-        return ~indexOf(a.data, uint160(needle), 0) != 0;
-    }
-
-    /// @dev Returns if `needle` is in `a`.
-    function contains(DynamicArray memory a, bytes32 needle) internal pure returns (bool) {
-        return ~indexOf(a.data, uint256(needle), 0) != 0;
-    }
-
-    /// @dev Returns the first index of `needle`, scanning forward from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, uint256 needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return indexOf(a.data, needle, from);
-    }
-
-    /// @dev Returns the first index of `needle`, scanning forward from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, address needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return indexOf(a.data, uint160(needle), from);
-    }
-
-    /// @dev Returns the first index of `needle`, scanning forward from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, bytes32 needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return indexOf(a.data, uint256(needle), from);
-    }
-
-    /// @dev Returns the first index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {
-        return indexOf(a.data, needle, 0);
-    }
-
-    /// @dev Returns the first index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {
-        return indexOf(a.data, uint160(needle), 0);
-    }
-
-    /// @dev Returns the first index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function indexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {
-        return indexOf(a.data, uint256(needle), 0);
-    }
-
-    /// @dev Returns the last index of `needle`, scanning backwards from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, uint256 needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return lastIndexOf(a.data, needle, from);
-    }
-
-    /// @dev Returns the last index of `needle`, scanning backwards from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, address needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return lastIndexOf(a.data, uint160(needle), from);
-    }
-
-    /// @dev Returns the last index of `needle`, scanning backwards from `from`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, bytes32 needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return lastIndexOf(a.data, uint256(needle), from);
-    }
-
-    /// @dev Returns the last index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {
-        return lastIndexOf(a.data, needle, NOT_FOUND);
-    }
-
-    /// @dev Returns the last index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {
-        return lastIndexOf(a.data, uint160(needle), NOT_FOUND);
-    }
-
-    /// @dev Returns the last index of `needle`.
-    /// If `needle` is not in `a`, returns `NOT_FOUND`.
-    function lastIndexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {
-        return lastIndexOf(a.data, uint256(needle), NOT_FOUND);
-    }
-
-    /// @dev Equivalent to `keccak256(abi.encodePacked(a.data))`.
-    function hash(DynamicArray memory a) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := keccak256(add(mload(a), 0x20), shl(5, mload(mload(a))))
-        }
-    }
-
-    /// @dev Directly returns `a` without copying.
-    function directReturn(DynamicArray memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let arrData := mload(a)
-            let retStart := sub(arrData, 0x20)
-            mstore(retStart, 0x20)
-            return(retStart, add(0x40, shl(5, mload(arrData))))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Helper for deallocating an automatically allocated array pointer.
-    function _deallocate(DynamicArray memory result) private pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // Deallocate, as we have already allocated.
-        }
-    }
-
-    /// @dev Casts the bool into a uint256.
-    function _toUint(bool b) private pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := iszero(iszero(b))
-        }
-    }
-}
diff --git a/src/utils/g/DynamicBufferLib.sol b/src/utils/g/DynamicBufferLib.sol
deleted file mode 100644
index 0e9c3ee..0000000
--- a/src/utils/g/DynamicBufferLib.sol
+++ /dev/null
@@ -1,1317 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Type to represent a dynamic buffer in memory.
-/// You can directly assign to `data`, and the `p` function will
-/// take care of the memory allocation.
-struct DynamicBuffer {
-    bytes data;
-}
-
-using DynamicBufferLib for DynamicBuffer global;
-
-/// @notice Library for buffers with automatic capacity resizing.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/DynamicBufferLib.sol)
-/// @author Modified from cozyco (https://github.com/samkingco/cozyco/blob/main/contracts/utils/DynamicBuffer.sol)
-library DynamicBufferLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Some of these functions return the same buffer for function chaining.
-    // e.g. `buffer.p("1").p("2")`.
-
-    /// @dev Shorthand for `buffer.data.length`.
-    function length(DynamicBuffer memory buffer) internal pure returns (uint256) {
-        return buffer.data.length;
-    }
-
-    /// @dev Reserves at least `minimum` amount of contiguous memory.
-    function reserve(DynamicBuffer memory buffer, uint256 minimum)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = buffer;
-        uint256 n = buffer.data.length;
-        if (minimum > n) {
-            uint256 i = 0x40;
-            do {} while ((i <<= 1) < minimum);
-            bytes memory data;
-            /// @solidity memory-safe-assembly
-            assembly {
-                data := 0x01
-                mstore(data, sub(i, n))
-            }
-            result = p(result, data);
-        }
-    }
-
-    /// @dev Clears the buffer without deallocating the memory.
-    function clear(DynamicBuffer memory buffer)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(mload(buffer), 0)
-        }
-        result = buffer;
-    }
-
-    /// @dev Returns a string pointing to the underlying bytes data.
-    /// Note: The string WILL change if the buffer is updated.
-    function s(DynamicBuffer memory buffer) internal pure returns (string memory) {
-        return string(buffer.data);
-    }
-
-    /// @dev Appends `data` to `buffer`.
-    function p(DynamicBuffer memory buffer, bytes memory data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = buffer;
-        if (data.length == uint256(0)) return result;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let w := not(0x1f)
-            let bufData := mload(buffer)
-            let bufDataLen := mload(bufData)
-            let newBufDataLen := add(mload(data), bufDataLen)
-            // Some random prime number to multiply `cap`, so that
-            // we know that the `cap` is for a dynamic buffer.
-            // Selected to be larger than any memory pointer realistically.
-            let prime := 1621250193422201
-            let cap := mload(add(bufData, w)) // `mload(sub(bufData, 0x20))`.
-            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.
-            cap := mul(div(cap, prime), iszero(mod(cap, prime)))
-
-            // Expand / Reallocate memory if required.
-            // Note that we need to allocate an extra word for the length, and
-            // and another extra word as a safety word (giving a total of 0x40 bytes).
-            // Without the safety word, the backwards copying can cause a buffer overflow.
-            for {} iszero(lt(newBufDataLen, cap)) {} {
-                // Approximately more than double the capacity to ensure more than enough space.
-                let newCap := and(add(cap, add(or(cap, newBufDataLen), 0x20)), w)
-                // If the memory is contiguous, we can simply expand it.
-                if iszero(or(xor(mload(0x40), add(bufData, add(0x40, cap))), iszero(cap))) {
-                    // Store `cap * prime` in the word before the length.
-                    mstore(add(bufData, w), mul(prime, newCap))
-                    mstore(0x40, add(bufData, add(0x40, newCap))) // Expand the memory allocation.
-                    break
-                }
-                // Set the `newBufData` to point to the word after `cap`.
-                let newBufData := add(mload(0x40), 0x20)
-                mstore(0x40, add(newBufData, add(0x40, newCap))) // Reallocate the memory.
-                mstore(buffer, newBufData) // Store the `newBufData`.
-                // Copy `bufData` one word at a time, backwards.
-                for { let o := and(add(bufDataLen, 0x20), w) } 1 {} {
-                    mstore(add(newBufData, o), mload(add(bufData, o)))
-                    o := add(o, w) // `sub(o, 0x20)`.
-                    if iszero(o) { break }
-                }
-                // Store `cap * prime` in the word before the length.
-                mstore(add(newBufData, w), mul(prime, newCap))
-                bufData := newBufData // Assign `newBufData` to `bufData`.
-                break
-            }
-            // If it's a reserve operation, set the variables to skip the appending.
-            if eq(data, 0x01) {
-                mstore(data, 0x00)
-                newBufDataLen := bufDataLen
-            }
-            // Copy `data` one word at a time, backwards.
-            for { let o := and(add(mload(data), 0x20), w) } 1 {} {
-                mstore(add(add(bufData, bufDataLen), o), mload(add(data, o)))
-                o := add(o, w) // `sub(o, 0x20)`.
-                if iszero(o) { break }
-            }
-            mstore(add(add(bufData, 0x20), newBufDataLen), 0) // Zeroize the word after the buffer.
-            mstore(bufData, newBufDataLen) // Store the length.
-        }
-    }
-
-    /// @dev Appends `data0`, `data1` to `buffer`.
-    function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(p(buffer, data0), data1);
-    }
-
-    /// @dev Appends `data0` .. `data2` to `buffer`.
-    function p(
-        DynamicBuffer memory buffer,
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2
-    ) internal pure returns (DynamicBuffer memory result) {
-        _deallocate(result);
-        result = p(p(p(buffer, data0), data1), data2);
-    }
-
-    /// @dev Appends `data0` .. `data3` to `buffer`.
-    function p(
-        DynamicBuffer memory buffer,
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3
-    ) internal pure returns (DynamicBuffer memory result) {
-        _deallocate(result);
-        result = p(p(p(p(buffer, data0), data1), data2), data3);
-    }
-
-    /// @dev Appends `data0` .. `data4` to `buffer`.
-    function p(
-        DynamicBuffer memory buffer,
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4
-    ) internal pure returns (DynamicBuffer memory result) {
-        _deallocate(result);
-        result = p(p(p(p(p(buffer, data0), data1), data2), data3), data4);
-    }
-
-    /// @dev Appends `data0` .. `data5` to `buffer`.
-    function p(
-        DynamicBuffer memory buffer,
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4,
-        bytes memory data5
-    ) internal pure returns (DynamicBuffer memory result) {
-        _deallocate(result);
-        result = p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5);
-    }
-
-    /// @dev Appends `data0` .. `data6` to `buffer`.
-    function p(
-        DynamicBuffer memory buffer,
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4,
-        bytes memory data5,
-        bytes memory data6
-    ) internal pure returns (DynamicBuffer memory result) {
-        _deallocate(result);
-        result = p(p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5), data6);
-    }
-
-    /// @dev Appends `abi.encodePacked(bool(data))` to buffer.
-    function pBool(DynamicBuffer memory buffer, bool data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        uint256 casted;
-        /// @solidity memory-safe-assembly
-        assembly {
-            casted := iszero(iszero(data))
-        }
-        result = p(buffer, _single(casted, 1));
-    }
-
-    /// @dev Appends `abi.encodePacked(address(data))` to buffer.
-    function pAddress(DynamicBuffer memory buffer, address data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(uint256(uint160(data)), 20));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint8(data))` to buffer.
-    function pUint8(DynamicBuffer memory buffer, uint8 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 1));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint16(data))` to buffer.
-    function pUint16(DynamicBuffer memory buffer, uint16 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 2));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint24(data))` to buffer.
-    function pUint24(DynamicBuffer memory buffer, uint24 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 3));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint32(data))` to buffer.
-    function pUint32(DynamicBuffer memory buffer, uint32 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 4));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint40(data))` to buffer.
-    function pUint40(DynamicBuffer memory buffer, uint40 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 5));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint48(data))` to buffer.
-    function pUint48(DynamicBuffer memory buffer, uint48 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 6));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint56(data))` to buffer.
-    function pUint56(DynamicBuffer memory buffer, uint56 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 7));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint64(data))` to buffer.
-    function pUint64(DynamicBuffer memory buffer, uint64 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 8));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint72(data))` to buffer.
-    function pUint72(DynamicBuffer memory buffer, uint72 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 9));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint80(data))` to buffer.
-    function pUint80(DynamicBuffer memory buffer, uint80 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 10));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint88(data))` to buffer.
-    function pUint88(DynamicBuffer memory buffer, uint88 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 11));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint96(data))` to buffer.
-    function pUint96(DynamicBuffer memory buffer, uint96 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 12));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint104(data))` to buffer.
-    function pUint104(DynamicBuffer memory buffer, uint104 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 13));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint112(data))` to buffer.
-    function pUint112(DynamicBuffer memory buffer, uint112 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 14));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint120(data))` to buffer.
-    function pUint120(DynamicBuffer memory buffer, uint120 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 15));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint128(data))` to buffer.
-    function pUint128(DynamicBuffer memory buffer, uint128 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 16));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint136(data))` to buffer.
-    function pUint136(DynamicBuffer memory buffer, uint136 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 17));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint144(data))` to buffer.
-    function pUint144(DynamicBuffer memory buffer, uint144 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 18));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint152(data))` to buffer.
-    function pUint152(DynamicBuffer memory buffer, uint152 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 19));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint160(data))` to buffer.
-    function pUint160(DynamicBuffer memory buffer, uint160 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 20));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint168(data))` to buffer.
-    function pUint168(DynamicBuffer memory buffer, uint168 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 21));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint176(data))` to buffer.
-    function pUint176(DynamicBuffer memory buffer, uint176 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 22));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint184(data))` to buffer.
-    function pUint184(DynamicBuffer memory buffer, uint184 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 23));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint192(data))` to buffer.
-    function pUint192(DynamicBuffer memory buffer, uint192 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 24));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint200(data))` to buffer.
-    function pUint200(DynamicBuffer memory buffer, uint200 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 25));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint208(data))` to buffer.
-    function pUint208(DynamicBuffer memory buffer, uint208 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 26));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint216(data))` to buffer.
-    function pUint216(DynamicBuffer memory buffer, uint216 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 27));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint224(data))` to buffer.
-    function pUint224(DynamicBuffer memory buffer, uint224 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 28));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint232(data))` to buffer.
-    function pUint232(DynamicBuffer memory buffer, uint232 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 29));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint240(data))` to buffer.
-    function pUint240(DynamicBuffer memory buffer, uint240 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 30));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint248(data))` to buffer.
-    function pUint248(DynamicBuffer memory buffer, uint248 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 31));
-    }
-
-    /// @dev Appends `abi.encodePacked(uint256(data))` to buffer.
-    function pUint256(DynamicBuffer memory buffer, uint256 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(data, 32));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes1(data))` to buffer.
-    function pBytes1(DynamicBuffer memory buffer, bytes1 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 1));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes2(data))` to buffer.
-    function pBytes2(DynamicBuffer memory buffer, bytes2 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 2));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes3(data))` to buffer.
-    function pBytes3(DynamicBuffer memory buffer, bytes3 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 3));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes4(data))` to buffer.
-    function pBytes4(DynamicBuffer memory buffer, bytes4 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 4));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes5(data))` to buffer.
-    function pBytes5(DynamicBuffer memory buffer, bytes5 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 5));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes6(data))` to buffer.
-    function pBytes6(DynamicBuffer memory buffer, bytes6 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 6));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes7(data))` to buffer.
-    function pBytes7(DynamicBuffer memory buffer, bytes7 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 7));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes8(data))` to buffer.
-    function pBytes8(DynamicBuffer memory buffer, bytes8 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 8));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes9(data))` to buffer.
-    function pBytes9(DynamicBuffer memory buffer, bytes9 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 9));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes10(data))` to buffer.
-    function pBytes10(DynamicBuffer memory buffer, bytes10 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 10));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes11(data))` to buffer.
-    function pBytes11(DynamicBuffer memory buffer, bytes11 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 11));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes12(data))` to buffer.
-    function pBytes12(DynamicBuffer memory buffer, bytes12 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 12));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes13(data))` to buffer.
-    function pBytes13(DynamicBuffer memory buffer, bytes13 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 13));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes14(data))` to buffer.
-    function pBytes14(DynamicBuffer memory buffer, bytes14 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 14));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes15(data))` to buffer.
-    function pBytes15(DynamicBuffer memory buffer, bytes15 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 15));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes16(data))` to buffer.
-    function pBytes16(DynamicBuffer memory buffer, bytes16 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 16));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes17(data))` to buffer.
-    function pBytes17(DynamicBuffer memory buffer, bytes17 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 17));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes18(data))` to buffer.
-    function pBytes18(DynamicBuffer memory buffer, bytes18 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 18));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes19(data))` to buffer.
-    function pBytes19(DynamicBuffer memory buffer, bytes19 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 19));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes20(data))` to buffer.
-    function pBytes20(DynamicBuffer memory buffer, bytes20 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 20));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes21(data))` to buffer.
-    function pBytes21(DynamicBuffer memory buffer, bytes21 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 21));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes22(data))` to buffer.
-    function pBytes22(DynamicBuffer memory buffer, bytes22 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 22));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes23(data))` to buffer.
-    function pBytes23(DynamicBuffer memory buffer, bytes23 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 23));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes24(data))` to buffer.
-    function pBytes24(DynamicBuffer memory buffer, bytes24 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 24));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes25(data))` to buffer.
-    function pBytes25(DynamicBuffer memory buffer, bytes25 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 25));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes26(data))` to buffer.
-    function pBytes26(DynamicBuffer memory buffer, bytes26 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 26));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes27(data))` to buffer.
-    function pBytes27(DynamicBuffer memory buffer, bytes27 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 27));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes28(data))` to buffer.
-    function pBytes28(DynamicBuffer memory buffer, bytes28 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 28));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes29(data))` to buffer.
-    function pBytes29(DynamicBuffer memory buffer, bytes29 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 29));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes30(data))` to buffer.
-    function pBytes30(DynamicBuffer memory buffer, bytes30 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 30));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes31(data))` to buffer.
-    function pBytes31(DynamicBuffer memory buffer, bytes31 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 31));
-    }
-
-    /// @dev Appends `abi.encodePacked(bytes32(data))` to buffer.
-    function pBytes32(DynamicBuffer memory buffer, bytes32 data)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        _deallocate(result);
-        result = p(buffer, _single(bytes32(data), 32));
-    }
-
-    /// @dev Shorthand for returning a new buffer.
-    function p() internal pure returns (DynamicBuffer memory result) {}
-
-    /// @dev Shorthand for `p(p(), data)`.
-    function p(bytes memory data) internal pure returns (DynamicBuffer memory result) {
-        p(result, data);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, data1)`.
-    function p(bytes memory data0, bytes memory data1)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        p(p(result, data0), data1);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, .., data2)`.
-    function p(bytes memory data0, bytes memory data1, bytes memory data2)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        p(p(p(result, data0), data1), data2);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, .., data3)`.
-    function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3)
-        internal
-        pure
-        returns (DynamicBuffer memory result)
-    {
-        p(p(p(p(result, data0), data1), data2), data3);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, .., data4)`.
-    function p(
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4
-    ) internal pure returns (DynamicBuffer memory result) {
-        p(p(p(p(p(result, data0), data1), data2), data3), data4);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, .., data5)`.
-    function p(
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4,
-        bytes memory data5
-    ) internal pure returns (DynamicBuffer memory result) {
-        p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5);
-    }
-
-    /// @dev Shorthand for `p(p(), data0, .., data6)`.
-    function p(
-        bytes memory data0,
-        bytes memory data1,
-        bytes memory data2,
-        bytes memory data3,
-        bytes memory data4,
-        bytes memory data5,
-        bytes memory data6
-    ) internal pure returns (DynamicBuffer memory result) {
-        p(p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5), data6);
-    }
-
-    /// @dev Shorthand for `pBool(p(), data)`.
-    function pBool(bool data) internal pure returns (DynamicBuffer memory result) {
-        pBool(result, data);
-    }
-
-    /// @dev Shorthand for `pAddress(p(), data)`.
-    function pAddress(address data) internal pure returns (DynamicBuffer memory result) {
-        pAddress(result, data);
-    }
-
-    /// @dev Shorthand for `pUint8(p(), data)`.
-    function pUint8(uint8 data) internal pure returns (DynamicBuffer memory result) {
-        pUint8(result, data);
-    }
-
-    /// @dev Shorthand for `pUint16(p(), data)`.
-    function pUint16(uint16 data) internal pure returns (DynamicBuffer memory result) {
-        pUint16(result, data);
-    }
-
-    /// @dev Shorthand for `pUint24(p(), data)`.
-    function pUint24(uint24 data) internal pure returns (DynamicBuffer memory result) {
-        pUint24(result, data);
-    }
-
-    /// @dev Shorthand for `pUint32(p(), data)`.
-    function pUint32(uint32 data) internal pure returns (DynamicBuffer memory result) {
-        pUint32(result, data);
-    }
-
-    /// @dev Shorthand for `pUint40(p(), data)`.
-    function pUint40(uint40 data) internal pure returns (DynamicBuffer memory result) {
-        pUint40(result, data);
-    }
-
-    /// @dev Shorthand for `pUint48(p(), data)`.
-    function pUint48(uint48 data) internal pure returns (DynamicBuffer memory result) {
-        pUint48(result, data);
-    }
-
-    /// @dev Shorthand for `pUint56(p(), data)`.
-    function pUint56(uint56 data) internal pure returns (DynamicBuffer memory result) {
-        pUint56(result, data);
-    }
-
-    /// @dev Shorthand for `pUint64(p(), data)`.
-    function pUint64(uint64 data) internal pure returns (DynamicBuffer memory result) {
-        pUint64(result, data);
-    }
-
-    /// @dev Shorthand for `pUint72(p(), data)`.
-    function pUint72(uint72 data) internal pure returns (DynamicBuffer memory result) {
-        pUint72(result, data);
-    }
-
-    /// @dev Shorthand for `pUint80(p(), data)`.
-    function pUint80(uint80 data) internal pure returns (DynamicBuffer memory result) {
-        pUint80(result, data);
-    }
-
-    /// @dev Shorthand for `pUint88(p(), data)`.
-    function pUint88(uint88 data) internal pure returns (DynamicBuffer memory result) {
-        pUint88(result, data);
-    }
-
-    /// @dev Shorthand for `pUint96(p(), data)`.
-    function pUint96(uint96 data) internal pure returns (DynamicBuffer memory result) {
-        pUint96(result, data);
-    }
-
-    /// @dev Shorthand for `pUint104(p(), data)`.
-    function pUint104(uint104 data) internal pure returns (DynamicBuffer memory result) {
-        pUint104(result, data);
-    }
-
-    /// @dev Shorthand for `pUint112(p(), data)`.
-    function pUint112(uint112 data) internal pure returns (DynamicBuffer memory result) {
-        pUint112(result, data);
-    }
-
-    /// @dev Shorthand for `pUint120(p(), data)`.
-    function pUint120(uint120 data) internal pure returns (DynamicBuffer memory result) {
-        pUint120(result, data);
-    }
-
-    /// @dev Shorthand for `pUint128(p(), data)`.
-    function pUint128(uint128 data) internal pure returns (DynamicBuffer memory result) {
-        pUint128(result, data);
-    }
-
-    /// @dev Shorthand for `pUint136(p(), data)`.
-    function pUint136(uint136 data) internal pure returns (DynamicBuffer memory result) {
-        pUint136(result, data);
-    }
-
-    /// @dev Shorthand for `pUint144(p(), data)`.
-    function pUint144(uint144 data) internal pure returns (DynamicBuffer memory result) {
-        pUint144(result, data);
-    }
-
-    /// @dev Shorthand for `pUint152(p(), data)`.
-    function pUint152(uint152 data) internal pure returns (DynamicBuffer memory result) {
-        pUint152(result, data);
-    }
-
-    /// @dev Shorthand for `pUint160(p(), data)`.
-    function pUint160(uint160 data) internal pure returns (DynamicBuffer memory result) {
-        pUint160(result, data);
-    }
-
-    /// @dev Shorthand for `pUint168(p(), data)`.
-    function pUint168(uint168 data) internal pure returns (DynamicBuffer memory result) {
-        pUint168(result, data);
-    }
-
-    /// @dev Shorthand for `pUint176(p(), data)`.
-    function pUint176(uint176 data) internal pure returns (DynamicBuffer memory result) {
-        pUint176(result, data);
-    }
-
-    /// @dev Shorthand for `pUint184(p(), data)`.
-    function pUint184(uint184 data) internal pure returns (DynamicBuffer memory result) {
-        pUint184(result, data);
-    }
-
-    /// @dev Shorthand for `pUint192(p(), data)`.
-    function pUint192(uint192 data) internal pure returns (DynamicBuffer memory result) {
-        pUint192(result, data);
-    }
-
-    /// @dev Shorthand for `pUint200(p(), data)`.
-    function pUint200(uint200 data) internal pure returns (DynamicBuffer memory result) {
-        pUint200(result, data);
-    }
-
-    /// @dev Shorthand for `pUint208(p(), data)`.
-    function pUint208(uint208 data) internal pure returns (DynamicBuffer memory result) {
-        pUint208(result, data);
-    }
-
-    /// @dev Shorthand for `pUint216(p(), data)`.
-    function pUint216(uint216 data) internal pure returns (DynamicBuffer memory result) {
-        pUint216(result, data);
-    }
-
-    /// @dev Shorthand for `pUint224(p(), data)`.
-    function pUint224(uint224 data) internal pure returns (DynamicBuffer memory result) {
-        pUint224(result, data);
-    }
-
-    /// @dev Shorthand for `pUint232(p(), data)`.
-    function pUint232(uint232 data) internal pure returns (DynamicBuffer memory result) {
-        pUint232(result, data);
-    }
-
-    /// @dev Shorthand for `pUint240(p(), data)`.
-    function pUint240(uint240 data) internal pure returns (DynamicBuffer memory result) {
-        pUint240(result, data);
-    }
-
-    /// @dev Shorthand for `pUint248(p(), data)`.
-    function pUint248(uint248 data) internal pure returns (DynamicBuffer memory result) {
-        pUint248(result, data);
-    }
-
-    /// @dev Shorthand for `pUint256(p(), data)`.
-    function pUint256(uint256 data) internal pure returns (DynamicBuffer memory result) {
-        pUint256(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes1(p(), data)`.
-    function pBytes1(bytes1 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes1(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes2(p(), data)`.
-    function pBytes2(bytes2 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes2(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes3(p(), data)`.
-    function pBytes3(bytes3 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes3(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes4(p(), data)`.
-    function pBytes4(bytes4 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes4(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes5(p(), data)`.
-    function pBytes5(bytes5 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes5(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes6(p(), data)`.
-    function pBytes6(bytes6 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes6(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes7(p(), data)`.
-    function pBytes7(bytes7 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes7(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes8(p(), data)`.
-    function pBytes8(bytes8 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes8(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes9(p(), data)`.
-    function pBytes9(bytes9 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes9(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes10(p(), data)`.
-    function pBytes10(bytes10 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes10(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes11(p(), data)`.
-    function pBytes11(bytes11 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes11(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes12(p(), data)`.
-    function pBytes12(bytes12 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes12(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes13(p(), data)`.
-    function pBytes13(bytes13 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes13(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes14(p(), data)`.
-    function pBytes14(bytes14 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes14(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes15(p(), data)`.
-    function pBytes15(bytes15 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes15(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes16(p(), data)`.
-    function pBytes16(bytes16 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes16(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes17(p(), data)`.
-    function pBytes17(bytes17 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes17(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes18(p(), data)`.
-    function pBytes18(bytes18 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes18(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes19(p(), data)`.
-    function pBytes19(bytes19 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes19(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes20(p(), data)`.
-    function pBytes20(bytes20 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes20(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes21(p(), data)`.
-    function pBytes21(bytes21 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes21(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes22(p(), data)`.
-    function pBytes22(bytes22 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes22(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes23(p(), data)`.
-    function pBytes23(bytes23 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes23(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes24(p(), data)`.
-    function pBytes24(bytes24 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes24(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes25(p(), data)`.
-    function pBytes25(bytes25 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes25(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes26(p(), data)`.
-    function pBytes26(bytes26 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes26(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes27(p(), data)`.
-    function pBytes27(bytes27 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes27(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes28(p(), data)`.
-    function pBytes28(bytes28 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes28(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes29(p(), data)`.
-    function pBytes29(bytes29 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes29(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes30(p(), data)`.
-    function pBytes30(bytes30 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes30(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes31(p(), data)`.
-    function pBytes31(bytes31 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes31(result, data);
-    }
-
-    /// @dev Shorthand for `pBytes32(p(), data)`.
-    function pBytes32(bytes32 data) internal pure returns (DynamicBuffer memory result) {
-        pBytes32(result, data);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Helper for deallocating an automatically allocated `buffer` pointer.
-    function _deallocate(DynamicBuffer memory result) private pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // Deallocate, as we have already allocated.
-        }
-    }
-
-    /// @dev Returns a temporary bytes string of length `n` for `data`.
-    function _single(uint256 data, uint256 n) private pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := 0x00
-            mstore(n, data)
-            mstore(result, n)
-        }
-    }
-
-    /// @dev Returns a temporary bytes string of length `n` for `data`.
-    function _single(bytes32 data, uint256 n) private pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := 0x00
-            mstore(0x20, data)
-            mstore(result, n)
-        }
-    }
-}
diff --git a/src/utils/g/EnumerableMapLib.sol b/src/utils/g/EnumerableMapLib.sol
deleted file mode 100644
index 8a7f961..0000000
--- a/src/utils/g/EnumerableMapLib.sol
+++ /dev/null
@@ -1,832 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev An enumerable map of `bytes32` to `bytes32`.
-struct Bytes32ToBytes32Map {
-    EnumerableSetLib.Bytes32Set _keys;
-    mapping(bytes32 => bytes32) _values;
-}
-
-/// @dev An enumerable map of `bytes32` to `uint256`.
-struct Bytes32ToUint256Map {
-    EnumerableSetLib.Bytes32Set _keys;
-    mapping(bytes32 => uint256) _values;
-}
-
-/// @dev An enumerable map of `bytes32` to `address`.
-struct Bytes32ToAddressMap {
-    EnumerableSetLib.Bytes32Set _keys;
-    mapping(bytes32 => address) _values;
-}
-
-/// @dev An enumerable map of `uint256` to `bytes32`.
-struct Uint256ToBytes32Map {
-    EnumerableSetLib.Uint256Set _keys;
-    mapping(uint256 => bytes32) _values;
-}
-
-/// @dev An enumerable map of `uint256` to `uint256`.
-struct Uint256ToUint256Map {
-    EnumerableSetLib.Uint256Set _keys;
-    mapping(uint256 => uint256) _values;
-}
-
-/// @dev An enumerable map of `uint256` to `address`.
-struct Uint256ToAddressMap {
-    EnumerableSetLib.Uint256Set _keys;
-    mapping(uint256 => address) _values;
-}
-
-/// @dev An enumerable map of `address` to `bytes32`.
-struct AddressToBytes32Map {
-    EnumerableSetLib.AddressSet _keys;
-    mapping(address => bytes32) _values;
-}
-
-/// @dev An enumerable map of `address` to `uint256`.
-struct AddressToUint256Map {
-    EnumerableSetLib.AddressSet _keys;
-    mapping(address => uint256) _values;
-}
-
-/// @dev An enumerable map of `address` to `address`.
-struct AddressToAddressMap {
-    EnumerableSetLib.AddressSet _keys;
-    mapping(address => address) _values;
-}
-
-using EnumerableMapLib for Bytes32ToBytes32Map global;
-using EnumerableMapLib for Bytes32ToUint256Map global;
-using EnumerableMapLib for Bytes32ToAddressMap global;
-using EnumerableMapLib for Uint256ToBytes32Map global;
-using EnumerableMapLib for Uint256ToUint256Map global;
-using EnumerableMapLib for Uint256ToAddressMap global;
-using EnumerableMapLib for AddressToBytes32Map global;
-using EnumerableMapLib for AddressToUint256Map global;
-using EnumerableMapLib for AddressToAddressMap global;
-
-import {EnumerableSetLib} from "../EnumerableSetLib.sol";
-
-/// @notice Library for managing enumerable maps in storage.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/EnumerableMapLib.sol)
-/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol)
-library EnumerableMapLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The key does not exist in the enumerable map.
-    error EnumerableMapKeyNotFound();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     GETTERS / SETTERS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Bytes32ToBytes32Map storage map,
-        bytes32 key,
-        bytes32 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Bytes32ToBytes32Map storage map, uint256 i)
-        internal
-        view
-        returns (bytes32 key, bytes32 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key)
-        internal
-        view
-        returns (bool exists, bytes32 value)
-    {
-        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Bytes32ToBytes32Map storage map, bytes32 key)
-        internal
-        view
-        returns (bytes32 value)
-    {
-        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Bytes32ToUint256Map storage map, bytes32 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Bytes32ToUint256Map storage map,
-        bytes32 key,
-        uint256 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Bytes32ToUint256Map storage map, bytes32 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Bytes32ToUint256Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Bytes32ToUint256Map storage map, uint256 i)
-        internal
-        view
-        returns (bytes32 key, uint256 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Bytes32ToUint256Map storage map, bytes32 key)
-        internal
-        view
-        returns (bool exists, uint256 value)
-    {
-        exists = (value = map._values[key]) != uint256(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Bytes32ToUint256Map storage map, bytes32 key)
-        internal
-        view
-        returns (uint256 value)
-    {
-        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Bytes32ToUint256Map storage map) internal view returns (bytes32[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Bytes32ToAddressMap storage map, bytes32 key, address value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Bytes32ToAddressMap storage map, bytes32 key, address value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Bytes32ToAddressMap storage map,
-        bytes32 key,
-        address value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Bytes32ToAddressMap storage map, uint256 i)
-        internal
-        view
-        returns (bytes32 key, address value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Bytes32ToAddressMap storage map, bytes32 key)
-        internal
-        view
-        returns (bool exists, address value)
-    {
-        exists = (value = map._values[key]) != address(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Bytes32ToAddressMap storage map, bytes32 key)
-        internal
-        view
-        returns (address value)
-    {
-        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Uint256ToBytes32Map storage map, uint256 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Uint256ToBytes32Map storage map,
-        uint256 key,
-        bytes32 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Uint256ToBytes32Map storage map, uint256 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Uint256ToBytes32Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Uint256ToBytes32Map storage map, uint256 i)
-        internal
-        view
-        returns (uint256 key, bytes32 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Uint256ToBytes32Map storage map, uint256 key)
-        internal
-        view
-        returns (bool exists, bytes32 value)
-    {
-        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Uint256ToBytes32Map storage map, uint256 key)
-        internal
-        view
-        returns (bytes32 value)
-    {
-        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Uint256ToBytes32Map storage map) internal view returns (uint256[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Uint256ToUint256Map storage map, uint256 key, uint256 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Uint256ToUint256Map storage map, uint256 key, uint256 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Uint256ToUint256Map storage map, uint256 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Uint256ToUint256Map storage map,
-        uint256 key,
-        uint256 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Uint256ToUint256Map storage map, uint256 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Uint256ToUint256Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Uint256ToUint256Map storage map, uint256 i)
-        internal
-        view
-        returns (uint256 key, uint256 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Uint256ToUint256Map storage map, uint256 key)
-        internal
-        view
-        returns (bool exists, uint256 value)
-    {
-        exists = (value = map._values[key]) != uint256(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Uint256ToUint256Map storage map, uint256 key)
-        internal
-        view
-        returns (uint256 value)
-    {
-        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Uint256ToUint256Map storage map) internal view returns (uint256[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(Uint256ToAddressMap storage map, uint256 key, address value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(Uint256ToAddressMap storage map, uint256 key, address value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(Uint256ToAddressMap storage map, uint256 key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        Uint256ToAddressMap storage map,
-        uint256 key,
-        address value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(Uint256ToAddressMap storage map, uint256 key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(Uint256ToAddressMap storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(Uint256ToAddressMap storage map, uint256 i)
-        internal
-        view
-        returns (uint256 key, address value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(Uint256ToAddressMap storage map, uint256 key)
-        internal
-        view
-        returns (bool exists, address value)
-    {
-        exists = (value = map._values[key]) != address(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(Uint256ToAddressMap storage map, uint256 key)
-        internal
-        view
-        returns (address value)
-    {
-        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(Uint256ToAddressMap storage map) internal view returns (uint256[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(AddressToBytes32Map storage map, address key, bytes32 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(AddressToBytes32Map storage map, address key, bytes32 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        AddressToBytes32Map storage map,
-        address key,
-        bytes32 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(AddressToBytes32Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(AddressToBytes32Map storage map, uint256 i)
-        internal
-        view
-        returns (address key, bytes32 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(AddressToBytes32Map storage map, address key)
-        internal
-        view
-        returns (bool exists, bytes32 value)
-    {
-        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(AddressToBytes32Map storage map, address key)
-        internal
-        view
-        returns (bytes32 value)
-    {
-        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(AddressToUint256Map storage map, address key, uint256 value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(AddressToUint256Map storage map, address key, uint256 value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(AddressToUint256Map storage map, address key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        AddressToUint256Map storage map,
-        address key,
-        uint256 value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(AddressToUint256Map storage map, address key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(AddressToUint256Map storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(AddressToUint256Map storage map, uint256 i)
-        internal
-        view
-        returns (address key, uint256 value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(AddressToUint256Map storage map, address key)
-        internal
-        view
-        returns (bool exists, uint256 value)
-    {
-        exists = (value = map._values[key]) != uint256(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(AddressToUint256Map storage map, address key)
-        internal
-        view
-        returns (uint256 value)
-    {
-        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(AddressToUint256Map storage map) internal view returns (address[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    function set(AddressToAddressMap storage map, address key, address value)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key);
-    }
-
-    /// @dev Adds a key-value pair to the map, or updates the value for an existing key.
-    /// Returns true if `key` was added to the map, that is if it was not already present.
-    /// Reverts if the map grows bigger than the custom on-the-fly capacity `cap`.
-    function set(AddressToAddressMap storage map, address key, address value, uint256 cap)
-        internal
-        returns (bool)
-    {
-        map._values[key] = value;
-        return EnumerableSetLib.add(map._keys, key, cap);
-    }
-
-    /// @dev Removes a key-value pair from the map.
-    /// Returns true if `key` was removed from the map, that is if it was present.
-    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {
-        delete map._values[key];
-        return EnumerableSetLib.remove(map._keys, key);
-    }
-
-    /// @dev Shorthand for `isAdd ? map.set(key, value, cap) : map.remove(key)`.
-    function update(
-        AddressToAddressMap storage map,
-        address key,
-        address value,
-        bool isAdd,
-        uint256 cap
-    ) internal returns (bool) {
-        return isAdd ? set(map, key, value, cap) : remove(map, key);
-    }
-
-    /// @dev Returns true if the key is in the map.
-    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {
-        return EnumerableSetLib.contains(map._keys, key);
-    }
-
-    /// @dev Returns the number of key-value pairs in the map.
-    function length(AddressToAddressMap storage map) internal view returns (uint256) {
-        return EnumerableSetLib.length(map._keys);
-    }
-
-    /// @dev Returns the key-value pair at index `i`. Reverts if `i` is out-of-bounds.
-    function at(AddressToAddressMap storage map, uint256 i)
-        internal
-        view
-        returns (address key, address value)
-    {
-        value = map._values[key = EnumerableSetLib.at(map._keys, i)];
-    }
-
-    /// @dev Tries to return the value associated with the key.
-    function tryGet(AddressToAddressMap storage map, address key)
-        internal
-        view
-        returns (bool exists, address value)
-    {
-        exists = (value = map._values[key]) != address(0) || contains(map, key);
-    }
-
-    /// @dev Returns the value for the key. Reverts if the key is not found.
-    function get(AddressToAddressMap storage map, address key)
-        internal
-        view
-        returns (address value)
-    {
-        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();
-    }
-
-    /// @dev Returns the keys. May run out-of-gas if the map is too big.
-    function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {
-        return EnumerableSetLib.values(map._keys);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Reverts with `EnumerableMapKeyNotFound()`.
-    function _revertNotFound() private pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x88682bf3) // `EnumerableMapKeyNotFound()`.
-            revert(0x1c, 0x04)
-        }
-    }
-}
diff --git a/src/utils/g/EnumerableSetLib.sol b/src/utils/g/EnumerableSetLib.sol
deleted file mode 100644
index ac1110a..0000000
--- a/src/utils/g/EnumerableSetLib.sol
+++ /dev/null
@@ -1,822 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev An enumerable address set in storage.
-struct AddressSet {
-    uint256 _spacer;
-}
-
-/// @dev An enumerable bytes32 set in storage.
-struct Bytes32Set {
-    uint256 _spacer;
-}
-
-/// @dev An enumerable uint256 set in storage.
-struct Uint256Set {
-    uint256 _spacer;
-}
-
-/// @dev An enumerable int256 set in storage.
-struct Int256Set {
-    uint256 _spacer;
-}
-
-/// @dev An enumerable uint8 set in storage. Useful for enums.
-struct Uint8Set {
-    uint256 data;
-}
-
-using EnumerableSetLib for AddressSet global;
-using EnumerableSetLib for Bytes32Set global;
-using EnumerableSetLib for Uint256Set global;
-using EnumerableSetLib for Int256Set global;
-using EnumerableSetLib for Uint8Set global;
-
-/// @notice Library for managing enumerable sets in storage.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/EnumerableSetLib.sol)
-///
-/// @dev Note:
-/// In many applications, the number of elements in an enumerable set is small.
-/// This enumerable set implementation avoids storing the length and indices
-/// for up to 3 elements. Once the length exceeds 3 for the first time, the length
-/// and indices will be initialized. The amortized cost of adding elements is O(1).
-///
-/// The AddressSet implementation packs the length with the 0th entry.
-///
-/// All enumerable sets except Uint8Set use a pop and swap mechanism to remove elements.
-/// This means that the iteration order of elements can change between element removals.
-library EnumerableSetLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The index must be less than the length.
-    error IndexOutOfBounds();
-
-    /// @dev The value cannot be the zero sentinel.
-    error ValueIsZeroSentinel();
-
-    /// @dev Cannot accommodate a new unique value with the capacity.
-    error ExceedsCapacity();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev A sentinel value to denote the zero value in storage.
-    /// No elements can be equal to this value.
-    /// `uint72(bytes9(keccak256(bytes("_ZERO_SENTINEL"))))`.
-    uint256 private constant _ZERO_SENTINEL = 0xfbb67fda52d4bfb8bf;
-
-    /// @dev The storage layout is given by:
-    /// ```
-    ///     mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)
-    ///     mstore(0x00, set.slot)
-    ///     let rootSlot := keccak256(0x00, 0x24)
-    ///     mstore(0x20, rootSlot)
-    ///     mstore(0x00, shr(96, shl(96, value)))
-    ///     let positionSlot := keccak256(0x00, 0x40)
-    ///     let valueSlot := add(rootSlot, sload(positionSlot))
-    ///     let valueInStorage := shr(96, sload(valueSlot))
-    ///     let lazyLength := shr(160, shl(160, sload(rootSlot)))
-    /// ```
-    uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED = 0x978aab92;
-
-    /// @dev The storage layout is given by:
-    /// ```
-    ///     mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)
-    ///     mstore(0x00, set.slot)
-    ///     let rootSlot := keccak256(0x00, 0x24)
-    ///     mstore(0x20, rootSlot)
-    ///     mstore(0x00, value)
-    ///     let positionSlot := keccak256(0x00, 0x40)
-    ///     let valueSlot := add(rootSlot, sload(positionSlot))
-    ///     let valueInStorage := sload(valueSlot)
-    ///     let lazyLength := sload(not(rootSlot))
-    /// ```
-    uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED = 0x18fb5864;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     GETTERS / SETTERS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the number of elements in the set.
-    function length(AddressSet storage set) internal view returns (uint256 result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let rootPacked := sload(rootSlot)
-            let n := shr(160, shl(160, rootPacked))
-            result := shr(1, n)
-            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {
-                result := 1
-                if iszero(sload(add(rootSlot, result))) { break }
-                result := 2
-                if iszero(sload(add(rootSlot, result))) { break }
-                result := 3
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the number of elements in the set.
-    function length(Bytes32Set storage set) internal view returns (uint256 result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := sload(not(rootSlot))
-            result := shr(1, n)
-            for {} iszero(n) {} {
-                result := 0
-                if iszero(sload(add(rootSlot, result))) { break }
-                result := 1
-                if iszero(sload(add(rootSlot, result))) { break }
-                result := 2
-                if iszero(sload(add(rootSlot, result))) { break }
-                result := 3
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the number of elements in the set.
-    function length(Uint256Set storage set) internal view returns (uint256 result) {
-        result = length(_toBytes32Set(set));
-    }
-
-    /// @dev Returns the number of elements in the set.
-    function length(Int256Set storage set) internal view returns (uint256 result) {
-        result = length(_toBytes32Set(set));
-    }
-
-    /// @dev Returns the number of elements in the set.
-    function length(Uint8Set storage set) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for { let packed := sload(set.slot) } packed { result := add(1, result) } {
-                packed := xor(packed, and(packed, add(1, not(packed))))
-            }
-        }
-    }
-
-    /// @dev Returns whether `value` is in the set.
-    function contains(AddressSet storage set, address value) internal view returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            value := shr(96, shl(96, value))
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            let rootPacked := sload(rootSlot)
-            for {} 1 {} {
-                if iszero(shr(160, shl(160, rootPacked))) {
-                    result := 1
-                    if eq(shr(96, rootPacked), value) { break }
-                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }
-                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }
-                    result := 0
-                    break
-                }
-                mstore(0x20, rootSlot)
-                mstore(0x00, value)
-                result := iszero(iszero(sload(keccak256(0x00, 0x40))))
-                break
-            }
-        }
-    }
-
-    /// @dev Returns whether `value` is in the set.
-    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            for {} 1 {} {
-                if iszero(sload(not(rootSlot))) {
-                    result := 1
-                    if eq(sload(rootSlot), value) { break }
-                    if eq(sload(add(rootSlot, 1)), value) { break }
-                    if eq(sload(add(rootSlot, 2)), value) { break }
-                    result := 0
-                    break
-                }
-                mstore(0x20, rootSlot)
-                mstore(0x00, value)
-                result := iszero(iszero(sload(keccak256(0x00, 0x40))))
-                break
-            }
-        }
-    }
-
-    /// @dev Returns whether `value` is in the set.
-    function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {
-        result = contains(_toBytes32Set(set), bytes32(value));
-    }
-
-    /// @dev Returns whether `value` is in the set.
-    function contains(Int256Set storage set, int256 value) internal view returns (bool result) {
-        result = contains(_toBytes32Set(set), bytes32(uint256(value)));
-    }
-
-    /// @dev Returns whether `value` is in the set.
-    function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := and(1, shr(and(0xff, value), sload(set.slot)))
-        }
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    function add(AddressSet storage set, address value) internal returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            value := shr(96, shl(96, value))
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            let rootPacked := sload(rootSlot)
-            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {
-                mstore(0x20, rootSlot)
-                if iszero(n) {
-                    let v0 := shr(96, rootPacked)
-                    if iszero(v0) {
-                        sstore(rootSlot, shl(96, value))
-                        result := 1
-                        break
-                    }
-                    if eq(v0, value) { break }
-                    let v1 := shr(96, sload(add(rootSlot, 1)))
-                    if iszero(v1) {
-                        sstore(add(rootSlot, 1), shl(96, value))
-                        result := 1
-                        break
-                    }
-                    if eq(v1, value) { break }
-                    let v2 := shr(96, sload(add(rootSlot, 2)))
-                    if iszero(v2) {
-                        sstore(add(rootSlot, 2), shl(96, value))
-                        result := 1
-                        break
-                    }
-                    if eq(v2, value) { break }
-                    mstore(0x00, v0)
-                    sstore(keccak256(0x00, 0x40), 1)
-                    mstore(0x00, v1)
-                    sstore(keccak256(0x00, 0x40), 2)
-                    mstore(0x00, v2)
-                    sstore(keccak256(0x00, 0x40), 3)
-                    rootPacked := or(rootPacked, 7)
-                    n := 7
-                }
-                mstore(0x00, value)
-                let p := keccak256(0x00, 0x40)
-                if iszero(sload(p)) {
-                    n := shr(1, n)
-                    result := 1
-                    sstore(p, add(1, n))
-                    if iszero(n) {
-                        sstore(rootSlot, or(3, shl(96, value)))
-                        break
-                    }
-                    sstore(add(rootSlot, n), shl(96, value))
-                    sstore(rootSlot, add(2, rootPacked))
-                    break
-                }
-                break
-            }
-        }
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            for { let n := sload(not(rootSlot)) } 1 {} {
-                mstore(0x20, rootSlot)
-                if iszero(n) {
-                    let v0 := sload(rootSlot)
-                    if iszero(v0) {
-                        sstore(rootSlot, value)
-                        result := 1
-                        break
-                    }
-                    if eq(v0, value) { break }
-                    let v1 := sload(add(rootSlot, 1))
-                    if iszero(v1) {
-                        sstore(add(rootSlot, 1), value)
-                        result := 1
-                        break
-                    }
-                    if eq(v1, value) { break }
-                    let v2 := sload(add(rootSlot, 2))
-                    if iszero(v2) {
-                        sstore(add(rootSlot, 2), value)
-                        result := 1
-                        break
-                    }
-                    if eq(v2, value) { break }
-                    mstore(0x00, v0)
-                    sstore(keccak256(0x00, 0x40), 1)
-                    mstore(0x00, v1)
-                    sstore(keccak256(0x00, 0x40), 2)
-                    mstore(0x00, v2)
-                    sstore(keccak256(0x00, 0x40), 3)
-                    n := 7
-                }
-                mstore(0x00, value)
-                let p := keccak256(0x00, 0x40)
-                if iszero(sload(p)) {
-                    n := shr(1, n)
-                    sstore(add(rootSlot, n), value)
-                    sstore(p, add(1, n))
-                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))
-                    result := 1
-                    break
-                }
-                break
-            }
-        }
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    function add(Uint256Set storage set, uint256 value) internal returns (bool result) {
-        result = add(_toBytes32Set(set), bytes32(value));
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    function add(Int256Set storage set, int256 value) internal returns (bool result) {
-        result = add(_toBytes32Set(set), bytes32(uint256(value)));
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    function add(Uint8Set storage set, uint8 value) internal returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := sload(set.slot)
-            let mask := shl(and(0xff, value), 1)
-            sstore(set.slot, or(result, mask))
-            result := iszero(and(result, mask))
-        }
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.
-    function add(AddressSet storage set, address value, uint256 cap)
-        internal
-        returns (bool result)
-    {
-        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.
-    function add(Bytes32Set storage set, bytes32 value, uint256 cap)
-        internal
-        returns (bool result)
-    {
-        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.
-    function add(Uint256Set storage set, uint256 value, uint256 cap)
-        internal
-        returns (bool result)
-    {
-        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.
-    function add(Int256Set storage set, int256 value, uint256 cap) internal returns (bool result) {
-        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();
-    }
-
-    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.
-    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.
-    function add(Uint8Set storage set, uint8 value, uint256 cap) internal returns (bool result) {
-        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();
-    }
-
-    /// @dev Removes `value` from the set. Returns whether `value` was in the set.
-    function remove(AddressSet storage set, address value) internal returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            value := shr(96, shl(96, value))
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            let rootPacked := sload(rootSlot)
-            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {
-                if iszero(n) {
-                    result := 1
-                    if eq(shr(96, rootPacked), value) {
-                        sstore(rootSlot, sload(add(rootSlot, 1)))
-                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    if eq(shr(96, sload(add(rootSlot, 1))), value) {
-                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    if eq(shr(96, sload(add(rootSlot, 2))), value) {
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    result := 0
-                    break
-                }
-                mstore(0x20, rootSlot)
-                mstore(0x00, value)
-                let p := keccak256(0x00, 0x40)
-                let position := sload(p)
-                if iszero(position) { break }
-                n := sub(shr(1, n), 1)
-                if iszero(eq(sub(position, 1), n)) {
-                    let lastValue := shr(96, sload(add(rootSlot, n)))
-                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))
-                    mstore(0x00, lastValue)
-                    sstore(keccak256(0x00, 0x40), position)
-                }
-                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))
-                sstore(p, 0)
-                result := 1
-                break
-            }
-        }
-    }
-
-    /// @dev Removes `value` from the set. Returns whether `value` was in the set.
-    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            if eq(value, _ZERO_SENTINEL) {
-                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(value) { value := _ZERO_SENTINEL }
-            for { let n := sload(not(rootSlot)) } 1 {} {
-                if iszero(n) {
-                    result := 1
-                    if eq(sload(rootSlot), value) {
-                        sstore(rootSlot, sload(add(rootSlot, 1)))
-                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    if eq(sload(add(rootSlot, 1)), value) {
-                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    if eq(sload(add(rootSlot, 2)), value) {
-                        sstore(add(rootSlot, 2), 0)
-                        break
-                    }
-                    result := 0
-                    break
-                }
-                mstore(0x20, rootSlot)
-                mstore(0x00, value)
-                let p := keccak256(0x00, 0x40)
-                let position := sload(p)
-                if iszero(position) { break }
-                n := sub(shr(1, n), 1)
-                if iszero(eq(sub(position, 1), n)) {
-                    let lastValue := sload(add(rootSlot, n))
-                    sstore(add(rootSlot, sub(position, 1)), lastValue)
-                    mstore(0x00, lastValue)
-                    sstore(keccak256(0x00, 0x40), position)
-                }
-                sstore(not(rootSlot), or(shl(1, n), 1))
-                sstore(p, 0)
-                result := 1
-                break
-            }
-        }
-    }
-
-    /// @dev Removes `value` from the set. Returns whether `value` was in the set.
-    function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {
-        result = remove(_toBytes32Set(set), bytes32(value));
-    }
-
-    /// @dev Removes `value` from the set. Returns whether `value` was in the set.
-    function remove(Int256Set storage set, int256 value) internal returns (bool result) {
-        result = remove(_toBytes32Set(set), bytes32(uint256(value)));
-    }
-
-    /// @dev Removes `value` from the set. Returns whether `value` was in the set.
-    function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := sload(set.slot)
-            let mask := shl(and(0xff, value), 1)
-            sstore(set.slot, and(result, not(mask)))
-            result := iszero(iszero(and(result, mask)))
-        }
-    }
-
-    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.
-    function update(AddressSet storage set, address value, bool isAdd, uint256 cap)
-        internal
-        returns (bool)
-    {
-        return isAdd ? add(set, value, cap) : remove(set, value);
-    }
-
-    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.
-    function update(Bytes32Set storage set, bytes32 value, bool isAdd, uint256 cap)
-        internal
-        returns (bool)
-    {
-        return isAdd ? add(set, value, cap) : remove(set, value);
-    }
-
-    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.
-    function update(Uint256Set storage set, uint256 value, bool isAdd, uint256 cap)
-        internal
-        returns (bool)
-    {
-        return isAdd ? add(set, value, cap) : remove(set, value);
-    }
-
-    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.
-    function update(Int256Set storage set, int256 value, bool isAdd, uint256 cap)
-        internal
-        returns (bool)
-    {
-        return isAdd ? add(set, value, cap) : remove(set, value);
-    }
-
-    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.
-    function update(Uint8Set storage set, uint8 value, bool isAdd, uint256 cap)
-        internal
-        returns (bool)
-    {
-        return isAdd ? add(set, value, cap) : remove(set, value);
-    }
-
-    /// @dev Returns all of the values in the set.
-    /// Note: This can consume more gas than the block gas limit for large sets.
-    function values(AddressSet storage set) internal view returns (address[] memory result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let zs := _ZERO_SENTINEL
-            let rootPacked := sload(rootSlot)
-            let n := shr(160, shl(160, rootPacked))
-            result := mload(0x40)
-            let o := add(0x20, result)
-            let v := shr(96, rootPacked)
-            mstore(o, mul(v, iszero(eq(v, zs))))
-            for {} 1 {} {
-                if iszero(n) {
-                    if v {
-                        n := 1
-                        v := shr(96, sload(add(rootSlot, n)))
-                        if v {
-                            n := 2
-                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))
-                            v := shr(96, sload(add(rootSlot, n)))
-                            if v {
-                                n := 3
-                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))
-                            }
-                        }
-                    }
-                    break
-                }
-                n := shr(1, n)
-                for { let i := 1 } lt(i, n) { i := add(i, 1) } {
-                    v := shr(96, sload(add(rootSlot, i)))
-                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))
-                }
-                break
-            }
-            mstore(result, n)
-            mstore(0x40, add(o, shl(5, n)))
-        }
-    }
-
-    /// @dev Returns all of the values in the set.
-    /// Note: This can consume more gas than the block gas limit for large sets.
-    function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let zs := _ZERO_SENTINEL
-            let n := sload(not(rootSlot))
-            result := mload(0x40)
-            let o := add(0x20, result)
-            for {} 1 {} {
-                if iszero(n) {
-                    let v := sload(rootSlot)
-                    if v {
-                        n := 1
-                        mstore(o, mul(v, iszero(eq(v, zs))))
-                        v := sload(add(rootSlot, n))
-                        if v {
-                            n := 2
-                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))
-                            v := sload(add(rootSlot, n))
-                            if v {
-                                n := 3
-                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))
-                            }
-                        }
-                    }
-                    break
-                }
-                n := shr(1, n)
-                for { let i := 0 } lt(i, n) { i := add(i, 1) } {
-                    let v := sload(add(rootSlot, i))
-                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))
-                }
-                break
-            }
-            mstore(result, n)
-            mstore(0x40, add(o, shl(5, n)))
-        }
-    }
-
-    /// @dev Returns all of the values in the set.
-    /// Note: This can consume more gas than the block gas limit for large sets.
-    function values(Uint256Set storage set) internal view returns (uint256[] memory result) {
-        result = _toUints(values(_toBytes32Set(set)));
-    }
-
-    /// @dev Returns all of the values in the set.
-    /// Note: This can consume more gas than the block gas limit for large sets.
-    function values(Int256Set storage set) internal view returns (int256[] memory result) {
-        result = _toInts(values(_toBytes32Set(set)));
-    }
-
-    /// @dev Returns all of the values in the set.
-    function values(Uint8Set storage set) internal view returns (uint8[] memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let ptr := add(result, 0x20)
-            let o := 0
-            for { let packed := sload(set.slot) } packed {} {
-                if iszero(and(packed, 0xffff)) {
-                    o := add(o, 16)
-                    packed := shr(16, packed)
-                    continue
-                }
-                mstore(ptr, o)
-                ptr := add(ptr, shl(5, and(packed, 1)))
-                o := add(o, 1)
-                packed := shr(1, packed)
-            }
-            mstore(result, shr(5, sub(ptr, add(result, 0x20))))
-            mstore(0x40, ptr)
-        }
-    }
-
-    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.
-    function at(AddressSet storage set, uint256 i) internal view returns (address result) {
-        bytes32 rootSlot = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(96, sload(add(rootSlot, i)))
-            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))
-        }
-        if (i >= length(set)) revert IndexOutOfBounds();
-    }
-
-    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.
-    function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {
-        result = _rootSlot(set);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := sload(add(result, i))
-            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))
-        }
-        if (i >= length(set)) revert IndexOutOfBounds();
-    }
-
-    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.
-    function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {
-        result = uint256(at(_toBytes32Set(set), i));
-    }
-
-    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.
-    function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {
-        result = int256(uint256(at(_toBytes32Set(set), i)));
-    }
-
-    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.
-    function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let packed := sload(set.slot)
-            for {} 1 {
-                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.
-                revert(0x1c, 0x04)
-            } {
-                if iszero(lt(i, 256)) { continue }
-                for { let j := 0 } iszero(eq(i, j)) {} {
-                    packed := xor(packed, and(packed, add(1, not(packed))))
-                    j := add(j, 1)
-                }
-                if iszero(packed) { continue }
-                break
-            }
-            // Find first set subroutine, optimized for smaller bytecode size.
-            let x := and(packed, add(1, not(packed)))
-            let r := shl(7, iszero(iszero(shr(128, x))))
-            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))
-            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
-            // For the lower 5 bits of the result, use a De Bruijn lookup.
-            // forgefmt: disable-next-item
-            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),
-                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the root slot.
-    function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)
-            mstore(0x00, s.slot)
-            r := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns the root slot.
-    function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)
-            mstore(0x00, s.slot)
-            r := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Casts to a Bytes32Set.
-    function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            c.slot := s.slot
-        }
-    }
-
-    /// @dev Casts to a Bytes32Set.
-    function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            c.slot := s.slot
-        }
-    }
-
-    /// @dev Casts to a uint256 array.
-    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            c := a
-        }
-    }
-
-    /// @dev Casts to a int256 array.
-    function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            c := a
-        }
-    }
-}
diff --git a/src/utils/g/JSONParserLib.sol b/src/utils/g/JSONParserLib.sol
deleted file mode 100644
index 6a3faed..0000000
--- a/src/utils/g/JSONParserLib.sol
+++ /dev/null
@@ -1,819 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A pointer to a parsed JSON node.
-struct Item {
-    // Do NOT modify the `_data` directly.
-    uint256 _data;
-}
-
-using JSONParserLib for Item global;
-
-/// @notice Library for parsing JSONs.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/JSONParserLib.sol)
-library JSONParserLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The input is invalid.
-    error ParsingFailed();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // There are 6 types of variables in JSON (excluding undefined).
-
-    /// @dev For denoting that an item has not been initialized.
-    /// A item returned from `parse` will never be of an undefined type.
-    /// Parsing an invalid JSON string will simply revert.
-    uint8 internal constant TYPE_UNDEFINED = 0;
-
-    /// @dev Type representing an array (e.g. `[1,2,3]`).
-    uint8 internal constant TYPE_ARRAY = 1;
-
-    /// @dev Type representing an object (e.g. `{"a":"A","b":"B"}`).
-    uint8 internal constant TYPE_OBJECT = 2;
-
-    /// @dev Type representing a number (e.g. `-1.23e+21`).
-    uint8 internal constant TYPE_NUMBER = 3;
-
-    /// @dev Type representing a string (e.g. `"hello"`).
-    uint8 internal constant TYPE_STRING = 4;
-
-    /// @dev Type representing a boolean (i.e. `true` or `false`).
-    uint8 internal constant TYPE_BOOLEAN = 5;
-
-    /// @dev Type representing null (i.e. `null`).
-    uint8 internal constant TYPE_NULL = 6;
-
-    // Private constants for packing `_data`.
-
-    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;
-    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;
-    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;
-    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;
-    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;
-    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;
-    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;
-    uint256 private constant _BITMASK_POINTER = 0xffffffff;
-    uint256 private constant _BITMASK_TYPE = 7;
-    uint256 private constant _KEY_INITED = 1 << 3;
-    uint256 private constant _VALUE_INITED = 1 << 4;
-    uint256 private constant _CHILDREN_INITED = 1 << 5;
-    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;
-    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                   JSON PARSING OPERATION                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Parses the JSON string `s`, and returns the root.
-    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.
-    /// Object items WILL simply contain all their children, inclusive of repeated keys,
-    /// in the same order which they appear in the JSON string.
-    ///
-    /// Note: For efficiency, this function WILL NOT make a copy of `s`.
-    /// The parsed tree WILL contain offsets to `s`.
-    /// Do NOT pass in a string that WILL be modified later on.
-    function parse(string memory s) internal pure returns (Item memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // We will use our own allocation instead.
-        }
-        bytes32 r = _query(_toInput(s), 255);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := r
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                    JSON ITEM OPERATIONS                    */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Note:
-    // - An item is a node in the JSON tree.
-    // - The value of a string item WILL be double-quoted, JSON encoded.
-    // - We make a distinction between `index` and `key`.
-    //   - Items in arrays are located by `index` (uint256).
-    //   - Items in objects are located by `key` (string).
-    // - Keys are always strings, double-quoted, JSON encoded.
-    //
-    // These design choices are made to balance between efficiency and ease-of-use.
-
-    /// @dev Returns the string value of the item.
-    /// This is its exact string representation in the original JSON string.
-    /// The returned string WILL have leading and trailing whitespace trimmed.
-    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.
-    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.
-    ///
-    /// Note: This function lazily instantiates and caches the returned string.
-    /// Do NOT modify the returned string.
-    function value(Item memory item) internal pure returns (string memory result) {
-        bytes32 r = _query(_toInput(item), 0);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := r
-        }
-    }
-
-    /// @dev Returns the index of the item in the array.
-    /// It the item's parent is not an array, returns 0.
-    function index(Item memory item) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if and(mload(item), _PARENT_IS_ARRAY) {
-                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))
-            }
-        }
-    }
-
-    /// @dev Returns the key of the item in the object.
-    /// It the item's parent is not an object, returns an empty string.
-    /// The returned string WILL be double-quoted, JSON encoded.
-    ///
-    /// Note: This function lazily instantiates and caches the returned string.
-    /// Do NOT modify the returned string.
-    function key(Item memory item) internal pure returns (string memory result) {
-        if (item._data & _PARENT_IS_OBJECT != 0) {
-            bytes32 r = _query(_toInput(item), 1);
-            /// @solidity memory-safe-assembly
-            assembly {
-                result := r
-            }
-        }
-    }
-
-    /// @dev Returns the key of the item in the object.
-    /// It the item is neither an array nor object, returns an empty array.
-    ///
-    /// Note: This function lazily instantiates and caches the returned array.
-    /// Do NOT modify the returned array.
-    function children(Item memory item) internal pure returns (Item[] memory result) {
-        bytes32 r = _query(_toInput(item), 3);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := r
-        }
-    }
-
-    /// @dev Returns the number of children.
-    /// It the item is neither an array nor object, returns zero.
-    function size(Item memory item) internal pure returns (uint256 result) {
-        bytes32 r = _query(_toInput(item), 3);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(r)
-        }
-    }
-
-    /// @dev Returns the item at index `i` for (array).
-    /// If `item` is not an array, the result's type WILL be undefined.
-    /// If there is no item with the index, the result's type WILL be undefined.
-    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // Free the default allocation. We'll allocate manually.
-        }
-        bytes32 r = _query(_toInput(item), 3);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(r, 0x20), shl(5, i)))
-            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {
-                result := 0x60 // Reset to the zero pointer.
-            }
-        }
-    }
-
-    /// @dev Returns the item at key `k` for (object).
-    /// If `item` is not an object, the result's type WILL be undefined.
-    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.
-    /// - Correct : `item.at('"k"')`.
-    /// - Wrong   : `item.at("k")`.
-    /// For duplicated keys, the last item with the key WILL be returned.
-    /// If there is no item with the key, the result's type WILL be undefined.
-    function at(Item memory item, string memory k) internal pure returns (Item memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // Free the default allocation. We'll allocate manually.
-            result := 0x60 // Initialize to the zero pointer.
-        }
-        if (isObject(item)) {
-            bytes32 kHash = keccak256(bytes(k));
-            Item[] memory r = children(item);
-            // We'll just do a linear search. The alternatives are very bloated.
-            for (uint256 i = r.length << 5; i != 0;) {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    item := mload(add(r, i))
-                    i := sub(i, 0x20)
-                }
-                if (keccak256(bytes(key(item))) != kHash) continue;
-                result = item;
-                break;
-            }
-        }
-    }
-
-    /// @dev Returns the item's type.
-    function getType(Item memory item) internal pure returns (uint8 result) {
-        result = uint8(item._data & _BITMASK_TYPE);
-    }
-
-    /// Note: All types are mutually exclusive.
-
-    /// @dev Returns whether the item is of type undefined.
-    function isUndefined(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;
-    }
-
-    /// @dev Returns whether the item is of type array.
-    function isArray(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;
-    }
-
-    /// @dev Returns whether the item is of type object.
-    function isObject(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;
-    }
-
-    /// @dev Returns whether the item is of type number.
-    function isNumber(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;
-    }
-
-    /// @dev Returns whether the item is of type string.
-    function isString(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_STRING;
-    }
-
-    /// @dev Returns whether the item is of type boolean.
-    function isBoolean(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;
-    }
-
-    /// @dev Returns whether the item is of type null.
-    function isNull(Item memory item) internal pure returns (bool result) {
-        result = item._data & _BITMASK_TYPE == TYPE_NULL;
-    }
-
-    /// @dev Returns the item's parent.
-    /// If the item does not have a parent, the result's type will be undefined.
-    function parent(Item memory item) internal pure returns (Item memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x40, result) // Free the default allocation. We've already allocated.
-            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)
-            if iszero(result) { result := 0x60 } // Reset to the zero pointer.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     UTILITY FUNCTIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).
-    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,
-    /// or if the parsed number is too big for a uint256.
-    function parseUint(string memory s) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(s)
-            let preMulOverflowThres := div(not(0), 10)
-            for { let i := 0 } 1 {} {
-                i := add(i, 1)
-                let digit := sub(and(mload(add(s, i)), 0xff), 48)
-                let mulOverflowed := gt(result, preMulOverflowThres)
-                let product := mul(10, result)
-                result := add(product, digit)
-                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))
-                if iszero(lt(i, n)) { break }
-            }
-            if iszero(n) {
-                mstore(0x00, 0x10182796) // `ParsingFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).
-    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,
-    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.
-    function parseInt(string memory s) internal pure returns (int256 result) {
-        uint256 n = bytes(s).length;
-        uint256 sign;
-        uint256 isNegative;
-        /// @solidity memory-safe-assembly
-        assembly {
-            if n {
-                let c := and(mload(add(s, 1)), 0xff)
-                isNegative := eq(c, 45)
-                if or(eq(c, 43), isNegative) {
-                    sign := c
-                    s := add(s, 1)
-                    mstore(s, sub(n, 1))
-                }
-                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }
-            }
-        }
-        uint256 x = parseUint(s);
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(lt(x, add(shl(255, 1), isNegative))) {
-                mstore(0x00, 0x10182796) // `ParsingFailed()`.
-                revert(0x1c, 0x04)
-            }
-            if sign {
-                mstore(s, sign)
-                s := sub(s, 1)
-                mstore(s, n)
-            }
-            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))
-        }
-    }
-
-    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).
-    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx
-    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.
-    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(s)
-            // Skip two if starts with '0x' or '0X'.
-            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))
-            for {} 1 {} {
-                i := add(i, 1)
-                let c :=
-                    byte(
-                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),
-                        0x3010a071000000b0104040208000c05090d060e0f
-                    )
-                n := mul(n, iszero(or(iszero(c), shr(252, result))))
-                result := add(shl(4, result), sub(c, 1))
-                if iszero(lt(i, n)) { break }
-            }
-            if iszero(n) {
-                mstore(0x00, 0x10182796) // `ParsingFailed()`.
-                revert(0x1c, 0x04)
-            }
-        }
-    }
-
-    /// @dev Decodes a JSON encoded string.
-    /// The string MUST be double-quoted, JSON encoded.
-    /// Reverts if the string is invalid.
-    /// As you can see, it's pretty complex for a deceptively simple looking task.
-    function decodeString(string memory s) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function fail() {
-                mstore(0x00, 0x10182796) // `ParsingFailed()`.
-                revert(0x1c, 0x04)
-            }
-
-            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {
-                _pOut := add(pIn_, 4)
-                let b_ := iszero(gt(_pOut, end_))
-                let t_ := mload(pIn_) // Load the whole word.
-                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {
-                    let c_ := sub(byte(i_, t_), 48)
-                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.
-                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))
-                    _unicode := add(shl(4, _unicode), c_)
-                }
-            }
-
-            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {
-                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)
-                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {
-                    let t_ := mload(_pOut) // Load the whole word.
-                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\u'.
-                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)
-                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))
-                }
-            }
-
-            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {
-                if iszero(gt(c_, 0x7f)) {
-                    mstore8(pIn_, c_)
-                    _pOut := add(pIn_, 1)
-                    leave
-                }
-                mstore8(0x1f, c_)
-                mstore8(0x1e, shr(6, c_))
-                if iszero(gt(c_, 0x7ff)) {
-                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))
-                    _pOut := add(pIn_, 2)
-                    leave
-                }
-                mstore8(0x1d, shr(12, c_))
-                if iszero(gt(c_, 0xffff)) {
-                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))
-                    _pOut := add(pIn_, 3)
-                    leave
-                }
-                mstore8(0x1c, shr(18, c_))
-                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))
-                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))
-            }
-
-            function chr(p_) -> _c {
-                _c := byte(0, mload(p_))
-            }
-
-            let n := mload(s)
-            let end := add(add(s, n), 0x1f)
-            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {
-                fail() // Fail if not double-quoted.
-            }
-            let out := add(mload(0x40), 0x20)
-            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {
-                let c := chr(curr)
-                curr := add(curr, 1)
-                // Not '\\'.
-                if iszero(eq(c, 92)) {
-                    // Not '"'.
-                    if iszero(eq(c, 34)) {
-                        mstore8(out, c)
-                        out := add(out, 1)
-                        continue
-                    }
-                    curr := end
-                }
-                if iszero(eq(curr, end)) {
-                    let escape := chr(curr)
-                    curr := add(curr, 1)
-                    // '"', '/', '\\'.
-                    if and(shr(escape, 0x100000000000800400000000), 1) {
-                        mstore8(out, escape)
-                        out := add(out, 1)
-                        continue
-                    }
-                    // 'u'.
-                    if eq(escape, 117) {
-                        escape, curr := decodeUnicodeCodePoint(curr, end)
-                        out := appendCodePointAsUTF8(out, escape)
-                        continue
-                    }
-                    // `{'b':'\b', 'f':'\f', 'n':'\n', 'r':'\r', 't':'\t'}`.
-                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)
-                    if escape {
-                        mstore8(out, escape)
-                        out := add(out, 1)
-                        continue
-                    }
-                }
-                fail()
-                break
-            }
-            mstore(out, 0) // Zeroize the last slot.
-            result := mload(0x40)
-            mstore(result, sub(out, add(result, 0x20))) // Store the length.
-            mstore(0x40, add(out, 0x20)) // Allocate the memory.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Performs a query on the input with the given mode.
-    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function fail() {
-                mstore(0x00, 0x10182796) // `ParsingFailed()`.
-                revert(0x1c, 0x04)
-            }
-
-            function chr(p_) -> _c {
-                _c := byte(0, mload(p_))
-            }
-
-            function skipWhitespace(pIn_, end_) -> _pOut {
-                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {
-                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \n\r\t'.
-                }
-            }
-
-            function setP(packed_, bitpos_, p_) -> _packed {
-                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.
-                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))
-                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))
-            }
-
-            function getP(packed_, bitpos_) -> _p {
-                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))
-            }
-
-            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {
-                _item := mload(0x40)
-                // forgefmt: disable-next-item
-                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),
-                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))
-                mstore(_item, or(packed_, type_))
-                mstore(0x40, add(_item, 0x20)) // Allocate memory.
-            }
-
-            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {
-                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)
-                _pOut := skipWhitespace(pIn_, end_)
-                if iszero(lt(_pOut, end_)) { leave }
-                for { let c_ := chr(_pOut) } 1 {} {
-                    // If starts with '"'.
-                    if eq(c_, 34) {
-                        let pStart_ := _pOut
-                        _pOut := parseStringSub(s_, packed_, _pOut, end_)
-                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)
-                        break
-                    }
-                    // If starts with '['.
-                    if eq(c_, 91) {
-                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)
-                        break
-                    }
-                    // If starts with '{'.
-                    if eq(c_, 123) {
-                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)
-                        break
-                    }
-                    // If starts with any in '0123456789-'.
-                    if and(shr(c_, shl(45, 0x1ff9)), 1) {
-                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)
-                        break
-                    }
-                    if iszero(gt(add(_pOut, 4), end_)) {
-                        let pStart_ := _pOut
-                        let w_ := shr(224, mload(_pOut))
-                        // 'true' in hex format.
-                        if eq(w_, 0x74727565) {
-                            _pOut := add(_pOut, 4)
-                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)
-                            break
-                        }
-                        // 'null' in hex format.
-                        if eq(w_, 0x6e756c6c) {
-                            _pOut := add(_pOut, 4)
-                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)
-                            break
-                        }
-                    }
-                    if iszero(gt(add(_pOut, 5), end_)) {
-                        let pStart_ := _pOut
-                        let w_ := shr(216, mload(_pOut))
-                        // 'false' in hex format.
-                        if eq(w_, 0x66616c7365) {
-                            _pOut := add(_pOut, 5)
-                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)
-                            break
-                        }
-                    }
-                    fail()
-                    break
-                }
-                _pOut := skipWhitespace(_pOut, end_)
-            }
-
-            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {
-                let j_ := 0
-                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {
-                    if iszero(lt(_pOut, end_)) { fail() }
-                    if iszero(_item) {
-                        _pOut := skipWhitespace(_pOut, end_)
-                        if eq(chr(_pOut), 93) { break } // ']'.
-                    }
-                    _item, _pOut := parseValue(s_, _item, _pOut, end_)
-                    if _item {
-                        // forgefmt: disable-next-item
-                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),
-                            _BITPOS_KEY, j_))
-                        j_ := add(j_, 1)
-                        let c_ := chr(_pOut)
-                        if eq(c_, 93) { break } // ']'.
-                        if eq(c_, 44) { continue } // ','.
-                    }
-                    _pOut := end_
-                }
-                _pOut := add(_pOut, 1)
-                packed_ := setP(packed_, _BITPOS_CHILD, _item)
-                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)
-            }
-
-            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {
-                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {
-                    if iszero(lt(_pOut, end_)) { fail() }
-                    if iszero(_item) {
-                        _pOut := skipWhitespace(_pOut, end_)
-                        if eq(chr(_pOut), 125) { break } // '}'.
-                    }
-                    _pOut := skipWhitespace(_pOut, end_)
-                    let pKeyStart_ := _pOut
-                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)
-                    _pOut := skipWhitespace(pKeyEnd_, end_)
-                    // If ':'.
-                    if eq(chr(_pOut), 58) {
-                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)
-                        if _item {
-                            // forgefmt: disable-next-item
-                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),
-                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),
-                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))
-                            let c_ := chr(_pOut)
-                            if eq(c_, 125) { break } // '}'.
-                            if eq(c_, 44) { continue } // ','.
-                        }
-                    }
-                    _pOut := end_
-                }
-                _pOut := add(_pOut, 1)
-                packed_ := setP(packed_, _BITPOS_CHILD, _item)
-                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)
-            }
-
-            function checkStringU(p_, o_) {
-                // If not in '0123456789abcdefABCDEF', revert.
-                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }
-                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }
-            }
-
-            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {
-                if iszero(lt(pIn_, end_)) { fail() }
-                for { _pOut := add(pIn_, 1) } 1 {} {
-                    let c_ := chr(_pOut)
-                    if eq(c_, 34) { break } // '"'.
-                    // Not '\'.
-                    if iszero(eq(c_, 92)) {
-                        _pOut := add(_pOut, 1)
-                        continue
-                    }
-                    c_ := chr(add(_pOut, 1))
-                    // '"', '\', '//', 'b', 'f', 'n', 'r', 't'.
-                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {
-                        _pOut := add(_pOut, 2)
-                        continue
-                    }
-                    // 'u'.
-                    if eq(c_, 117) {
-                        checkStringU(_pOut, 2)
-                        _pOut := add(_pOut, 6)
-                        continue
-                    }
-                    _pOut := end_
-                    break
-                }
-                if iszero(lt(_pOut, end_)) { fail() }
-                _pOut := add(_pOut, 1)
-            }
-
-            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {
-                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {
-                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.
-                }
-                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }
-            }
-
-            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {
-                _pOut := pIn_
-                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.
-                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.
-                let c_ := chr(_pOut)
-                _pOut := add(_pOut, 1)
-                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.
-                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.
-                let t_ := mload(_pOut)
-                // 'E', 'e'.
-                if eq(or(0x20, byte(0, t_)), 101) {
-                    // forgefmt: disable-next-item
-                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.
-                        add(_pOut, 1)), end_, 1)
-                }
-                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)
-            }
-
-            function copyStr(s_, offset_, len_) -> _sCopy {
-                _sCopy := mload(0x40)
-                s_ := add(s_, offset_)
-                let w_ := not(0x1f)
-                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {
-                    mstore(add(_sCopy, i_), mload(add(s_, i_)))
-                    i_ := add(i_, w_) // `sub(i_, 0x20)`.
-                    if iszero(i_) { break }
-                }
-                mstore(_sCopy, len_) // Copy the length.
-                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.
-                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.
-            }
-
-            function value(item_) -> _value {
-                let packed_ := mload(item_)
-                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.
-                if iszero(and(_VALUE_INITED, packed_)) {
-                    let s_ := getP(packed_, _BITPOS_STRING)
-                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))
-                    packed_ := setP(packed_, _BITPOS_VALUE, _value)
-                    mstore(s_, or(_VALUE_INITED, packed_))
-                }
-            }
-
-            function children(item_) -> _arr {
-                _arr := 0x60 // Initialize to the zero pointer.
-                let packed_ := mload(item_)
-                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {
-                    if or(iszero(packed_), iszero(item_)) { break }
-                    if and(packed_, _CHILDREN_INITED) {
-                        _arr := getP(packed_, _BITPOS_CHILD)
-                        break
-                    }
-                    _arr := mload(0x40)
-                    let o_ := add(_arr, 0x20)
-                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {
-                        mstore(o_, h_)
-                        let q_ := mload(h_)
-                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)
-                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))
-                        h_ := y_
-                        o_ := add(o_, 0x20)
-                    }
-                    let w_ := not(0x1f)
-                    let n_ := add(w_, sub(o_, _arr))
-                    mstore(_arr, shr(5, n_))
-                    mstore(0x40, o_) // Allocate memory.
-                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)
-                    mstore(item_, or(_CHILDREN_INITED, packed_))
-                    // Reverse the array.
-                    if iszero(lt(n_, 0x40)) {
-                        let lo_ := add(_arr, 0x20)
-                        let hi_ := add(_arr, n_)
-                        for {} 1 {} {
-                            let temp_ := mload(lo_)
-                            mstore(lo_, mload(hi_))
-                            mstore(hi_, temp_)
-                            hi_ := add(hi_, w_)
-                            lo_ := add(lo_, 0x20)
-                            if iszero(lt(lo_, hi_)) { break }
-                        }
-                    }
-                    break
-                }
-            }
-
-            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {
-                _result := 0x60 // Initialize to the zero pointer.
-                let packed_ := mload(item_)
-                if or(iszero(item_), iszero(packed_)) { leave }
-                _result := getP(packed_, bitpos_)
-                if iszero(and(bitmaskInited_, packed_)) {
-                    let s_ := getP(packed_, _BITPOS_STRING)
-                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))
-                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))
-                }
-            }
-
-            switch mode
-            // Get value.
-            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }
-            // Get key.
-            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }
-            // Get children.
-            case 3 { result := children(input) }
-            // Parse.
-            default {
-                let p := add(input, 0x20)
-                let e := add(p, mload(input))
-                if iszero(eq(p, e)) {
-                    let c := chr(e)
-                    mstore8(e, 34) // Place a '"' at the end to speed up parsing.
-                    // The `34 << 248` makes `mallocItem` preserve '"' at the end.
-                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))
-                    result, p := parseValue(input, 0, p, e)
-                    mstore8(e, c) // Restore the original char at the end.
-                }
-                if or(lt(p, e), iszero(result)) { fail() }
-            }
-        }
-    }
-
-    /// @dev Casts the input to a bytes32.
-    function _toInput(string memory input) private pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := input
-        }
-    }
-
-    /// @dev Casts the input to a bytes32.
-    function _toInput(Item memory input) private pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := input
-        }
-    }
-}
diff --git a/src/utils/g/LibBitmap.sol b/src/utils/g/LibBitmap.sol
deleted file mode 100644
index 91af771..0000000
--- a/src/utils/g/LibBitmap.sol
+++ /dev/null
@@ -1,240 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A bitmap in storage.
-struct Bitmap {
-    mapping(uint256 => uint256) map;
-}
-
-using LibBitmap for Bitmap global;
-
-import {LibBit} from "../LibBit.sol";
-
-/// @notice Library for storage of packed unsigned booleans.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibBitmap.sol)
-/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)
-/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)
-library LibBitmap {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The constant returned when a bitmap scan does not find a result.
-    uint256 internal constant NOT_FOUND = type(uint256).max;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.
-    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {
-        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.
-        // Both cost the same amount of gas, but the former allows the returned value
-        // to be reused without cleaning the upper bits.
-        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;
-        /// @solidity memory-safe-assembly
-        assembly {
-            isSet := b
-        }
-    }
-
-    /// @dev Updates the bit at `index` in `bitmap` to true.
-    function set(Bitmap storage bitmap, uint256 index) internal {
-        bitmap.map[index >> 8] |= (1 << (index & 0xff));
-    }
-
-    /// @dev Updates the bit at `index` in `bitmap` to false.
-    function unset(Bitmap storage bitmap, uint256 index) internal {
-        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));
-    }
-
-    /// @dev Flips the bit at `index` in `bitmap`.
-    /// Returns the boolean result of the flipped bit.
-    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, bitmap.slot)
-            mstore(0x00, shr(8, index))
-            let storageSlot := keccak256(0x00, 0x40)
-            let shift := and(index, 0xff)
-            let storageValue := xor(sload(storageSlot), shl(shift, 1))
-            // It makes sense to return the `newIsSet`,
-            // as it allow us to skip an additional warm `sload`,
-            // and it costs minimal gas (about 15),
-            // which may be optimized away if the returned value is unused.
-            newIsSet := and(1, shr(shift, storageValue))
-            sstore(storageSlot, storageValue)
-        }
-    }
-
-    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.
-    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, bitmap.slot)
-            mstore(0x00, shr(8, index))
-            let storageSlot := keccak256(0x00, 0x40)
-            let storageValue := sload(storageSlot)
-            let shift := and(index, 0xff)
-            sstore(
-                storageSlot,
-                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.
-                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))
-            )
-        }
-    }
-
-    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.
-    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let max := not(0)
-            let shift := and(start, 0xff)
-            mstore(0x20, bitmap.slot)
-            mstore(0x00, shr(8, start))
-            if iszero(lt(add(shift, amount), 257)) {
-                let storageSlot := keccak256(0x00, 0x40)
-                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))
-                let bucket := add(mload(0x00), 1)
-                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))
-                amount := and(add(amount, shift), 0xff)
-                shift := 0
-                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {
-                    mstore(0x00, bucket)
-                    sstore(keccak256(0x00, 0x40), max)
-                }
-                mstore(0x00, bucket)
-            }
-            let storageSlot := keccak256(0x00, 0x40)
-            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))
-        }
-    }
-
-    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.
-    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let shift := and(start, 0xff)
-            mstore(0x20, bitmap.slot)
-            mstore(0x00, shr(8, start))
-            if iszero(lt(add(shift, amount), 257)) {
-                let storageSlot := keccak256(0x00, 0x40)
-                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))
-                let bucket := add(mload(0x00), 1)
-                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))
-                amount := and(add(amount, shift), 0xff)
-                shift := 0
-                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {
-                    mstore(0x00, bucket)
-                    sstore(keccak256(0x00, 0x40), 0)
-                }
-                mstore(0x00, bucket)
-            }
-            let storageSlot := keccak256(0x00, 0x40)
-            sstore(
-                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))
-            )
-        }
-    }
-
-    /// @dev Returns number of set bits within a range by
-    /// scanning `amount` of bits starting from the bit at `start`.
-    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)
-        internal
-        view
-        returns (uint256 count)
-    {
-        unchecked {
-            uint256 bucket = start >> 8;
-            uint256 shift = start & 0xff;
-            if (!(amount + shift < 257)) {
-                count = LibBit.popCount(bitmap.map[bucket] >> shift);
-                uint256 bucketEnd = bucket + ((amount + shift) >> 8);
-                amount = (amount + shift) & 0xff;
-                shift = 0;
-                for (++bucket; bucket != bucketEnd; ++bucket) {
-                    count += LibBit.popCount(bitmap.map[bucket]);
-                }
-            }
-            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));
-        }
-    }
-
-    /// @dev Returns the index of the most significant set bit in `[0..upTo]`.
-    /// If no set bit is found, returns `NOT_FOUND`.
-    function findLastSet(Bitmap storage bitmap, uint256 upTo)
-        internal
-        view
-        returns (uint256 setBitIndex)
-    {
-        setBitIndex = NOT_FOUND;
-        uint256 bucket = upTo >> 8;
-        uint256 bits;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, bucket)
-            mstore(0x20, bitmap.slot)
-            let offset := and(0xff, not(upTo)) // `256 - (255 & upTo) - 1`.
-            bits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))
-            if iszero(or(bits, iszero(bucket))) {
-                for {} 1 {} {
-                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.
-                    mstore(0x00, bucket)
-                    bits := sload(keccak256(0x00, 0x40))
-                    if or(bits, iszero(bucket)) { break }
-                }
-            }
-        }
-        if (bits != 0) {
-            setBitIndex = (bucket << 8) | LibBit.fls(bits);
-            /// @solidity memory-safe-assembly
-            assembly {
-                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, upTo)))
-            }
-        }
-    }
-
-    /// @dev Returns the index of the least significant unset bit in `[begin..upTo]`.
-    /// If no unset bit is found, returns `NOT_FOUND`.
-    function findFirstUnset(Bitmap storage bitmap, uint256 begin, uint256 upTo)
-        internal
-        view
-        returns (uint256 unsetBitIndex)
-    {
-        unsetBitIndex = NOT_FOUND;
-        uint256 bucket = begin >> 8;
-        uint256 negBits;
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, bucket)
-            mstore(0x20, bitmap.slot)
-            let offset := and(0xff, begin)
-            negBits := shl(offset, shr(offset, not(sload(keccak256(0x00, 0x40)))))
-            if iszero(negBits) {
-                let lastBucket := shr(8, upTo)
-                for {} 1 {} {
-                    bucket := add(bucket, 1)
-                    mstore(0x00, bucket)
-                    negBits := not(sload(keccak256(0x00, 0x40)))
-                    if or(negBits, gt(bucket, lastBucket)) { break }
-                }
-                if gt(bucket, lastBucket) {
-                    negBits := shl(and(0xff, not(upTo)), shr(and(0xff, not(upTo)), negBits))
-                }
-            }
-        }
-        if (negBits != 0) {
-            uint256 r = (bucket << 8) | LibBit.ffs(negBits);
-            /// @solidity memory-safe-assembly
-            assembly {
-                unsetBitIndex := or(r, sub(0, or(gt(r, upTo), lt(r, begin))))
-            }
-        }
-    }
-}
diff --git a/src/utils/g/LibBytes.sol b/src/utils/g/LibBytes.sol
deleted file mode 100644
index 6b384e0..0000000
--- a/src/utils/g/LibBytes.sol
+++ /dev/null
@@ -1,866 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Goated bytes storage struct that totally MOGs, no cap, fr.
-/// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.
-/// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.
-struct BytesStorage {
-    bytes32 _spacer;
-}
-
-using LibBytes for BytesStorage global;
-
-/// @notice Library for byte related operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibBytes.sol)
-library LibBytes {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The constant returned when the `search` is not found in the bytes.
-    uint256 internal constant NOT_FOUND = type(uint256).max;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  BYTE STORAGE OPERATIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Sets the value of the bytes storage `$` to `s`.
-    function set(BytesStorage storage $, bytes memory s) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(s)
-            let packed := or(0xff, shl(8, n))
-            for { let i := 0 } 1 {} {
-                if iszero(gt(n, 0xfe)) {
-                    i := 0x1f
-                    packed := or(n, shl(8, mload(add(s, i))))
-                    if iszero(gt(n, i)) { break }
-                }
-                let o := add(s, 0x20)
-                mstore(0x00, $.slot)
-                for { let p := keccak256(0x00, 0x20) } 1 {} {
-                    sstore(add(p, shr(5, i)), mload(add(o, i)))
-                    i := add(i, 0x20)
-                    if iszero(lt(i, n)) { break }
-                }
-                break
-            }
-            sstore($.slot, packed)
-        }
-    }
-
-    /// @dev Sets the value of the bytes storage `$` to `s`.
-    function setCalldata(BytesStorage storage $, bytes calldata s) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let packed := or(0xff, shl(8, s.length))
-            for { let i := 0 } 1 {} {
-                if iszero(gt(s.length, 0xfe)) {
-                    i := 0x1f
-                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))
-                    if iszero(gt(s.length, i)) { break }
-                }
-                mstore(0x00, $.slot)
-                for { let p := keccak256(0x00, 0x20) } 1 {} {
-                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))
-                    i := add(i, 0x20)
-                    if iszero(lt(i, s.length)) { break }
-                }
-                break
-            }
-            sstore($.slot, packed)
-        }
-    }
-
-    /// @dev Sets the value of the bytes storage `$` to the empty bytes.
-    function clear(BytesStorage storage $) internal {
-        delete $._spacer;
-    }
-
-    /// @dev Returns whether the value stored is `$` is the empty bytes "".
-    function isEmpty(BytesStorage storage $) internal view returns (bool) {
-        return uint256($._spacer) & 0xff == uint256(0);
-    }
-
-    /// @dev Returns the length of the value stored in `$`.
-    function length(BytesStorage storage $) internal view returns (uint256 result) {
-        result = uint256($._spacer);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := and(0xff, result)
-            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))
-        }
-    }
-
-    /// @dev Returns the value stored in `$`.
-    function get(BytesStorage storage $) internal view returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let o := add(result, 0x20)
-            let packed := sload($.slot)
-            let n := shr(8, packed)
-            for { let i := 0 } 1 {} {
-                if iszero(eq(or(packed, 0xff), packed)) {
-                    mstore(o, packed)
-                    n := and(0xff, packed)
-                    i := 0x1f
-                    if iszero(gt(n, i)) { break }
-                }
-                mstore(0x00, $.slot)
-                for { let p := keccak256(0x00, 0x20) } 1 {} {
-                    mstore(add(o, i), sload(add(p, shr(5, i))))
-                    i := add(i, 0x20)
-                    if iszero(lt(i, n)) { break }
-                }
-                break
-            }
-            mstore(result, n) // Store the length of the memory.
-            mstore(add(o, n), 0) // Zeroize the slot after the bytes.
-            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.
-    function uint8At(BytesStorage storage $, uint256 i) internal view returns (uint8 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for { let packed := sload($.slot) } 1 {} {
-                if iszero(eq(or(packed, 0xff), packed)) {
-                    if iszero(gt(i, 0x1e)) {
-                        result := byte(i, packed)
-                        break
-                    }
-                    if iszero(gt(i, and(0xff, packed))) {
-                        mstore(0x00, $.slot)
-                        let j := sub(i, 0x1f)
-                        result := byte(and(j, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, j))))
-                    }
-                    break
-                }
-                if iszero(gt(i, shr(8, packed))) {
-                    mstore(0x00, $.slot)
-                    result := byte(and(i, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, i))))
-                }
-                break
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      BYTES OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.
-    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let needleLen := mload(needle)
-            let replacementLen := mload(replacement)
-            let d := sub(result, subject) // Memory difference.
-            let i := add(subject, 0x20) // Subject bytes pointer.
-            mstore(0x00, add(i, mload(subject))) // End of subject.
-            if iszero(gt(needleLen, mload(subject))) {
-                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)
-                let h := 0 // The hash of `needle`.
-                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }
-                let s := mload(add(needle, 0x20))
-                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {
-                    let t := mload(i)
-                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.
-                    if iszero(shr(m, xor(t, s))) {
-                        if h {
-                            if iszero(eq(keccak256(i, needleLen), h)) {
-                                mstore(add(i, d), t)
-                                i := add(i, 1)
-                                if iszero(lt(i, subjectSearchEnd)) { break }
-                                continue
-                            }
-                        }
-                        // Copy the `replacement` one word at a time.
-                        for { let j := 0 } 1 {} {
-                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))
-                            j := add(j, 0x20)
-                            if iszero(lt(j, replacementLen)) { break }
-                        }
-                        d := sub(add(d, replacementLen), needleLen)
-                        if needleLen {
-                            i := add(i, needleLen)
-                            if iszero(lt(i, subjectSearchEnd)) { break }
-                            continue
-                        }
-                    }
-                    mstore(add(i, d), t)
-                    i := add(i, 1)
-                    if iszero(lt(i, subjectSearchEnd)) { break }
-                }
-            }
-            let end := mload(0x00)
-            let n := add(sub(d, add(result, 0x20)), end)
-            // Copy the rest of the bytes one word at a time.
-            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }
-            let o := add(i, d)
-            mstore(o, 0) // Zeroize the slot after the bytes.
-            mstore(0x40, add(o, 0x20)) // Allocate memory.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right, starting from `from`.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOf(bytes memory subject, bytes memory needle, uint256 from)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := not(0) // Initialize to `NOT_FOUND`.
-            for { let subjectLen := mload(subject) } 1 {} {
-                if iszero(mload(needle)) {
-                    result := from
-                    if iszero(gt(from, subjectLen)) { break }
-                    result := subjectLen
-                    break
-                }
-                let needleLen := mload(needle)
-                let subjectStart := add(subject, 0x20)
-
-                subject := add(subjectStart, from)
-                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)
-                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))
-                let s := mload(add(needle, 0x20))
-
-                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }
-
-                if iszero(lt(needleLen, 0x20)) {
-                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {
-                        if iszero(shr(m, xor(mload(subject), s))) {
-                            if eq(keccak256(subject, needleLen), h) {
-                                result := sub(subject, subjectStart)
-                                break
-                            }
-                        }
-                        subject := add(subject, 1)
-                        if iszero(lt(subject, end)) { break }
-                    }
-                    break
-                }
-                for {} 1 {} {
-                    if iszero(shr(m, xor(mload(subject), s))) {
-                        result := sub(subject, subjectStart)
-                        break
-                    }
-                    subject := add(subject, 1)
-                    if iszero(lt(subject, end)) { break }
-                }
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right, starting from `from`. Optimized for byte needles.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOfByte(bytes memory subject, bytes1 needle, uint256 from)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := not(0) // Initialize to `NOT_FOUND`.
-            if gt(mload(subject), from) {
-                let start := add(subject, 0x20)
-                let end := add(start, mload(subject))
-                let m := div(not(0), 255) // `0x0101 ... `.
-                let h := mul(byte(0, needle), m) // Replicating needle mask.
-                m := not(shl(7, m)) // `0x7f7f ... `.
-                for { let i := add(start, from) } 1 {} {
-                    let c := xor(mload(i), h) // Load 32-byte chunk and xor with mask.
-                    c := not(or(or(add(and(c, m), m), c), m)) // Each needle byte will be `0x80`.
-                    if c {
-                        c := and(not(shr(shl(3, sub(end, i)), not(0))), c) // Truncate bytes past the end.
-                        if c {
-                            let r := shl(7, lt(0x8421084210842108cc6318c6db6d54be, c)) // Save bytecode.
-                            r := or(shl(6, lt(0xffffffffffffffff, shr(r, c))), r)
-                            // forgefmt: disable-next-item
-                            result := add(sub(i, start), shr(3, xor(byte(and(0x1f, shr(byte(24,
-                                mul(0x02040810204081, shr(r, c))), 0x8421084210842108cc6318c6db6d54be)),
-                                0xc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8), r)))
-                            break
-                        }
-                    }
-                    i := add(i, 0x20)
-                    if iszero(lt(i, end)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right. Optimized for byte needles.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOfByte(bytes memory subject, bytes1 needle)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        return indexOfByte(subject, needle, 0);
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {
-        return indexOf(subject, needle, 0);
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from right to left, starting from `from`.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)
-        internal
-        pure
-        returns (uint256 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} 1 {} {
-                result := not(0) // Initialize to `NOT_FOUND`.
-                let needleLen := mload(needle)
-                if gt(needleLen, mload(subject)) { break }
-                let w := result
-
-                let fromMax := sub(mload(subject), needleLen)
-                if iszero(gt(fromMax, from)) { from := fromMax }
-
-                let end := add(add(subject, 0x20), w)
-                subject := add(add(subject, 0x20), from)
-                if iszero(gt(subject, end)) { break }
-                // As this function is not too often used,
-                // we shall simply use keccak256 for smaller bytecode size.
-                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {
-                    if eq(keccak256(subject, needleLen), h) {
-                        result := sub(subject, add(end, 1))
-                        break
-                    }
-                    subject := add(subject, w) // `sub(subject, 1)`.
-                    if iszero(gt(subject, end)) { break }
-                }
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from right to left.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function lastIndexOf(bytes memory subject, bytes memory needle)
-        internal
-        pure
-        returns (uint256)
-    {
-        return lastIndexOf(subject, needle, type(uint256).max);
-    }
-
-    /// @dev Returns true if `needle` is found in `subject`, false otherwise.
-    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {
-        return indexOf(subject, needle) != NOT_FOUND;
-    }
-
-    /// @dev Returns whether `subject` starts with `needle`.
-    function startsWith(bytes memory subject, bytes memory needle)
-        internal
-        pure
-        returns (bool result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(needle)
-            // Just using keccak256 directly is actually cheaper.
-            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))
-            result := lt(gt(n, mload(subject)), t)
-        }
-    }
-
-    /// @dev Returns whether `subject` ends with `needle`.
-    function endsWith(bytes memory subject, bytes memory needle)
-        internal
-        pure
-        returns (bool result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(needle)
-            let notInRange := gt(n, mload(subject))
-            // `subject + 0x20 + max(subject.length - needle.length, 0)`.
-            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))
-            // Just using keccak256 directly is actually cheaper.
-            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)
-        }
-    }
-
-    /// @dev Returns `subject` repeated `times`.
-    function repeat(bytes memory subject, uint256 times)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let l := mload(subject) // Subject length.
-            if iszero(or(iszero(times), iszero(l))) {
-                result := mload(0x40)
-                subject := add(subject, 0x20)
-                let o := add(result, 0x20)
-                for {} 1 {} {
-                    // Copy the `subject` one word at a time.
-                    for { let j := 0 } 1 {} {
-                        mstore(add(o, j), mload(add(subject, j)))
-                        j := add(j, 0x20)
-                        if iszero(lt(j, l)) { break }
-                    }
-                    o := add(o, l)
-                    times := sub(times, 1)
-                    if iszero(times) { break }
-                }
-                mstore(o, 0) // Zeroize the slot after the bytes.
-                mstore(0x40, add(o, 0x20)) // Allocate memory.
-                mstore(result, sub(o, add(result, 0x20))) // Store the length.
-            }
-        }
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).
-    /// `start` and `end` are byte offsets.
-    function slice(bytes memory subject, uint256 start, uint256 end)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let l := mload(subject) // Subject length.
-            if iszero(gt(l, end)) { end := l }
-            if iszero(gt(l, start)) { start := l }
-            if lt(start, end) {
-                result := mload(0x40)
-                let n := sub(end, start)
-                let i := add(subject, start)
-                let w := not(0x1f)
-                // Copy the `subject` one word at a time, backwards.
-                for { let j := and(add(n, 0x1f), w) } 1 {} {
-                    mstore(add(result, j), mload(add(i, j)))
-                    j := add(j, w) // `sub(j, 0x20)`.
-                    if iszero(j) { break }
-                }
-                let o := add(add(result, 0x20), n)
-                mstore(o, 0) // Zeroize the slot after the bytes.
-                mstore(0x40, add(o, 0x20)) // Allocate memory.
-                mstore(result, n) // Store the length.
-            }
-        }
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.
-    /// `start` is a byte offset.
-    function slice(bytes memory subject, uint256 start)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        result = slice(subject, start, type(uint256).max);
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).
-    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.
-    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))
-            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))
-            result.offset := add(subject.offset, start)
-            result.length := mul(lt(start, end), sub(end, start))
-        }
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.
-    /// `start` is a byte offset. Faster than Solidity's native slicing.
-    function sliceCalldata(bytes calldata subject, uint256 start)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))
-            result.offset := add(subject.offset, start)
-            result.length := mul(lt(start, subject.length), sub(subject.length, start))
-        }
-    }
-
-    /// @dev Reduces the size of `subject` to `n`.
-    /// If `n` is greater than the size of `subject`, this will be a no-op.
-    function truncate(bytes memory subject, uint256 n)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := subject
-            mstore(mul(lt(n, mload(result)), result), n)
-        }
-    }
-
-    /// @dev Returns a copy of `subject`, with the length reduced to `n`.
-    /// If `n` is greater than the size of `subject`, this will be a no-op.
-    function truncatedCalldata(bytes calldata subject, uint256 n)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result.offset := subject.offset
-            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))
-        }
-    }
-
-    /// @dev Returns all the indices of `needle` in `subject`.
-    /// The indices are byte offsets.
-    function indicesOf(bytes memory subject, bytes memory needle)
-        internal
-        pure
-        returns (uint256[] memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let searchLen := mload(needle)
-            if iszero(gt(searchLen, mload(subject))) {
-                result := mload(0x40)
-                let i := add(subject, 0x20)
-                let o := add(result, 0x20)
-                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)
-                let h := 0 // The hash of `needle`.
-                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }
-                let s := mload(add(needle, 0x20))
-                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {
-                    let t := mload(i)
-                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.
-                    if iszero(shr(m, xor(t, s))) {
-                        if h {
-                            if iszero(eq(keccak256(i, searchLen), h)) {
-                                i := add(i, 1)
-                                if iszero(lt(i, subjectSearchEnd)) { break }
-                                continue
-                            }
-                        }
-                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.
-                        o := add(o, 0x20)
-                        i := add(i, searchLen) // Advance `i` by `searchLen`.
-                        if searchLen {
-                            if iszero(lt(i, subjectSearchEnd)) { break }
-                            continue
-                        }
-                    }
-                    i := add(i, 1)
-                    if iszero(lt(i, subjectSearchEnd)) { break }
-                }
-                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.
-                // Allocate memory for result.
-                // We allocate one more word, so this array can be recycled for {split}.
-                mstore(0x40, add(o, 0x20))
-            }
-        }
-    }
-
-    /// @dev Returns an arrays of bytess based on the `delimiter` inside of the `subject` bytes.
-    function split(bytes memory subject, bytes memory delimiter)
-        internal
-        pure
-        returns (bytes[] memory result)
-    {
-        uint256[] memory indices = indicesOf(subject, delimiter);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let w := not(0x1f)
-            let indexPtr := add(indices, 0x20)
-            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
-            mstore(add(indicesEnd, w), mload(subject))
-            mstore(indices, add(mload(indices), 1))
-            for { let prevIndex := 0 } 1 {} {
-                let index := mload(indexPtr)
-                mstore(indexPtr, 0x60)
-                if iszero(eq(index, prevIndex)) {
-                    let element := mload(0x40)
-                    let l := sub(index, prevIndex)
-                    mstore(element, l) // Store the length of the element.
-                    // Copy the `subject` one word at a time, backwards.
-                    for { let o := and(add(l, 0x1f), w) } 1 {} {
-                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
-                        o := add(o, w) // `sub(o, 0x20)`.
-                        if iszero(o) { break }
-                    }
-                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.
-                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.
-                    mstore(0x40, add(element, and(add(l, 0x3f), w)))
-                    mstore(indexPtr, element) // Store the `element` into the array.
-                }
-                prevIndex := add(index, mload(delimiter))
-                indexPtr := add(indexPtr, 0x20)
-                if iszero(lt(indexPtr, indicesEnd)) { break }
-            }
-            result := indices
-            if iszero(mload(delimiter)) {
-                result := add(indices, 0x20)
-                mstore(result, sub(mload(indices), 2))
-            }
-        }
-    }
-
-    /// @dev Returns a concatenated bytes of `a` and `b`.
-    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.
-    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let w := not(0x1f)
-            let aLen := mload(a)
-            // Copy `a` one word at a time, backwards.
-            for { let o := and(add(aLen, 0x20), w) } 1 {} {
-                mstore(add(result, o), mload(add(a, o)))
-                o := add(o, w) // `sub(o, 0x20)`.
-                if iszero(o) { break }
-            }
-            let bLen := mload(b)
-            let output := add(result, aLen)
-            // Copy `b` one word at a time, backwards.
-            for { let o := and(add(bLen, 0x20), w) } 1 {} {
-                mstore(add(output, o), mload(add(b, o)))
-                o := add(o, w) // `sub(o, 0x20)`.
-                if iszero(o) { break }
-            }
-            let totalLen := add(aLen, bLen)
-            let last := add(add(result, 0x20), totalLen)
-            mstore(last, 0) // Zeroize the slot after the bytes.
-            mstore(result, totalLen) // Store the length.
-            mstore(0x40, add(last, 0x20)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns whether `a` equals `b`.
-    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
-        }
-    }
-
-    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.
-    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // These should be evaluated on compile time, as far as possible.
-            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.
-            let x := not(or(m, or(b, add(m, and(b, m)))))
-            let r := shl(7, iszero(iszero(shr(128, x))))
-            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))
-            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
-            r := or(r, shl(4, lt(0xffff, shr(r, x))))
-            r := or(r, shl(3, lt(0xff, shr(r, x))))
-            // forgefmt: disable-next-item
-            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),
-                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))
-        }
-    }
-
-    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.
-    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.
-    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let aLen := mload(a)
-            let bLen := mload(b)
-            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))
-            if n {
-                for { let i := 0x20 } 1 {} {
-                    let x := mload(add(a, i))
-                    let y := mload(add(b, i))
-                    if iszero(or(xor(x, y), eq(i, n))) {
-                        i := add(i, 0x20)
-                        continue
-                    }
-                    result := sub(gt(x, y), lt(x, y))
-                    break
-                }
-            }
-            // forgefmt: disable-next-item
-            if iszero(result) {
-                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201
-                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))
-                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))
-                result := sub(gt(x, y), lt(x, y))
-                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }
-            }
-        }
-    }
-
-    /// @dev Directly returns `a` without copying.
-    function directReturn(bytes memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Assumes that the bytes does not start from the scratch space.
-            let retStart := sub(a, 0x20)
-            let retUnpaddedSize := add(mload(a), 0x40)
-            // Right pad with zeroes. Just in case the bytes is produced
-            // by a method that doesn't zero right pad.
-            mstore(add(retStart, retUnpaddedSize), 0)
-            mstore(retStart, 0x20) // Store the return offset.
-            // End the transaction, returning the bytes.
-            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))
-        }
-    }
-
-    /// @dev Directly returns `a` with minimal copying.
-    function directReturn(bytes[] memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(a) // `a.length`.
-            let o := add(a, 0x20) // Start of elements in `a`.
-            let u := a // Highest memory slot.
-            let w := not(0x1f)
-            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {
-                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.
-                let s := mload(c) // `a[i]`.
-                let l := mload(s) // `a[i].length`.
-                let r := and(l, 0x1f) // `a[i].length % 32`.
-                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.
-                // If `s` comes before `o`, or `s` is not zero right padded.
-                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {
-                    let m := mload(0x40)
-                    mstore(m, l) // Copy `a[i].length`.
-                    for {} 1 {} {
-                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.
-                        z := add(z, w) // `sub(z, 0x20)`.
-                        if iszero(z) { break }
-                    }
-                    let e := add(add(m, 0x20), l)
-                    mstore(e, 0) // Zeroize the slot after the copied bytes.
-                    mstore(0x40, add(e, 0x20)) // Allocate memory.
-                    s := m
-                }
-                mstore(c, sub(s, o)) // Convert to calldata offset.
-                let t := add(l, add(s, 0x20))
-                if iszero(lt(t, u)) { u := t }
-            }
-            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.
-            mstore(retStart, 0x20) // Store the return offset.
-            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.
-        }
-    }
-
-    /// @dev Returns the word at `offset`, without any bounds checks.
-    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(add(add(a, 0x20), offset))
-        }
-    }
-
-    /// @dev Returns the word at `offset`, without any bounds checks.
-    function loadCalldata(bytes calldata a, uint256 offset)
-        internal
-        pure
-        returns (bytes32 result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := calldataload(add(a.offset, offset))
-        }
-    }
-
-    /// @dev Returns a slice representing a static struct in the calldata. Performs bounds checks.
-    function staticStructInCalldata(bytes calldata a, uint256 offset)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let l := sub(a.length, 0x20)
-            result.offset := add(a.offset, offset)
-            result.length := sub(a.length, offset)
-            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }
-        }
-    }
-
-    /// @dev Returns a slice representing a dynamic struct in the calldata. Performs bounds checks.
-    function dynamicStructInCalldata(bytes calldata a, uint256 offset)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let l := sub(a.length, 0x20)
-            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.
-            result.offset := add(a.offset, s)
-            result.length := sub(a.length, s)
-            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }
-        }
-    }
-
-    /// @dev Returns bytes in calldata. Performs bounds checks.
-    function bytesInCalldata(bytes calldata a, uint256 offset)
-        internal
-        pure
-        returns (bytes calldata result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let l := sub(a.length, 0x20)
-            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.
-            result.offset := add(add(a.offset, s), 0x20)
-            result.length := calldataload(add(a.offset, s))
-            // forgefmt: disable-next-item
-            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),
-                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }
-        }
-    }
-
-    /// @dev Returns empty calldata bytes. For silencing the compiler.
-    function emptyCalldata() internal pure returns (bytes calldata result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result.length := 0
-        }
-    }
-
-    /// @dev Returns the most significant 20 bytes as an address.
-    function msbToAddress(bytes32 x) internal pure returns (address) {
-        return address(bytes20(x));
-    }
-
-    /// @dev Returns the least significant 20 bytes as an address.
-    function lsbToAddress(bytes32 x) internal pure returns (address) {
-        return address(uint160(uint256(x)));
-    }
-}
diff --git a/src/utils/g/LibMap.sol b/src/utils/g/LibMap.sol
deleted file mode 100644
index cea3d28..0000000
--- a/src/utils/g/LibMap.sol
+++ /dev/null
@@ -1,318 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A uint8 map in storage.
-struct Uint8Map {
-    mapping(uint256 => uint256) map;
-}
-
-/// @dev A uint16 map in storage.
-struct Uint16Map {
-    mapping(uint256 => uint256) map;
-}
-
-/// @dev A uint32 map in storage.
-struct Uint32Map {
-    mapping(uint256 => uint256) map;
-}
-
-/// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.
-struct Uint40Map {
-    mapping(uint256 => uint256) map;
-}
-
-/// @dev A uint64 map in storage.
-struct Uint64Map {
-    mapping(uint256 => uint256) map;
-}
-
-/// @dev A uint128 map in storage.
-struct Uint128Map {
-    mapping(uint256 => uint256) map;
-}
-
-using LibMap for Uint8Map global;
-using LibMap for Uint16Map global;
-using LibMap for Uint32Map global;
-using LibMap for Uint40Map global;
-using LibMap for Uint64Map global;
-using LibMap for Uint128Map global;
-
-/// @notice Library for storage of packed unsigned integers.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibMap.sol)
-library LibMap {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     GETTERS / SETTERS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the uint8 value at `index` in `map`.
-    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(5, index))
-            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))
-        }
-    }
-
-    /// @dev Updates the uint8 value at `index` in `map`.
-    function set(Uint8Map storage map, uint256 index, uint8 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(5, index))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            mstore(0x00, sload(s))
-            mstore8(and(31, not(index)), value)
-            sstore(s, mload(0x00))
-        }
-    }
-
-    /// @dev Returns the uint16 value at `index` in `map`.
-    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {
-        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));
-    }
-
-    /// @dev Updates the uint16 value at `index` in `map`.
-    function set(Uint16Map storage map, uint256 index, uint16 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(4, index))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            let o := shl(4, and(index, 15)) // Storage slot offset (bits).
-            let v := sload(s) // Storage slot value.
-            let m := 0xffff // Value mask.
-            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))
-        }
-    }
-
-    /// @dev Returns the uint32 value at `index` in `map`.
-    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {
-        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));
-    }
-
-    /// @dev Updates the uint32 value at `index` in `map`.
-    function set(Uint32Map storage map, uint256 index, uint32 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(3, index))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            let o := shl(5, and(index, 7)) // Storage slot offset (bits).
-            let v := sload(s) // Storage slot value.
-            let m := 0xffffffff // Value mask.
-            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))
-        }
-    }
-
-    /// @dev Returns the uint40 value at `index` in `map`.
-    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {
-        unchecked {
-            result = uint40(map.map[index / 6] >> ((index % 6) * 40));
-        }
-    }
-
-    /// @dev Updates the uint40 value at `index` in `map`.
-    function set(Uint40Map storage map, uint256 index, uint40 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, div(index, 6))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).
-            let v := sload(s) // Storage slot value.
-            let m := 0xffffffffff // Value mask.
-            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))
-        }
-    }
-
-    /// @dev Returns the uint64 value at `index` in `map`.
-    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {
-        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));
-    }
-
-    /// @dev Updates the uint64 value at `index` in `map`.
-    function set(Uint64Map storage map, uint256 index, uint64 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(2, index))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            let o := shl(6, and(index, 3)) // Storage slot offset (bits).
-            let v := sload(s) // Storage slot value.
-            let m := 0xffffffffffffffff // Value mask.
-            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))
-        }
-    }
-
-    /// @dev Returns the uint128 value at `index` in `map`.
-    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {
-        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));
-    }
-
-    /// @dev Updates the uint128 value at `index` in `map`.
-    function set(Uint128Map storage map, uint256 index, uint128 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, map.slot)
-            mstore(0x00, shr(1, index))
-            let s := keccak256(0x00, 0x40) // Storage slot.
-            let o := shl(7, and(index, 1)) // Storage slot offset (bits).
-            let v := sload(s) // Storage slot value.
-            let m := 0xffffffffffffffffffffffffffffffff // Value mask.
-            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))
-        }
-    }
-
-    /// @dev Returns the value at `index` in `map`.
-    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)
-        internal
-        view
-        returns (uint256 result)
-    {
-        unchecked {
-            uint256 d = _rawDiv(256, bitWidth); // Bucket size.
-            uint256 m = (1 << bitWidth) - 1; // Value mask.
-            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;
-        }
-    }
-
-    /// @dev Updates the value at `index` in `map`.
-    function set(
-        mapping(uint256 => uint256) storage map,
-        uint256 index,
-        uint256 value,
-        uint256 bitWidth
-    ) internal {
-        unchecked {
-            uint256 d = _rawDiv(256, bitWidth); // Bucket size.
-            uint256 m = (1 << bitWidth) - 1; // Value mask.
-            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).
-            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       BINARY SEARCH                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // The following functions search in the range of [`start`, `end`)
-    // (i.e. `start <= index < end`).
-    // The range must be sorted in ascending order.
-    // `index` precedence: equal to > nearest before > nearest after.
-    // An invalid search range will simply return `(found = false, index = start)`.
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 8);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 16);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 32);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 40);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 64);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)
-        internal
-        view
-        returns (bool found, uint256 index)
-    {
-        return searchSorted(map.map, needle, start, end, 128);
-    }
-
-    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.
-    function searchSorted(
-        mapping(uint256 => uint256) storage map,
-        uint256 needle,
-        uint256 start,
-        uint256 end,
-        uint256 bitWidth
-    ) internal view returns (bool found, uint256 index) {
-        unchecked {
-            if (start >= end) end = start;
-            uint256 t;
-            uint256 o = start - 1; // Offset to derive the actual index.
-            uint256 l = 1; // Low.
-            uint256 d = _rawDiv(256, bitWidth); // Bucket size.
-            uint256 m = (1 << bitWidth) - 1; // Value mask.
-            uint256 h = end - start; // High.
-            while (true) {
-                index = (l & h) + ((l ^ h) >> 1);
-                if (l > h) break;
-                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;
-                if (t == needle) break;
-                if (needle <= t) h = index - 1;
-                else l = index + 1;
-            }
-            /// @solidity memory-safe-assembly
-            assembly {
-                m := or(iszero(index), iszero(bitWidth))
-                found := iszero(or(xor(t, needle), m))
-                index := add(o, xor(index, mul(xor(index, 1), m)))
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns `x / y`, returning 0 if `y` is zero.
-    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            z := div(x, y)
-        }
-    }
-
-    /// @dev Returns `x % y`, returning 0 if `y` is zero.
-    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            z := mod(x, y)
-        }
-    }
-}
diff --git a/src/utils/g/LibPRNG.sol b/src/utils/g/LibPRNG.sol
deleted file mode 100644
index 9f21886..0000000
--- a/src/utils/g/LibPRNG.sol
+++ /dev/null
@@ -1,505 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A pseudorandom number state in memory.
-struct PRNG {
-    uint256 state;
-}
-
-/// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.
-struct LazyShuffler {
-    // Bits Layout:
-    // - [0..31]    `numShuffled`
-    // - [32..223]  `permutationSlot`
-    // - [224..255] `length`
-    uint256 _state;
-}
-
-using LibPRNG for PRNG global;
-using LibPRNG for LazyShuffler global;
-
-/// @notice Library for generating pseudorandom numbers.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibPRNG.sol)
-/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)
-/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)
-library LibPRNG {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.
-    error InvalidInitialLazyShufflerLength();
-
-    /// @dev The new length must not be less than the current length.
-    error InvalidNewLazyShufflerLength();
-
-    /// @dev The lazy shuffler has not been initialized.
-    error LazyShufflerNotInitialized();
-
-    /// @dev Cannot double initialize the lazy shuffler.
-    error LazyShufflerAlreadyInitialized();
-
-    /// @dev The lazy shuffle has finished.
-    error LazyShuffleFinished();
-
-    /// @dev The queried index is out of bounds.
-    error LazyShufflerGetOutOfBounds();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The scalar of ETH and most ERC20s.
-    uint256 internal constant WAD = 1e18;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Seeds the `prng` with `state`.
-    function seed(PRNG memory prng, uint256 state) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(prng, state)
-        }
-    }
-
-    /// @dev Returns the next pseudorandom uint256.
-    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.
-    function next(PRNG memory prng) internal pure returns (uint256 result) {
-        // We simply use `keccak256` for a great balance between
-        // runtime gas costs, bytecode size, and statistical properties.
-        //
-        // A high-quality LCG with a 32-byte state
-        // is only about 30% more gas efficient during runtime,
-        // but requires a 32-byte multiplier, which can cause bytecode bloat
-        // when this function is inlined.
-        //
-        // Using this method is about 2x more efficient than
-        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := keccak256(prng, 0x20)
-            mstore(prng, result)
-        }
-    }
-
-    /// @dev Returns a pseudorandom uint256, uniformly distributed
-    /// between 0 (inclusive) and `upper` (exclusive).
-    /// If your modulus is big, this method is recommended
-    /// for uniform sampling to avoid modulo bias.
-    /// For uniform sampling across all uint256 values,
-    /// or for small enough moduli such that the bias is negligible,
-    /// use {next} instead.
-    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} 1 {} {
-                result := keccak256(prng, 0x20)
-                mstore(prng, result)
-                if iszero(lt(result, mod(sub(0, upper), upper))) { break }
-            }
-            result := mod(result, upper)
-        }
-    }
-
-    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.
-    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Technically, this is the Irwin-Hall distribution with 20 samples.
-            // The chance of drawing a sample outside 10 σ from the standard normal distribution
-            // is ≈ 0.000000000000000000000015, which is insignificant for most practical purposes.
-            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.
-            result := keccak256(prng, 0x20)
-            mstore(prng, result)
-            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.
-            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.
-            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff
-            let s := 0x1000000000000000100000000000000010000000000000001
-            let r1 := mulmod(result, a, n)
-            let r2 := mulmod(r1, a, n)
-            let r3 := mulmod(r2, a, n)
-            // forgefmt: disable-next-item
-            result := sub(sar(96, mul(26614938895861601847173011183,
-                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),
-                shr(192, mul(s, add(and(m, r2), and(m, r3))))),
-                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)
-        }
-    }
-
-    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.
-    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Passes the Kolmogorov-Smirnov test for 200k samples.
-            // Gas usage varies, starting from about 172+ gas.
-            let r := keccak256(prng, 0x20)
-            mstore(prng, r)
-            let p := shl(129, r)
-            let w := shl(1, r)
-            if iszero(gt(w, p)) {
-                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.
-                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.
-                for {} 1 {} {
-                    r := mulmod(r, a, n)
-                    if iszero(lt(shl(129, r), w)) {
-                        r := mulmod(r, a, n)
-                        result := add(1000000000000000000, result)
-                        w := shl(1, r)
-                        p := shl(129, r)
-                        if iszero(lt(w, p)) { break }
-                        continue
-                    }
-                    w := shl(1, r)
-                    if iszero(lt(w, shl(129, r))) { break }
-                }
-            }
-            result := add(div(p, shl(129, 170141183460469231732)), result)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*             MEMORY ARRAY SHUFFLING OPERATIONS              */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.
-    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(a)
-            let w := not(0)
-            let mask := shr(128, w)
-            if n {
-                for { a := add(a, 0x20) } 1 {} {
-                    // We can just directly use `keccak256`, cuz
-                    // the other approaches don't save much.
-                    let r := keccak256(prng, 0x20)
-                    mstore(prng, r)
-
-                    // Note that there will be a very tiny modulo bias
-                    // if the length of the array is not a power of 2.
-                    // For all practical purposes, it is negligible
-                    // and will not be a fairness or security concern.
-                    {
-                        let j := add(a, shl(5, mod(shr(128, r), n)))
-                        n := add(n, w) // `sub(n, 1)`.
-                        if iszero(n) { break }
-
-                        let i := add(a, shl(5, n))
-                        let t := mload(i)
-                        mstore(i, mload(j))
-                        mstore(j, t)
-                    }
-
-                    {
-                        let j := add(a, shl(5, mod(and(r, mask), n)))
-                        n := add(n, w) // `sub(n, 1)`.
-                        if iszero(n) { break }
-
-                        let i := add(a, shl(5, n))
-                        let t := mload(i)
-                        mstore(i, mload(j))
-                        mstore(j, t)
-                    }
-                }
-            }
-        }
-    }
-
-    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.
-    function shuffle(PRNG memory prng, int256[] memory a) internal pure {
-        shuffle(prng, _toUints(a));
-    }
-
-    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.
-    function shuffle(PRNG memory prng, address[] memory a) internal pure {
-        shuffle(prng, _toUints(a));
-    }
-
-    /// @dev Partially shuffles the array in-place with Fisher-Yates shuffle.
-    /// The first `k` elements will be uniformly sampled without replacement.
-    function shuffle(PRNG memory prng, uint256[] memory a, uint256 k) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(a)
-            k := xor(k, mul(xor(k, n), lt(n, k))) // `min(n, k)`.
-            if k {
-                let mask := shr(128, not(0))
-                let b := 0
-                for { a := add(a, 0x20) } 1 {} {
-                    // We can just directly use `keccak256`, cuz
-                    // the other approaches don't save much.
-                    let r := keccak256(prng, 0x20)
-                    mstore(prng, r)
-
-                    // Note that there will be a very tiny modulo bias
-                    // if the length of the array is not a power of 2.
-                    // For all practical purposes, it is negligible
-                    // and will not be a fairness or security concern.
-                    {
-                        let j := add(a, shl(5, add(b, mod(shr(128, r), sub(n, b)))))
-                        let i := add(a, shl(5, b))
-                        let t := mload(i)
-                        mstore(i, mload(j))
-                        mstore(j, t)
-                        b := add(b, 1)
-                        if eq(b, k) { break }
-                    }
-
-                    {
-                        let j := add(a, shl(5, add(b, mod(and(r, mask), sub(n, b)))))
-                        let i := add(a, shl(5, b))
-                        let t := mload(i)
-                        mstore(i, mload(j))
-                        mstore(j, t)
-                        b := add(b, 1)
-                        if eq(b, k) { break }
-                    }
-                }
-            }
-        }
-    }
-
-    /// @dev Partially shuffles the array in-place with Fisher-Yates shuffle.
-    /// The first `k` elements will be uniformly sampled without replacement.
-    function shuffle(PRNG memory prng, int256[] memory a, uint256 k) internal pure {
-        shuffle(prng, _toUints(a), k);
-    }
-
-    /// @dev Partially shuffles the array in-place with Fisher-Yates shuffle.
-    /// The first `k` elements will be uniformly sampled without replacement.
-    function shuffle(PRNG memory prng, address[] memory a, uint256 k) internal pure {
-        shuffle(prng, _toUints(a), k);
-    }
-
-    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.
-    function shuffle(PRNG memory prng, bytes memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(a)
-            let w := not(0)
-            let mask := shr(128, w)
-            if n {
-                let b := add(a, 0x01)
-                for { a := add(a, 0x20) } 1 {} {
-                    // We can just directly use `keccak256`, cuz
-                    // the other approaches don't save much.
-                    let r := keccak256(prng, 0x20)
-                    mstore(prng, r)
-
-                    // Note that there will be a very tiny modulo bias
-                    // if the length of the array is not a power of 2.
-                    // For all practical purposes, it is negligible
-                    // and will not be a fairness or security concern.
-                    {
-                        let o := mod(shr(128, r), n)
-                        n := add(n, w) // `sub(n, 1)`.
-                        if iszero(n) { break }
-
-                        let t := mload(add(b, n))
-                        mstore8(add(a, n), mload(add(b, o)))
-                        mstore8(add(a, o), t)
-                    }
-
-                    {
-                        let o := mod(and(r, mask), n)
-                        n := add(n, w) // `sub(n, 1)`.
-                        if iszero(n) { break }
-
-                        let t := mload(add(b, n))
-                        mstore8(add(a, n), mload(add(b, o)))
-                        mstore8(add(a, o), t)
-                    }
-                }
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.
-    /// Reverts if `n == 0 || n >= 2**32 - 1`.
-    /// Reverts if `$` has already been initialized.
-    /// If you need to reduce the length after initialization, just use a fresh new `$`.
-    function initialize(LazyShuffler storage $, uint256 n) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(lt(sub(n, 1), 0xfffffffe)) {
-                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.
-                revert(0x1c, 0x04)
-            }
-            if sload($.slot) {
-                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x00, $.slot)
-            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))
-        }
-    }
-
-    /// @dev Increases the length of `$`.
-    /// Reverts if `$` has not been initialized.
-    function grow(LazyShuffler storage $, uint256 n) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let state := sload($.slot) // The packed value at `$`.
-            // If the new length is smaller than the old length, revert.
-            if lt(n, shr(224, state)) {
-                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.
-                revert(0x1c, 0x04)
-            }
-            if iszero(state) {
-                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.
-                revert(0x1c, 0x04)
-            }
-            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))
-        }
-    }
-
-    /// @dev Restarts the shuffler by setting `numShuffled` to zero,
-    /// such that all elements can be drawn again.
-    /// Restarting does NOT clear the internal permutation, nor changes the length.
-    /// Even with the same sequence of randomness, reshuffling can yield different results.
-    function restart(LazyShuffler storage $) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let state := sload($.slot)
-            if iszero(state) {
-                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.
-                revert(0x1c, 0x04)
-            }
-            sstore($.slot, shl(32, shr(32, state)))
-        }
-    }
-
-    /// @dev Returns the number of elements that have been shuffled.
-    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := and(0xffffffff, sload($.slot))
-        }
-    }
-
-    /// @dev Returns the length of `$`.
-    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.
-    function length(LazyShuffler storage $) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(224, sload($.slot))
-        }
-    }
-
-    /// @dev Returns if `$` has been initialized.
-    function initialized(LazyShuffler storage $) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := iszero(iszero(sload($.slot)))
-        }
-    }
-
-    /// @dev Returns if there are any more elements left to shuffle.
-    /// Reverts if `$` is not initialized.
-    function finished(LazyShuffler storage $) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let state := sload($.slot) // The packed value at `$`.
-            if iszero(state) {
-                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.
-                revert(0x1c, 0x04)
-            }
-            result := eq(shr(224, state), and(0xffffffff, state))
-        }
-    }
-
-    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.
-    /// Reverts if `index` is greater than or equal to the `length` of `$`.
-    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let state := sload($.slot) // The packed value at `$`.
-            let n := shr(224, state) // Length of `$`.
-            if iszero(lt(index, n)) {
-                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.
-                revert(0x1c, 0x04)
-            }
-            let u32 := gt(n, 0xfffe)
-            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.
-            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).
-            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.
-            result := and(m, shr(o, sload(s)))
-            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))
-        }
-    }
-
-    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,
-    /// and returns the next value in the shuffled range.
-    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.
-    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.
-    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function _get(u32_, state_, i_) -> _value {
-                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.
-                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).
-                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.
-                _value := and(m_, shr(o_, sload(s_)))
-                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))
-            }
-            function _set(u32_, state_, i_, value_) {
-                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.
-                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).
-                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.
-                let v_ := sload(s_) // Bucket slot value.
-                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))
-                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))
-            }
-            let state := sload($.slot) // The packed value at `$`.
-            let shuffled := and(0xffffffff, state) // Number of elements shuffled.
-            let n := shr(224, state) // Length of `$`.
-            let remainder := sub(n, shuffled) // Number of elements left to shuffle.
-            if iszero(remainder) {
-                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x00, randomness) // (Re)hash the randomness so that we don't
-            mstore(0x20, shuffled) // need to expect guarantees on its distribution.
-            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)
-            chosen := _get(gt(n, 0xfffe), state, index)
-            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))
-            _set(gt(n, 0xfffe), state, shuffled, chosen)
-            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Reinterpret cast to an uint256 array.
-    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            casted := a
-        }
-    }
-
-    /// @dev Reinterpret cast to an uint256 array.
-    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // As any address written to memory will have the upper 96 bits
-            // of the word zeroized (as per Solidity spec), we can directly
-            // compare these addresses as if they are whole uint256 words.
-            casted := a
-        }
-    }
-}
diff --git a/src/utils/g/LibRLP.sol b/src/utils/g/LibRLP.sol
deleted file mode 100644
index f13e82e..0000000
--- a/src/utils/g/LibRLP.sol
+++ /dev/null
@@ -1,395 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A pointer to a RLP item list in memory.
-struct List {
-    // Do NOT modify the `_data` directly.
-    uint256 _data;
-}
-
-using LibRLP for List global;
-
-/// @notice Library for RLP encoding and CREATE address computation.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibRLP.sol)
-/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)
-library LibRLP {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                 CREATE ADDRESS PREDICTION                  */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the address where a contract will be stored if deployed via
-    /// `deployer` with `nonce` using the `CREATE` opcode.
-    /// For the specification of the Recursive Length Prefix (RLP)
-    /// encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper
-    /// (https://ethereum.github.io/yellowpaper/paper.pdf)
-    /// and the Ethereum Wiki (https://eth.wiki/fundamentals/rlp).
-    ///
-    /// Based on the EIP-161 (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md)
-    /// specification, all contract accounts on the Ethereum mainnet are initiated with
-    /// `nonce = 1`. Thus, the first contract address created by another contract
-    /// is calculated with a non-zero nonce.
-    ///
-    /// The theoretical allowed limit, based on EIP-2681
-    /// (https://eips.ethereum.org/EIPS/eip-2681), for an account nonce is 2**64-2.
-    ///
-    /// Caution! This function will NOT check that the nonce is within the theoretical range.
-    /// This is for performance, as exceeding the range is extremely impractical.
-    /// It is the user's responsibility to ensure that the nonce is valid
-    /// (e.g. no dirty bits after packing / unpacking).
-    ///
-    /// This is equivalent to:
-    /// `address(uint160(uint256(keccak256(LibRLP.p(deployer).p(nonce).encode()))))`.
-    ///
-    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
-    function computeAddress(address deployer, uint256 nonce)
-        internal
-        pure
-        returns (address deployed)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} 1 {} {
-                // The integer zero is treated as an empty byte string,
-                // and as a result it only has a length prefix, 0x80,
-                // computed via `0x80 + 0`.
-
-                // A one-byte integer in the [0x00, 0x7f] range uses its
-                // own value as a length prefix,
-                // there is no additional `0x80 + length` prefix that precedes it.
-                if iszero(gt(nonce, 0x7f)) {
-                    mstore(0x00, deployer)
-                    // Using `mstore8` instead of `or` naturally cleans
-                    // any dirty upper bits of `deployer`.
-                    mstore8(0x0b, 0x94)
-                    mstore8(0x0a, 0xd6)
-                    // `shl` 7 is equivalent to multiplying by 0x80.
-                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))
-                    deployed := keccak256(0x0a, 0x17)
-                    break
-                }
-                let i := 8
-                // Just use a loop to generalize all the way with minimal bytecode size.
-                for {} shr(i, nonce) { i := add(i, 8) } {}
-                // `shr` 3 is equivalent to dividing by 8.
-                i := shr(3, i)
-                // Store in descending slot sequence to overlap the values correctly.
-                mstore(i, nonce)
-                mstore(0x00, shl(8, deployer))
-                mstore8(0x1f, add(0x80, i))
-                mstore8(0x0a, 0x94)
-                mstore8(0x09, add(0xd6, i))
-                deployed := keccak256(0x09, add(0x17, i))
-                break
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                  RLP ENCODING OPERATIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Note:
-    // - addresses are treated like byte strings of length 20, agnostic of leading zero bytes.
-    // - uint256s are converted to byte strings, stripped of leading zero bytes, and encoded.
-    // - bools are converted to uint256s (`b ? 1 : 0`), then encoded with the uint256.
-    // - For bytes1 to bytes32, you must manually convert them to bytes memory
-    //   with `abi.encodePacked(x)` before encoding.
-
-    /// @dev Returns a new empty list.
-    function p() internal pure returns (List memory result) {}
-
-    /// @dev Returns a new list with `x` as the only element. Equivalent to `LibRLP.p().p(x)`.
-    function p(uint256 x) internal pure returns (List memory result) {
-        p(result, x);
-    }
-
-    /// @dev Returns a new list with `x` as the only element. Equivalent to `LibRLP.p().p(x)`.
-    function p(address x) internal pure returns (List memory result) {
-        p(result, x);
-    }
-
-    /// @dev Returns a new list with `x` as the only element. Equivalent to `LibRLP.p().p(x)`.
-    function p(bool x) internal pure returns (List memory result) {
-        p(result, x);
-    }
-
-    /// @dev Returns a new list with `x` as the only element. Equivalent to `LibRLP.p().p(x)`.
-    function p(bytes memory x) internal pure returns (List memory result) {
-        p(result, x);
-    }
-
-    /// @dev Returns a new list with `x` as the only element. Equivalent to `LibRLP.p().p(x)`.
-    function p(List memory x) internal pure returns (List memory result) {
-        p(result, x);
-    }
-
-    /// @dev Appends `x` to `list`. Returns `list` for function chaining.
-    function p(List memory list, uint256 x) internal pure returns (List memory result) {
-        result._data = x << 48;
-        _updateTail(list, result);
-        /// @solidity memory-safe-assembly
-        assembly {
-            // If `x` is too big, we cannot pack it inline with the node.
-            // We'll have to allocate a new slot for `x` and store the pointer to it in the node.
-            if shr(208, x) {
-                let m := mload(0x40)
-                mstore(m, x)
-                mstore(0x40, add(m, 0x20))
-                mstore(result, shl(40, or(1, shl(8, m))))
-            }
-        }
-        result = list;
-    }
-
-    /// @dev Appends `x` to `list`. Returns `list` for function chaining.
-    function p(List memory list, address x) internal pure returns (List memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, shl(40, or(4, shl(8, x))))
-        }
-        _updateTail(list, result);
-        result = list;
-    }
-
-    /// @dev Appends `x` to `list`. Returns `list` for function chaining.
-    function p(List memory list, bool x) internal pure returns (List memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, shl(48, iszero(iszero(x))))
-        }
-        _updateTail(list, result);
-        result = list;
-    }
-
-    /// @dev Appends `x` to `list`. Returns `list` for function chaining.
-    function p(List memory list, bytes memory x) internal pure returns (List memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, shl(40, or(2, shl(8, x))))
-        }
-        _updateTail(list, result);
-        result = list;
-    }
-
-    /// @dev Appends `x` to `list`. Returns `list` for function chaining.
-    function p(List memory list, List memory x) internal pure returns (List memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(result, shl(40, or(3, shl(8, x))))
-        }
-        _updateTail(list, result);
-        result = list;
-    }
-
-    /// @dev Returns the RLP encoding of `list`.
-    function encode(List memory list) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function encodeUint(x_, o_) -> _o {
-                _o := add(o_, 1)
-                if iszero(gt(x_, 0x7f)) {
-                    mstore8(o_, or(shl(7, iszero(x_)), x_)) // Copy `x_`.
-                    leave
-                }
-                let r_ := shl(7, lt(0xffffffffffffffffffffffffffffffff, x_))
-                r_ := or(r_, shl(6, lt(0xffffffffffffffff, shr(r_, x_))))
-                r_ := or(r_, shl(5, lt(0xffffffff, shr(r_, x_))))
-                r_ := or(r_, shl(4, lt(0xffff, shr(r_, x_))))
-                r_ := or(shr(3, r_), lt(0xff, shr(r_, x_)))
-                mstore8(o_, add(r_, 0x81)) // Store the prefix.
-                mstore(0x00, x_)
-                mstore(_o, mload(xor(31, r_))) // Copy `x_`.
-                _o := add(add(1, r_), _o)
-            }
-            function encodeAddress(x_, o_) -> _o {
-                _o := add(o_, 0x15)
-                mstore(o_, shl(88, x_))
-                mstore8(o_, 0x94)
-            }
-            function encodeBytes(x_, o_, c_) -> _o {
-                _o := add(o_, 1)
-                let n_ := mload(x_)
-                if iszero(gt(n_, 55)) {
-                    let f_ := mload(add(0x20, x_))
-                    if iszero(and(eq(1, n_), lt(byte(0, f_), 0x80))) {
-                        mstore8(o_, add(n_, c_)) // Store the prefix.
-                        mstore(add(0x21, o_), mload(add(0x40, x_)))
-                        mstore(_o, f_)
-                        _o := add(n_, _o)
-                        leave
-                    }
-                    mstore(o_, f_) // Copy `x_`.
-                    leave
-                }
-                returndatacopy(returndatasize(), returndatasize(), shr(32, n_))
-                let r_ := add(1, add(lt(0xff, n_), add(lt(0xffff, n_), lt(0xffffff, n_))))
-                mstore(o_, shl(248, add(r_, add(c_, 55)))) // Store the prefix.
-                // Copy `x`.
-                let i_ := add(r_, _o)
-                _o := add(i_, n_)
-                for { let d_ := sub(add(0x20, x_), i_) } 1 {} {
-                    mstore(i_, mload(add(d_, i_)))
-                    i_ := add(i_, 0x20)
-                    if iszero(lt(i_, _o)) { break }
-                }
-                mstore(o_, or(mload(o_), shl(sub(248, shl(3, r_)), n_))) // Store the prefix.
-            }
-            function encodeList(l_, o_) -> _o {
-                if iszero(mload(l_)) {
-                    mstore8(o_, 0xc0)
-                    _o := add(o_, 1)
-                    leave
-                }
-                let j_ := add(o_, 0x20)
-                for { let h_ := l_ } 1 {} {
-                    h_ := and(mload(h_), 0xffffffffff)
-                    if iszero(h_) { break }
-                    let t_ := byte(26, mload(h_))
-                    if iszero(gt(t_, 1)) {
-                        if iszero(t_) {
-                            j_ := encodeUint(shr(48, mload(h_)), j_)
-                            continue
-                        }
-                        j_ := encodeUint(mload(shr(48, mload(h_))), j_)
-                        continue
-                    }
-                    if eq(t_, 2) {
-                        j_ := encodeBytes(shr(48, mload(h_)), j_, 0x80)
-                        continue
-                    }
-                    if eq(t_, 3) {
-                        j_ := encodeList(shr(48, mload(h_)), j_)
-                        continue
-                    }
-                    j_ := encodeAddress(shr(48, mload(h_)), j_)
-                }
-                let n_ := sub(j_, add(o_, 0x20))
-                if iszero(gt(n_, 55)) {
-                    mstore8(o_, add(n_, 0xc0)) // Store the prefix.
-                    mstore(add(0x01, o_), mload(add(0x20, o_)))
-                    mstore(add(0x21, o_), mload(add(0x40, o_)))
-                    _o := add(n_, add(0x01, o_))
-                    leave
-                }
-                mstore(o_, n_)
-                _o := encodeBytes(o_, o_, 0xc0)
-            }
-            result := mload(0x40)
-            let begin := add(result, 0x20)
-            let end := encodeList(list, begin)
-            mstore(result, sub(end, begin)) // Store the length of `result`.
-            mstore(end, 0) // Zeroize the slot after `result`.
-            mstore(0x40, add(end, 0x20)) // Allocate memory for `result`.
-        }
-    }
-
-    /// @dev Returns the RLP encoding of `x`.
-    function encode(uint256 x) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} 1 {} {
-                result := mload(0x40)
-                if iszero(gt(x, 0x7f)) {
-                    mstore(result, 1) // Store the length of `result`.
-                    mstore(add(result, 0x20), shl(248, or(shl(7, iszero(x)), x))) // Copy `x`.
-                    mstore(0x40, add(result, 0x40)) // Allocate memory for `result`.
-                    break
-                }
-                let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
-                r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
-                r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
-                r := or(r, shl(4, lt(0xffff, shr(r, x))))
-                r := add(2, or(shr(3, r), lt(0xff, shr(r, x))))
-                mstore(add(r, result), x) // Copy `x`.
-                mstore(add(result, 1), add(r, 0x7f)) // Store the prefix.
-                mstore(result, r) // Store the length of `result`.
-                mstore(add(r, add(result, 0x20)), 0) // Zeroize the slot after `result`.
-                mstore(0x40, add(result, 0x60)) // Allocate memory for `result`.
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the RLP encoding of `x`.
-    function encode(address x) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 0x15)
-            let o := add(0x20, result)
-            mstore(o, shl(88, x))
-            mstore8(o, 0x94)
-            mstore(0x40, add(0x20, o))
-        }
-    }
-
-    /// @dev Returns the RLP encoding of `x`.
-    function encode(bool x) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 1)
-            mstore(add(0x20, result), shl(add(0xf8, mul(7, iszero(x))), 0x01))
-            mstore(0x40, add(0x40, result))
-        }
-    }
-
-    /// @dev Returns the RLP encoding of `x`.
-    function encode(bytes memory x) internal pure returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := x
-
-            for {} iszero(and(eq(1, mload(x)), lt(byte(0, mload(add(x, 0x20))), 0x80))) {} {
-                result := mload(0x40)
-                let n := mload(x) // Length of `x`.
-                if iszero(gt(n, 55)) {
-                    mstore(0x40, add(result, 0x60))
-                    mstore(add(0x41, result), mload(add(0x40, x)))
-                    mstore(add(0x21, result), mload(add(0x20, x)))
-                    mstore(add(1, result), add(n, 0x80)) // Store the prefix.
-                    mstore(result, add(1, n)) // Store the length of `result`.
-                    mstore(add(add(result, 0x21), n), 0) // Zeroize the slot after `result`.
-                    break
-                }
-                returndatacopy(returndatasize(), returndatasize(), shr(32, n))
-                let r := add(2, add(lt(0xff, n), add(lt(0xffff, n), lt(0xffffff, n))))
-                // Copy `x`.
-                let i := add(r, add(0x20, result))
-                let end := add(i, n)
-                for { let d := sub(add(0x20, x), i) } 1 {} {
-                    mstore(i, mload(add(d, i)))
-                    i := add(i, 0x20)
-                    if iszero(lt(i, end)) { break }
-                }
-                mstore(add(r, result), n) // Store the prefix.
-                mstore(add(1, result), add(r, 0xb6)) // Store the prefix.
-                mstore(result, add(r, n)) // Store the length of `result`.
-                mstore(end, 0) // Zeroize the slot after `result`.
-                mstore(0x40, add(end, 0x20)) // Allocate memory.
-                break
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Updates the tail in `list`.
-    function _updateTail(List memory list, List memory result) private pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let v := or(shr(mload(list), result), mload(list))
-            let tail := shr(40, v)
-            mstore(list, xor(shl(40, xor(tail, result)), v)) // Update the tail.
-            mstore(tail, or(mload(tail), result)) // Make the previous tail point to `result`.
-        }
-    }
-}
diff --git a/src/utils/g/LibStorage.sol b/src/utils/g/LibStorage.sol
deleted file mode 100644
index 746f6ac..0000000
--- a/src/utils/g/LibStorage.sol
+++ /dev/null
@@ -1,90 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Generates a storage slot that can be invalidated.
-struct Bump {
-    uint256 _current;
-}
-
-/// @dev Pointer struct to a `uint256` in storage.
-/// We have opted for a `uint256` as the inner type,
-/// as it requires less casting to get / set specific bits.
-struct Ref {
-    uint256 value;
-}
-
-using LibStorage for Bump global;
-using LibStorage for Ref global;
-
-/// @notice Library for basic storage operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibStorage.sol)
-library LibStorage {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The storage slot seed for calculating a bumped storage slot.
-    /// `bytes4(keccak256("_BUMPED_STORAGE_REF_SLOT_SEED"))`.
-    uint256 private constant _BUMPED_STORAGE_REF_SLOT_SEED = 0xd4203f8b;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the current storage slot pointed by the bump.
-    /// Use inline-assembly to cast the result to a desired custom data type storage pointer.
-    function slot(Bump storage b) internal view returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x1f, sload(b.slot))
-            mstore(0x04, _BUMPED_STORAGE_REF_SLOT_SEED)
-            mstore(0x00, b.slot)
-            result := keccak256(0x00, 0x3f)
-        }
-    }
-
-    /// @dev Makes the bump point to a whole new storage slot.
-    function invalidate(Bump storage b) internal {
-        unchecked {
-            ++b._current;
-        }
-    }
-
-    /// @dev Returns a bump at the storage slot.
-    function bump(bytes32 sSlot) internal pure returns (Bump storage $) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            $.slot := sSlot
-        }
-    }
-
-    /// @dev Returns a bump at the storage slot.
-    function bump(uint256 sSlot) internal pure returns (Bump storage $) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            $.slot := sSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `uint256` in storage.
-    function ref(bytes32 sSlot) internal pure returns (Ref storage $) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            $.slot := sSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `uint256` in storage.
-    function ref(uint256 sSlot) internal pure returns (Ref storage $) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            $.slot := sSlot
-        }
-    }
-}
diff --git a/src/utils/g/LibString.sol b/src/utils/g/LibString.sol
deleted file mode 100644
index 8dd862b..0000000
--- a/src/utils/g/LibString.sol
+++ /dev/null
@@ -1,981 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Goated string storage struct that totally MOGs, no cap, fr.
-/// Uses less gas and bytecode than Solidity's native string storage. It's meta af.
-/// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.
-struct StringStorage {
-    bytes32 _spacer;
-}
-
-using LibString for StringStorage global;
-
-import {LibBytes} from "../LibBytes.sol";
-
-/// @notice Library for converting numbers into strings and other string operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibString.sol)
-/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
-///
-/// @dev Note:
-/// For performance and bytecode compactness, most of the string operations are restricted to
-/// byte strings (7-bit ASCII), except where otherwise specified.
-/// Usage of byte string operations on charsets with runes spanning two or more bytes
-/// can lead to undefined behavior.
-library LibString {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                        CUSTOM ERRORS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The length of the output is too small to contain all the hex digits.
-    error HexLengthInsufficient();
-
-    /// @dev The length of the string is more than 32 bytes.
-    error TooBigForSmallString();
-
-    /// @dev The input string must be a 7-bit ASCII.
-    error StringNot7BitASCII();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The constant returned when the `search` is not found in the string.
-    uint256 internal constant NOT_FOUND = type(uint256).max;
-
-    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.
-    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;
-
-    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.
-    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;
-
-    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.
-    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;
-
-    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.
-    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;
-
-    /// @dev Lookup for '0123456789'.
-    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;
-
-    /// @dev Lookup for '0123456789abcdefABCDEF'.
-    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;
-
-    /// @dev Lookup for '01234567'.
-    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;
-
-    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'.
-    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;
-
-    /// @dev Lookup for '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'.
-    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;
-
-    /// @dev Lookup for ' \t\n\r\x0b\x0c'.
-    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                 STRING STORAGE OPERATIONS                  */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Sets the value of the string storage `$` to `s`.
-    function set(StringStorage storage $, string memory s) internal {
-        LibBytes.set(bytesStorage($), bytes(s));
-    }
-
-    /// @dev Sets the value of the string storage `$` to `s`.
-    function setCalldata(StringStorage storage $, string calldata s) internal {
-        LibBytes.setCalldata(bytesStorage($), bytes(s));
-    }
-
-    /// @dev Sets the value of the string storage `$` to the empty string.
-    function clear(StringStorage storage $) internal {
-        delete $._spacer;
-    }
-
-    /// @dev Returns whether the value stored is `$` is the empty string "".
-    function isEmpty(StringStorage storage $) internal view returns (bool) {
-        return uint256($._spacer) & 0xff == uint256(0);
-    }
-
-    /// @dev Returns the length of the value stored in `$`.
-    function length(StringStorage storage $) internal view returns (uint256) {
-        return LibBytes.length(bytesStorage($));
-    }
-
-    /// @dev Returns the value stored in `$`.
-    function get(StringStorage storage $) internal view returns (string memory) {
-        return string(LibBytes.get(bytesStorage($)));
-    }
-
-    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.
-    function uint8At(StringStorage storage $, uint256 i) internal view returns (uint8) {
-        return LibBytes.uint8At(bytesStorage($), i);
-    }
-
-    /// @dev Helper to cast `$` to a `BytesStorage`.
-    function bytesStorage(StringStorage storage $)
-        internal
-        pure
-        returns (LibBytes.BytesStorage storage casted)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            casted.slot := $.slot
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     DECIMAL OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the base 10 decimal representation of `value`.
-    function toString(uint256 value) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
-            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
-            // We will need 1 word for the trailing zeros padding, 1 word for the length,
-            // and 3 words for a maximum of 78 digits.
-            result := add(mload(0x40), 0x80)
-            mstore(0x40, add(result, 0x20)) // Allocate memory.
-            mstore(result, 0) // Zeroize the slot after the string.
-
-            let end := result // Cache the end of the memory to calculate the length later.
-            let w := not(0) // Tsk.
-            // We write the string from rightmost digit to leftmost digit.
-            // The following is essentially a do-while loop that also handles the zero case.
-            for { let temp := value } 1 {} {
-                result := add(result, w) // `sub(result, 1)`.
-                // Store the character to the pointer.
-                // The ASCII index of the '0' character is 48.
-                mstore8(result, add(48, mod(temp, 10)))
-                temp := div(temp, 10) // Keep dividing `temp` until zero.
-                if iszero(temp) { break }
-            }
-            let n := sub(end, result)
-            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the base 10 decimal representation of `value`.
-    function toString(int256 value) internal pure returns (string memory result) {
-        if (value >= 0) return toString(uint256(value));
-        unchecked {
-            result = toString(~uint256(value) + 1);
-        }
-        /// @solidity memory-safe-assembly
-        assembly {
-            // We still have some spare memory space on the left,
-            // as we have allocated 3 words (96 bytes) for up to 78 digits.
-            let n := mload(result) // Load the string length.
-            mstore(result, 0x2d) // Store the '-' character.
-            result := sub(result, 1) // Move back the string pointer by a byte.
-            mstore(result, add(n, 1)) // Update the string length.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                   HEXADECIMAL OPERATIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the hexadecimal representation of `value`,
-    /// left-padded to an input length of `byteCount` bytes.
-    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,
-    /// giving a total length of `byteCount * 2 + 2` bytes.
-    /// Reverts if `byteCount` is too small for the output to contain all the digits.
-    function toHexString(uint256 value, uint256 byteCount)
-        internal
-        pure
-        returns (string memory result)
-    {
-        result = toHexStringNoPrefix(value, byteCount);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := add(mload(result), 2) // Compute the length.
-            mstore(result, 0x3078) // Store the "0x" prefix.
-            result := sub(result, 2) // Move the pointer.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`,
-    /// left-padded to an input length of `byteCount` bytes.
-    /// The output is not prefixed with "0x" and is encoded using 2 hexadecimal digits per byte,
-    /// giving a total length of `byteCount * 2` bytes.
-    /// Reverts if `byteCount` is too small for the output to contain all the digits.
-    function toHexStringNoPrefix(uint256 value, uint256 byteCount)
-        internal
-        pure
-        returns (string memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes
-            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
-            // We add 0x20 to the total and round down to a multiple of 0x20.
-            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
-            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))
-            mstore(0x40, add(result, 0x20)) // Allocate memory.
-            mstore(result, 0) // Zeroize the slot after the string.
-
-            let end := result // Cache the end to calculate the length later.
-            // Store "0123456789abcdef" in scratch space.
-            mstore(0x0f, 0x30313233343536373839616263646566)
-
-            let start := sub(result, add(byteCount, byteCount))
-            let w := not(1) // Tsk.
-            let temp := value
-            // We write the string from rightmost digit to leftmost digit.
-            // The following is essentially a do-while loop that also handles the zero case.
-            for {} 1 {} {
-                result := add(result, w) // `sub(result, 2)`.
-                mstore8(add(result, 1), mload(and(temp, 15)))
-                mstore8(result, mload(and(shr(4, temp), 15)))
-                temp := shr(8, temp)
-                if iszero(xor(result, start)) { break }
-            }
-            if temp {
-                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.
-                revert(0x1c, 0x04)
-            }
-            let n := sub(end, result)
-            result := sub(result, 0x20)
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.
-    /// As address are 20 bytes long, the output will left-padded to have
-    /// a length of `20 * 2 + 2` bytes.
-    function toHexString(uint256 value) internal pure returns (string memory result) {
-        result = toHexStringNoPrefix(value);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := add(mload(result), 2) // Compute the length.
-            mstore(result, 0x3078) // Store the "0x" prefix.
-            result := sub(result, 2) // Move the pointer.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is prefixed with "0x".
-    /// The output excludes leading "0" from the `toHexString` output.
-    /// `0x00: "0x0", 0x01: "0x1", 0x12: "0x12", 0x123: "0x123"`.
-    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {
-        result = toHexStringNoPrefix(value);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.
-            let n := add(mload(result), 2) // Compute the length.
-            mstore(add(result, o), 0x3078) // Store the "0x" prefix, accounting for leading zero.
-            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.
-            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output excludes leading "0" from the `toHexStringNoPrefix` output.
-    /// `0x00: "0", 0x01: "1", 0x12: "12", 0x123: "123"`.
-    function toMinimalHexStringNoPrefix(uint256 value)
-        internal
-        pure
-        returns (string memory result)
-    {
-        result = toHexStringNoPrefix(value);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.
-            let n := mload(result) // Get the length.
-            result := add(result, o) // Move the pointer, accounting for leading zero.
-            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is encoded using 2 hexadecimal digits per byte.
-    /// As address are 20 bytes long, the output will left-padded to have
-    /// a length of `20 * 2` bytes.
-    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
-            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
-            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
-            result := add(mload(0x40), 0x80)
-            mstore(0x40, add(result, 0x20)) // Allocate memory.
-            mstore(result, 0) // Zeroize the slot after the string.
-
-            let end := result // Cache the end to calculate the length later.
-            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.
-
-            let w := not(1) // Tsk.
-            // We write the string from rightmost digit to leftmost digit.
-            // The following is essentially a do-while loop that also handles the zero case.
-            for { let temp := value } 1 {} {
-                result := add(result, w) // `sub(result, 2)`.
-                mstore8(add(result, 1), mload(and(temp, 15)))
-                mstore8(result, mload(and(shr(4, temp), 15)))
-                temp := shr(8, temp)
-                if iszero(temp) { break }
-            }
-            let n := sub(end, result)
-            result := sub(result, 0x20)
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is prefixed with "0x", encoded using 2 hexadecimal digits per byte,
-    /// and the alphabets are capitalized conditionally according to
-    /// https://eips.ethereum.org/EIPS/eip-55
-    function toHexStringChecksummed(address value) internal pure returns (string memory result) {
-        result = toHexString(value);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
-            let o := add(result, 0x22)
-            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
-            let t := shl(240, 136) // `0b10001000 << 240`
-            for { let i := 0 } 1 {} {
-                mstore(add(i, i), mul(t, byte(i, hashed)))
-                i := add(i, 1)
-                if eq(i, 20) { break }
-            }
-            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
-            o := add(o, 0x20)
-            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.
-    function toHexString(address value) internal pure returns (string memory result) {
-        result = toHexStringNoPrefix(value);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := add(mload(result), 2) // Compute the length.
-            mstore(result, 0x3078) // Store the "0x" prefix.
-            result := sub(result, 2) // Move the pointer.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hexadecimal representation of `value`.
-    /// The output is encoded using 2 hexadecimal digits per byte.
-    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            // Allocate memory.
-            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
-            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
-            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
-            mstore(0x40, add(result, 0x80))
-            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.
-
-            result := add(result, 2)
-            mstore(result, 40) // Store the length.
-            let o := add(result, 0x20)
-            mstore(add(o, 40), 0) // Zeroize the slot after the string.
-            value := shl(96, value)
-            // We write the string from rightmost digit to leftmost digit.
-            // The following is essentially a do-while loop that also handles the zero case.
-            for { let i := 0 } 1 {} {
-                let p := add(o, add(i, i))
-                let temp := byte(i, value)
-                mstore8(add(p, 1), mload(and(temp, 15)))
-                mstore8(p, mload(shr(4, temp)))
-                i := add(i, 1)
-                if eq(i, 20) { break }
-            }
-        }
-    }
-
-    /// @dev Returns the hex encoded string from the raw bytes.
-    /// The output is encoded using 2 hexadecimal digits per byte.
-    function toHexString(bytes memory raw) internal pure returns (string memory result) {
-        result = toHexStringNoPrefix(raw);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := add(mload(result), 2) // Compute the length.
-            mstore(result, 0x3078) // Store the "0x" prefix.
-            result := sub(result, 2) // Move the pointer.
-            mstore(result, n) // Store the length.
-        }
-    }
-
-    /// @dev Returns the hex encoded string from the raw bytes.
-    /// The output is encoded using 2 hexadecimal digits per byte.
-    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(raw)
-            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
-            mstore(result, add(n, n)) // Store the length of the output.
-
-            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.
-            let o := add(result, 0x20)
-            let end := add(raw, n)
-            for {} iszero(eq(raw, end)) {} {
-                raw := add(raw, 1)
-                mstore8(add(o, 1), mload(and(mload(raw), 15)))
-                mstore8(o, mload(and(shr(4, mload(raw)), 15)))
-                o := add(o, 2)
-            }
-            mstore(o, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(o, 0x20)) // Allocate memory.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                   RUNE STRING OPERATIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the number of UTF characters in the string.
-    function runeCount(string memory s) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if mload(s) {
-                mstore(0x00, div(not(0), 255))
-                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
-                let o := add(s, 0x20)
-                let end := add(o, mload(s))
-                for { result := 1 } 1 { result := add(result, 1) } {
-                    o := add(o, byte(0, mload(shr(250, mload(o)))))
-                    if iszero(lt(o, end)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Returns if this string is a 7-bit ASCII string.
-    /// (i.e. all characters codes are in [0..127])
-    function is7BitASCII(string memory s) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := 1
-            let mask := shl(7, div(not(0), 255))
-            let n := mload(s)
-            if n {
-                let o := add(s, 0x20)
-                let end := add(o, n)
-                let last := mload(end)
-                mstore(end, 0)
-                for {} 1 {} {
-                    if and(mask, mload(o)) {
-                        result := 0
-                        break
-                    }
-                    o := add(o, 0x20)
-                    if iszero(lt(o, end)) { break }
-                }
-                mstore(end, last)
-            }
-        }
-    }
-
-    /// @dev Returns if this string is a 7-bit ASCII string,
-    /// AND all characters are in the `allowed` lookup.
-    /// Note: If `s` is empty, returns true regardless of `allowed`.
-    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := 1
-            if mload(s) {
-                let allowed_ := shr(128, shl(128, allowed))
-                let o := add(s, 0x20)
-                for { let end := add(o, mload(s)) } 1 {} {
-                    result := and(result, shr(byte(0, mload(o)), allowed_))
-                    o := add(o, 1)
-                    if iszero(and(result, lt(o, end))) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Converts the bytes in the 7-bit ASCII string `s` to
-    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.
-    /// To save runtime gas, you can cache the result in an immutable variable.
-    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if mload(s) {
-                let o := add(s, 0x20)
-                for { let end := add(o, mload(s)) } 1 {} {
-                    result := or(result, shl(byte(0, mload(o)), 1))
-                    o := add(o, 1)
-                    if iszero(lt(o, end)) { break }
-                }
-                if shr(128, result) {
-                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.
-                    revert(0x1c, 0x04)
-                }
-            }
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                   BYTE STRING OPERATIONS                   */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // For performance and bytecode compactness, byte string operations are restricted
-    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.
-    // Usage of byte string operations on charsets with runes spanning two or more bytes
-    // can lead to undefined behavior.
-
-    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.
-    function replace(string memory subject, string memory needle, string memory replacement)
-        internal
-        pure
-        returns (string memory)
-    {
-        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right, starting from `from`.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOf(string memory subject, string memory needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return LibBytes.indexOf(bytes(subject), bytes(needle), from);
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from left to right.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {
-        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from right to left, starting from `from`.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function lastIndexOf(string memory subject, string memory needle, uint256 from)
-        internal
-        pure
-        returns (uint256)
-    {
-        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);
-    }
-
-    /// @dev Returns the byte index of the first location of `needle` in `subject`,
-    /// needleing from right to left.
-    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.
-    function lastIndexOf(string memory subject, string memory needle)
-        internal
-        pure
-        returns (uint256)
-    {
-        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);
-    }
-
-    /// @dev Returns true if `needle` is found in `subject`, false otherwise.
-    function contains(string memory subject, string memory needle) internal pure returns (bool) {
-        return LibBytes.contains(bytes(subject), bytes(needle));
-    }
-
-    /// @dev Returns whether `subject` starts with `needle`.
-    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {
-        return LibBytes.startsWith(bytes(subject), bytes(needle));
-    }
-
-    /// @dev Returns whether `subject` ends with `needle`.
-    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {
-        return LibBytes.endsWith(bytes(subject), bytes(needle));
-    }
-
-    /// @dev Returns `subject` repeated `times`.
-    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {
-        return string(LibBytes.repeat(bytes(subject), times));
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).
-    /// `start` and `end` are byte offsets.
-    function slice(string memory subject, uint256 start, uint256 end)
-        internal
-        pure
-        returns (string memory)
-    {
-        return string(LibBytes.slice(bytes(subject), start, end));
-    }
-
-    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.
-    /// `start` is a byte offset.
-    function slice(string memory subject, uint256 start) internal pure returns (string memory) {
-        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));
-    }
-
-    /// @dev Returns all the indices of `needle` in `subject`.
-    /// The indices are byte offsets.
-    function indicesOf(string memory subject, string memory needle)
-        internal
-        pure
-        returns (uint256[] memory)
-    {
-        return LibBytes.indicesOf(bytes(subject), bytes(needle));
-    }
-
-    /// @dev Returns an arrays of strings based on the `delimiter` inside of the `subject` string.
-    function split(string memory subject, string memory delimiter)
-        internal
-        pure
-        returns (string[] memory result)
-    {
-        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := a
-        }
-    }
-
-    /// @dev Returns a concatenated string of `a` and `b`.
-    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.
-    function concat(string memory a, string memory b) internal pure returns (string memory) {
-        return string(LibBytes.concat(bytes(a), bytes(b)));
-    }
-
-    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.
-    /// WARNING! This function is only compatible with 7-bit ASCII strings.
-    function toCase(string memory subject, bool toUpper)
-        internal
-        pure
-        returns (string memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := mload(subject)
-            if n {
-                result := mload(0x40)
-                let o := add(result, 0x20)
-                let d := sub(subject, result)
-                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
-                for { let end := add(o, n) } 1 {} {
-                    let b := byte(0, mload(add(d, o)))
-                    mstore8(o, xor(and(shr(b, flags), 0x20), b))
-                    o := add(o, 1)
-                    if eq(o, end) { break }
-                }
-                mstore(result, n) // Store the length.
-                mstore(o, 0) // Zeroize the slot after the string.
-                mstore(0x40, add(o, 0x20)) // Allocate memory.
-            }
-        }
-    }
-
-    /// @dev Returns a string from a small bytes32 string.
-    /// `s` must be null-terminated, or behavior will be undefined.
-    function fromSmallString(bytes32 s) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let n := 0
-            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\0'.
-            mstore(result, n) // Store the length.
-            let o := add(result, 0x20)
-            mstore(o, s) // Store the bytes of the string.
-            mstore(add(o, n), 0) // Zeroize the slot after the string.
-            mstore(0x40, add(result, 0x40)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns the small string, with all bytes after the first null byte zeroized.
-    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\0'.
-            mstore(0x00, s)
-            mstore(result, 0x00)
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Returns the string as a normalized null-terminated small string.
-    function toSmallString(string memory s) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(s)
-            if iszero(lt(result, 33)) {
-                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.
-                revert(0x1c, 0x04)
-            }
-            result := shl(shl(3, sub(32, result)), mload(add(s, result)))
-        }
-    }
-
-    /// @dev Returns a lowercased copy of the string.
-    /// WARNING! This function is only compatible with 7-bit ASCII strings.
-    function lower(string memory subject) internal pure returns (string memory result) {
-        result = toCase(subject, false);
-    }
-
-    /// @dev Returns an UPPERCASED copy of the string.
-    /// WARNING! This function is only compatible with 7-bit ASCII strings.
-    function upper(string memory subject) internal pure returns (string memory result) {
-        result = toCase(subject, true);
-    }
-
-    /// @dev Escapes the string to be used within HTML tags.
-    function escapeHTML(string memory s) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let end := add(s, mload(s))
-            let o := add(result, 0x20)
-            // Store the bytes of the packed offsets and strides into the scratch space.
-            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
-            mstore(0x1f, 0x900094)
-            mstore(0x08, 0xc0000000a6ab)
-            // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
-            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
-            for {} iszero(eq(s, end)) {} {
-                s := add(s, 1)
-                let c := and(mload(s), 0xff)
-                // Not in `["\"","'","&","<",">"]`.
-                if iszero(and(shl(c, 1), 0x500000c400000000)) {
-                    mstore8(o, c)
-                    o := add(o, 1)
-                    continue
-                }
-                let t := shr(248, mload(c))
-                mstore(o, mload(and(t, 0x1f)))
-                o := add(o, shr(5, t))
-            }
-            mstore(o, 0) // Zeroize the slot after the string.
-            mstore(result, sub(o, add(result, 0x20))) // Store the length.
-            mstore(0x40, add(o, 0x20)) // Allocate memory.
-        }
-    }
-
-    /// @dev Escapes the string to be used within double-quotes in a JSON.
-    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.
-    function escapeJSON(string memory s, bool addDoubleQuotes)
-        internal
-        pure
-        returns (string memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let o := add(result, 0x20)
-            if addDoubleQuotes {
-                mstore8(o, 34)
-                o := add(1, o)
-            }
-            // Store "\\u0000" in scratch space.
-            // Store "0123456789abcdef" in scratch space.
-            // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
-            // into the scratch space.
-            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
-            // Bitmask for detecting `["\"","\\"]`.
-            let e := or(shl(0x22, 1), shl(0x5c, 1))
-            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {
-                s := add(s, 1)
-                let c := and(mload(s), 0xff)
-                if iszero(lt(c, 0x20)) {
-                    if iszero(and(shl(c, 1), e)) {
-                        // Not in `["\"","\\"]`.
-                        mstore8(o, c)
-                        o := add(o, 1)
-                        continue
-                    }
-                    mstore8(o, 0x5c) // "\\".
-                    mstore8(add(o, 1), c)
-                    o := add(o, 2)
-                    continue
-                }
-                if iszero(and(shl(c, 1), 0x3700)) {
-                    // Not in `["\b","\t","\n","\f","\d"]`.
-                    mstore8(0x1d, mload(shr(4, c))) // Hex value.
-                    mstore8(0x1e, mload(and(c, 15))) // Hex value.
-                    mstore(o, mload(0x19)) // "\\u00XX".
-                    o := add(o, 6)
-                    continue
-                }
-                mstore8(o, 0x5c) // "\\".
-                mstore8(add(o, 1), mload(add(c, 8)))
-                o := add(o, 2)
-            }
-            if addDoubleQuotes {
-                mstore8(o, 34)
-                o := add(1, o)
-            }
-            mstore(o, 0) // Zeroize the slot after the string.
-            mstore(result, sub(o, add(result, 0x20))) // Store the length.
-            mstore(0x40, add(o, 0x20)) // Allocate memory.
-        }
-    }
-
-    /// @dev Escapes the string to be used within double-quotes in a JSON.
-    function escapeJSON(string memory s) internal pure returns (string memory result) {
-        result = escapeJSON(s, false);
-    }
-
-    /// @dev Encodes `s` so that it can be safely used in a URI,
-    /// just like `encodeURIComponent` in JavaScript.
-    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
-    /// See: https://datatracker.ietf.org/doc/html/rfc2396
-    /// See: https://datatracker.ietf.org/doc/html/rfc3986
-    function encodeURIComponent(string memory s) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            // Store "0123456789ABCDEF" in scratch space.
-            // Uppercased to be consistent with JavaScript's implementation.
-            mstore(0x0f, 0x30313233343536373839414243444546)
-            let o := add(result, 0x20)
-            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {
-                s := add(s, 1)
-                let c := and(mload(s), 0xff)
-                // If not in `[0-9A-Z-a-z-_.!~*'()]`.
-                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {
-                    mstore8(o, 0x25) // '%'.
-                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))
-                    mstore8(add(o, 2), mload(and(c, 15)))
-                    o := add(o, 3)
-                    continue
-                }
-                mstore8(o, c)
-                o := add(o, 1)
-            }
-            mstore(result, sub(o, add(result, 0x20))) // Store the length.
-            mstore(o, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(o, 0x20)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns whether `a` equals `b`.
-    function eq(string memory a, string memory b) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
-        }
-    }
-
-    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.
-    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // These should be evaluated on compile time, as far as possible.
-            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.
-            let x := not(or(m, or(b, add(m, and(b, m)))))
-            let r := shl(7, iszero(iszero(shr(128, x))))
-            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))
-            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
-            r := or(r, shl(4, lt(0xffff, shr(r, x))))
-            r := or(r, shl(3, lt(0xff, shr(r, x))))
-            // forgefmt: disable-next-item
-            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),
-                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))
-        }
-    }
-
-    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.
-    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.
-    function cmp(string memory a, string memory b) internal pure returns (int256) {
-        return LibBytes.cmp(bytes(a), bytes(b));
-    }
-
-    /// @dev Packs a single string with its length into a single word.
-    /// Returns `bytes32(0)` if the length is zero or greater than 31.
-    function packOne(string memory a) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // We don't need to zero right pad the string,
-            // since this is our own custom non-standard packing scheme.
-            result :=
-                mul(
-                    // Load the length and the bytes.
-                    mload(add(a, 0x1f)),
-                    // `length != 0 && length < 32`. Abuses underflow.
-                    // Assumes that the length is valid and within the block gas limit.
-                    lt(sub(mload(a), 1), 0x1f)
-                )
-        }
-    }
-
-    /// @dev Unpacks a string packed using {packOne}.
-    /// Returns the empty string if `packed` is `bytes32(0)`.
-    /// If `packed` is not an output of {packOne}, the output behavior is undefined.
-    function unpackOne(bytes32 packed) internal pure returns (string memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40) // Grab the free memory pointer.
-            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).
-            mstore(result, 0) // Zeroize the length slot.
-            mstore(add(result, 0x1f), packed) // Store the length and bytes.
-            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.
-        }
-    }
-
-    /// @dev Packs two strings with their lengths into a single word.
-    /// Returns `bytes32(0)` if combined length is zero or greater than 30.
-    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let aLen := mload(a)
-            // We don't need to zero right pad the strings,
-            // since this is our own custom non-standard packing scheme.
-            result :=
-                mul(
-                    or( // Load the length and the bytes of `a` and `b`.
-                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),
-                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.
-                    // Assumes that the lengths are valid and within the block gas limit.
-                    lt(sub(add(aLen, mload(b)), 1), 0x1e)
-                )
-        }
-    }
-
-    /// @dev Unpacks strings packed using {packTwo}.
-    /// Returns the empty strings if `packed` is `bytes32(0)`.
-    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.
-    function unpackTwo(bytes32 packed)
-        internal
-        pure
-        returns (string memory resultA, string memory resultB)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            resultA := mload(0x40) // Grab the free memory pointer.
-            resultB := add(resultA, 0x40)
-            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
-            mstore(0x40, add(resultB, 0x40))
-            // Zeroize the length slots.
-            mstore(resultA, 0)
-            mstore(resultB, 0)
-            // Store the lengths and bytes.
-            mstore(add(resultA, 0x1f), packed)
-            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
-            // Right pad with zeroes.
-            mstore(add(add(resultA, 0x20), mload(resultA)), 0)
-            mstore(add(add(resultB, 0x20), mload(resultB)), 0)
-        }
-    }
-
-    /// @dev Directly returns `a` without copying.
-    function directReturn(string memory a) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Assumes that the string does not start from the scratch space.
-            let retStart := sub(a, 0x20)
-            let retUnpaddedSize := add(mload(a), 0x40)
-            // Right pad with zeroes. Just in case the string is produced
-            // by a method that doesn't zero right pad.
-            mstore(add(retStart, retUnpaddedSize), 0)
-            mstore(retStart, 0x20) // Store the return offset.
-            // End the transaction, returning the string.
-            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))
-        }
-    }
-}
diff --git a/src/utils/g/LibTransient.sol b/src/utils/g/LibTransient.sol
deleted file mode 100644
index 23b53a9..0000000
--- a/src/utils/g/LibTransient.sol
+++ /dev/null
@@ -1,973 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Pointer struct to a `uint256` in transient storage.
-struct TUint256 {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a `int256` in transient storage.
-struct TInt256 {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a `bytes32` in transient storage.
-struct TBytes32 {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a `address` in transient storage.
-struct TAddress {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a `bool` in transient storage.
-struct TBool {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a `bytes` in transient storage.
-struct TBytes {
-    uint256 _spacer;
-}
-
-/// @dev Pointer struct to a stack pointer generator in transient storage.
-/// This stack does not directly take in values. Instead, it generates pointers
-/// that can be casted to any of the other transient storage pointer struct.
-struct TStack {
-    uint256 _spacer;
-}
-
-using LibTransient for TUint256 global;
-using LibTransient for TInt256 global;
-using LibTransient for TBytes32 global;
-using LibTransient for TAddress global;
-using LibTransient for TBool global;
-using LibTransient for TBytes global;
-using LibTransient for TStack global;
-
-/// @notice Library for transient storage operations.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/LibTransient.sol)
-/// @author Modified from Transient Goodies by Philogy (https://github.com/Philogy/transient-goodies/blob/main/src/TransientBytesLib.sol)
-///
-/// @dev Note: The functions postfixed with `Compat` will only use transient storage on L1.
-/// L2s are super cheap anyway.
-/// For best safety, always clear the storage after use.
-library LibTransient {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The transient stack is empty.
-    error StackIsEmpty();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         CONSTANTS                          */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The storage slot seed for converting a transient slot to a storage slot.
-    /// `bytes4(keccak256("_LIB_TRANSIENT_COMPAT_SLOT_SEED"))`.
-    uint256 private constant _LIB_TRANSIENT_COMPAT_SLOT_SEED = 0x5a0b45f2;
-
-    /// @dev Multiplier to stack base slot, so that in the case where two stacks
-    /// share consecutive base slots, their pointers will likely not overlap. A prime.
-    uint256 private constant _STACK_BASE_SALT = 0x9e076501211e1371b;
-
-    /// @dev The canonical address of the transient registry.
-    /// See: https://gist.github.com/Vectorized/4ab665d7a234ef5aaaff2e5091ec261f
-    address internal constant REGISTRY = 0x000000000000297f64C7F8d9595e43257908F170;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     UINT256 OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `uint256` in transient storage.
-    function tUint256(bytes32 tSlot) internal pure returns (TUint256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `uint256` in transient storage.
-    function tUint256(uint256 tSlot) internal pure returns (TUint256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TUint256 storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TUint256 storage ptr) internal view returns (uint256 result) {
-        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer;
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TUint256 storage ptr, uint256 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TUint256 storage ptr, uint256 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = value;
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TUint256 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TUint256 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function inc(TUint256 storage ptr) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function incCompat(TUint256 storage ptr) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function inc(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) + delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function dec(TUint256 storage ptr) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TUint256 storage ptr) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function dec(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        set(ptr, newValue = get(ptr) - delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := tload(ptr.slot)
-            newValue := add(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            tstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incSignedCompat(TUint256 storage ptr, int256 delta)
-        internal
-        returns (uint256 newValue)
-    {
-        if (block.chainid == 1) return incSigned(ptr, delta);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := sload(ptr.slot)
-            newValue := add(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            sstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := tload(ptr.slot)
-            newValue := sub(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            tstore(ptr.slot, newValue)
-        }
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decSignedCompat(TUint256 storage ptr, int256 delta)
-        internal
-        returns (uint256 newValue)
-    {
-        if (block.chainid == 1) return decSigned(ptr, delta);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let currentValue := sload(ptr.slot)
-            newValue := sub(currentValue, delta)
-            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {
-                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.
-                mstore(0x20, 0x11) // Underflow or overflow panic.
-                revert(0x1c, 0x24)
-            }
-            sstore(ptr.slot, newValue)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     INT256 OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `int256` in transient storage.
-    function tInt256(bytes32 tSlot) internal pure returns (TInt256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `int256` in transient storage.
-    function tInt256(uint256 tSlot) internal pure returns (TInt256 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TInt256 storage ptr) internal view returns (int256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TInt256 storage ptr) internal view returns (int256 result) {
-        result = block.chainid == 1 ? get(ptr) : int256(_compat(ptr)._spacer);
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TInt256 storage ptr, int256 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TInt256 storage ptr, int256 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint256(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TInt256 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TInt256 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function inc(TInt256 storage ptr) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by 1.
-    function incCompat(TInt256 storage ptr) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + 1);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function inc(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) + delta);
-    }
-
-    /// @dev Increments the value at transient `ptr` by `delta`.
-    function incCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) + delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function dec(TInt256 storage ptr) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by 1.
-    function decCompat(TInt256 storage ptr) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - 1);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function dec(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        set(ptr, newValue = get(ptr) - delta);
-    }
-
-    /// @dev Decrements the value at transient `ptr` by `delta`.
-    function decCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {
-        setCompat(ptr, newValue = getCompat(ptr) - delta);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     BYTES32 OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bytes32` in transient storage.
-    function tBytes32(bytes32 tSlot) internal pure returns (TBytes32 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bytes32` in transient storage.
-    function tBytes32(uint256 tSlot) internal pure returns (TBytes32 storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TBytes32 storage ptr) internal view returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TBytes32 storage ptr) internal view returns (bytes32 result) {
-        result = block.chainid == 1 ? get(ptr) : bytes32(_compat(ptr)._spacer);
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBytes32 storage ptr, bytes32 value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, value)
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBytes32 storage ptr, bytes32 value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint256(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBytes32 storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBytes32 storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                     ADDRESS OPERATIONS                     */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `address` in transient storage.
-    function tAddress(bytes32 tSlot) internal pure returns (TAddress storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `address` in transient storage.
-    function tAddress(uint256 tSlot) internal pure returns (TAddress storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TAddress storage ptr) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TAddress storage ptr) internal view returns (address result) {
-        result = block.chainid == 1 ? get(ptr) : address(uint160(_compat(ptr)._spacer));
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TAddress storage ptr, address value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, shr(96, shl(96, value)))
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TAddress storage ptr, address value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        _compat(ptr)._spacer = uint160(value);
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TAddress storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TAddress storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      BOOL OPERATIONS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bool` in transient storage.
-    function tBool(bytes32 tSlot) internal pure returns (TBool storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bool` in transient storage.
-    function tBool(uint256 tSlot) internal pure returns (TBool storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function get(TBool storage ptr) internal view returns (bool result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := tload(ptr.slot)
-        }
-    }
-
-    /// @dev Returns the value at transient `ptr`.
-    function getCompat(TBool storage ptr) internal view returns (bool result) {
-        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer != 0;
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBool storage ptr, bool value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, iszero(iszero(value)))
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBool storage ptr, bool value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, iszero(iszero(value)))
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBool storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBool storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      BYTES OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a `bytes` in transient storage.
-    function tBytes(bytes32 tSlot) internal pure returns (TBytes storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a `bytes` in transient storage.
-    function tBytes(uint256 tSlot) internal pure returns (TBytes storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the length of the bytes stored at transient `ptr`.
-    function length(TBytes storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(224, tload(ptr.slot))
-        }
-    }
-
-    /// @dev Returns the length of the bytes stored at transient `ptr`.
-    function lengthCompat(TBytes storage ptr) internal view returns (uint256 result) {
-        if (block.chainid == 1) return length(ptr);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(224, sload(ptr.slot))
-        }
-    }
-
-    /// @dev Returns the bytes stored at transient `ptr`.
-    function get(TBytes storage ptr) internal view returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 0x00)
-            mstore(add(result, 0x1c), tload(ptr.slot)) // Length and first `0x1c` bytes.
-            let n := mload(result)
-            let e := add(add(result, 0x20), n)
-            if iszero(lt(n, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let d := sub(keccak256(0x00, 0x20), result)
-                for { let o := add(result, 0x3c) } 1 {} {
-                    mstore(o, tload(add(o, d)))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-            mstore(e, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(0x20, e)) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns the bytes stored at transient `ptr`.
-    function getCompat(TBytes storage ptr) internal view returns (bytes memory result) {
-        if (block.chainid == 1) return get(ptr);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(result, 0x00)
-            mstore(add(result, 0x1c), sload(ptr.slot)) // Length and first `0x1c` bytes.
-            let n := mload(result)
-            let e := add(add(result, 0x20), n)
-            if iszero(lt(n, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let d := sub(keccak256(0x00, 0x20), result)
-                for { let o := add(result, 0x3c) } 1 {} {
-                    mstore(o, sload(add(o, d)))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-            mstore(e, 0) // Zeroize the slot after the string.
-            mstore(0x40, add(0x20, e)) // Allocate memory.
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function set(TBytes storage ptr, bytes memory value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, mload(add(value, 0x1c)))
-            if iszero(lt(mload(value), 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(add(value, 0x20), mload(value))
-                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)
-                for { let o := add(value, 0x3c) } 1 {} {
-                    tstore(add(o, d), mload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCompat(TBytes storage ptr, bytes memory value) internal {
-        if (block.chainid == 1) return set(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, mload(add(value, 0x1c)))
-            if iszero(lt(mload(value), 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(add(value, 0x20), mload(value))
-                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)
-                for { let o := add(value, 0x3c) } 1 {} {
-                    sstore(add(o, d), mload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCalldata(TBytes storage ptr, bytes calldata value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))
-            if iszero(lt(value.length, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(value.offset, value.length)
-                // forgefmt: disable-next-item
-                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),
-                    value.offset), 0x20)
-                for { let o := add(value.offset, 0x1c) } 1 {} {
-                    tstore(add(o, d), calldataload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Sets the value at transient `ptr`.
-    function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal {
-        if (block.chainid == 1) return setCalldata(ptr, value);
-        ptr = _compat(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            sstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))
-            if iszero(lt(value.length, 0x1d)) {
-                mstore(0x00, ptr.slot)
-                let e := add(value.offset, value.length)
-                // forgefmt: disable-next-item
-                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),
-                    value.offset), 0x20)
-                for { let o := add(value.offset, 0x1c) } 1 {} {
-                    sstore(add(o, d), calldataload(o))
-                    o := add(o, 0x20)
-                    if iszero(lt(o, e)) { break }
-                }
-            }
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clear(TBytes storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            tstore(ptr.slot, 0)
-        }
-    }
-
-    /// @dev Clears the value at transient `ptr`.
-    function clearCompat(TBytes storage ptr) internal {
-        if (block.chainid == 1) return clear(ptr);
-        _compat(ptr)._spacer = 0;
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      STACK OPERATIONS                      */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a pointer to a stack in transient storage.
-    function tStack(bytes32 tSlot) internal pure returns (TStack storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns a pointer to a stack in transient storage.
-    function tStack(uint256 tSlot) internal pure returns (TStack storage ptr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            ptr.slot := tSlot
-        }
-    }
-
-    /// @dev Returns the number of elements in the stack.
-    function length(TStack storage ptr) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(160, shl(128, tload(ptr.slot))) // Removes the base offset and stride.
-        }
-    }
-
-    /// @dev Clears the stack at `ptr`.
-    /// Note: Future usage of the stack will point to a fresh transient storage region.
-    function clear(TStack storage ptr) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Clears the length and increments the base pointer by `1 << 128`.
-            tstore(ptr.slot, shl(128, add(1, shr(128, tload(ptr.slot)))))
-        }
-    }
-
-    /// @dev Increments the stack length by 1, and returns a pointer to the top element.
-    /// We don't want to call this `push` as it does not take in an element value.
-    /// Note: The value pointed to might not be cleared from previous usage.
-    function place(TStack storage ptr) internal returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            topPtr := add(0x100000000, tload(ptr.slot)) // Increments by a stride.
-            tstore(ptr.slot, topPtr)
-            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)
-        }
-    }
-
-    /// @dev Returns a pointer to the top element. Returns the zero pointer if the stack is empty.
-    /// This method can help avoid an additional `TLOAD`, but you MUST check if the
-    /// returned pointer is zero. And if it is, please DO NOT read / write to it.
-    function peek(TStack storage ptr) internal view returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let t := tload(ptr.slot)
-            topPtr := mul(iszero(iszero(shl(128, t))), add(mul(_STACK_BASE_SALT, ptr.slot), t))
-        }
-    }
-
-    /// @dev Returns a pointer to the top element. Reverts if the stack is empty.
-    function top(TStack storage ptr) internal view returns (bytes32 topPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            topPtr := tload(ptr.slot)
-            if iszero(topPtr) {
-                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)
-        }
-    }
-
-    /// @dev Decrements the stack length by 1, returns a pointer to the top element
-    /// before the popping. Reverts if the stack is empty.
-    /// Note: Popping from the stack does NOT auto-clear the top value.
-    function pop(TStack storage ptr) internal returns (bytes32 lastTopPtr) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            lastTopPtr := tload(ptr.slot)
-            if iszero(lastTopPtr) {
-                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            tstore(ptr.slot, sub(lastTopPtr, 0x100000000)) // Decrements by a stride.
-            lastTopPtr := add(mul(_STACK_BASE_SALT, ptr.slot), lastTopPtr)
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*               TRANSIENT REGISTRY OPERATIONS                */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Sets the value for the key.
-    /// If the key does not exist, its admin will be set to the caller.
-    /// If the key already exist, its value will be overwritten,
-    /// and the caller must be the current admin for the key.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registrySet(bytes32 key, bytes memory value) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(m, 0xaac438c0) // `set(bytes32,bytes)`.
-            mstore(add(m, 0x20), key)
-            mstore(add(m, 0x40), 0x40)
-            let n := mload(value)
-            mstore(add(m, 0x60), n)
-            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {
-                mstore(add(add(m, 0x80), i), mload(add(add(value, 0x20), i)))
-            }
-            if iszero(
-                mul(
-                    returndatasize(),
-                    call(gas(), REGISTRY, 0, add(m, 0x1c), add(n, 0x64), 0x00, 0x20)
-                )
-            ) { revert(0x00, returndatasize()) }
-        }
-    }
-
-    /// @dev Returns the value for the key.
-    /// Reverts if the key does not exist.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryGet(bytes32 key) internal view returns (bytes memory result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            mstore(0x00, 0x8eaa6ac0) // `get(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            // We can safely assume that the bytes will be containing the 0x20 offset.
-            returndatacopy(result, 0x20, sub(returndatasize(), 0x20))
-            mstore(0x40, add(result, returndatasize())) // Allocate memory.
-        }
-    }
-
-    /// @dev Clears the admin and the value for the key.
-    /// The caller must be the current admin of the key.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryClear(bytes32 key) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0x97040a45) // `clear(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-        }
-    }
-
-    /// @dev Returns the admin of the key.
-    /// Returns `address(0)` if the key does not exist.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryAdminOf(bytes32 key) internal view returns (address result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, 0xc5344411) // `adminOf(bytes32)`.
-            mstore(0x20, key)
-            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            result := mload(0x00)
-        }
-    }
-
-    /// @dev Changes the admin of the key.
-    /// The caller must be the current admin of the key.
-    /// The new admin must not be `address(0)`.
-    /// Reverts with empty data if the registry has not been deployed.
-    function registryChangeAdmin(bytes32 key, address newAdmin) internal {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40) // Cache the free memory pointer.
-            mstore(0x00, 0x053b1ca3) // `changeAdmin(bytes32,address)`.
-            mstore(0x20, key)
-            mstore(0x40, shr(96, shl(96, newAdmin)))
-            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x44, 0x00, 0x20))) {
-                revert(0x00, returndatasize())
-            }
-            mstore(0x40, m) // Restore the free memory pointer.
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TUint256 storage ptr) private pure returns (TUint256 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TInt256 storage ptr) private pure returns (TInt256 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBytes32 storage ptr) private pure returns (TBytes32 storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TAddress storage ptr) private pure returns (TAddress storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBool storage ptr) private pure returns (TBool storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-
-    /// @dev Returns a regular storage pointer used for compatibility.
-    function _compat(TBytes storage ptr) private pure returns (TBytes storage c) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)
-            mstore(0x00, ptr.slot)
-            c.slot := keccak256(0x00, 0x24)
-        }
-    }
-}
diff --git a/src/utils/g/MinHeapLib.sol b/src/utils/g/MinHeapLib.sol
deleted file mode 100644
index fe80d0a..0000000
--- a/src/utils/g/MinHeapLib.sol
+++ /dev/null
@@ -1,581 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A heap in storage.
-struct Heap {
-    uint256[] data;
-}
-
-/// @dev A heap in memory.
-struct MemHeap {
-    uint256[] data;
-}
-
-using MinHeapLib for Heap global;
-using MinHeapLib for MemHeap global;
-
-/// @notice Library for managing a min-heap in storage or memory.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/MinHeapLib.sol)
-library MinHeapLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The heap is empty.
-    error HeapIsEmpty();
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    // Tips:
-    // - To use as a max-heap, bitwise negate the input and output values (e.g. `heap.push(~x)`).
-    // - To use on tuples, pack the tuple values into a single integer.
-    // - To use on signed integers, convert the signed integers into
-    //   their ordered unsigned counterparts via `uint256(x) + (1 << 255)`.
-
-    /// @dev Returns the minimum value of the heap.
-    /// Reverts if the heap is empty.
-    function root(Heap storage heap) internal view returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(sload(heap.slot)) {
-                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            mstore(0x00, heap.slot)
-            result := sload(keccak256(0x00, 0x20))
-        }
-    }
-
-    /// @dev Returns the minimum value of the heap.
-    /// Reverts if the heap is empty.
-    function root(MemHeap memory heap) internal pure returns (uint256 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(heap)
-            if iszero(mload(result)) {
-                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.
-                revert(0x1c, 0x04)
-            }
-            result := mload(add(0x20, result))
-        }
-    }
-
-    /// @dev Reserves at least `minimum` slots of memory for the heap.
-    /// Helps avoid reallocation if you already know the max size of the heap.
-    function reserve(MemHeap memory heap, uint256 minimum) internal pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let w := not(0x1f)
-            let prime := 204053801631428327883786711931463459222251954273621
-            let cap := not(mload(add(mload(heap), w)))
-            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {
-                let data := mload(heap)
-                let n := mload(data)
-                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.
-                mstore(mload(0x40), not(mul(newCap, prime)))
-                let m := add(mload(0x40), 0x20)
-                mstore(m, n) // Store the length.
-                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.
-                mstore(heap, m) // Update `heap.data`.
-                if n {
-                    for { let i := shl(5, n) } 1 {} {
-                        mstore(add(m, i), mload(add(data, i)))
-                        i := add(i, w)
-                        if iszero(i) { break }
-                    }
-                }
-            }
-        }
-    }
-
-    /// @dev Returns an array of the `k` smallest items in the heap,
-    /// sorted in ascending order, without modifying the heap.
-    /// If the heap has less than `k` items, all items in the heap will be returned.
-    function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function pIndex(h_, p_) -> _i {
-                _i := mload(add(0x20, add(h_, shl(6, p_))))
-            }
-            function pValue(h_, p_) -> _v {
-                _v := mload(add(h_, shl(6, p_)))
-            }
-            function pSet(h_, p_, i_, v_) {
-                mstore(add(h_, shl(6, p_)), v_)
-                mstore(add(0x20, add(h_, shl(6, p_))), i_)
-            }
-            function pSiftdown(h_, p_, i_, v_) {
-                for {} 1 {} {
-                    let u_ := shr(1, sub(p_, 1))
-                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }
-                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))
-                    p_ := u_
-                }
-                pSet(h_, p_, i_, v_)
-            }
-            function pSiftup(h_, e_, i_, v_) {
-                let p_ := 0
-                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {
-                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))
-                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))
-                    p_ := c_
-                }
-                pSiftdown(h_, p_, i_, v_)
-            }
-            a := mload(0x40)
-            mstore(0x00, heap.slot)
-            let sOffset := keccak256(0x00, 0x20)
-            let o := add(a, 0x20) // Offset into `a`.
-            let n := sload(heap.slot) // The number of items in the heap.
-            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.
-            let h := add(o, shl(5, m)) // Priority queue.
-            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.
-            for { let e := iszero(eq(o, h)) } e {} {
-                mstore(o, pValue(h, 0))
-                o := add(0x20, o)
-                if eq(o, h) { break }
-                let childPos := add(shl(1, pIndex(h, 0)), 1)
-                if iszero(lt(childPos, n)) {
-                    e := sub(e, 1)
-                    pSiftup(h, e, pIndex(h, e), pValue(h, e))
-                    continue
-                }
-                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))
-                childPos := add(1, childPos)
-                if iszero(eq(childPos, n)) {
-                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))
-                    e := add(e, 1)
-                }
-            }
-            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.
-            mstore(0x40, o) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns an array of the `k` smallest items in the heap,
-    /// sorted in ascending order, without modifying the heap.
-    /// If the heap has less than `k` items, all items in the heap will be returned.
-    function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function pIndex(h_, p_) -> _i {
-                _i := mload(add(0x20, add(h_, shl(6, p_))))
-            }
-            function pValue(h_, p_) -> _v {
-                _v := mload(add(h_, shl(6, p_)))
-            }
-            function pSet(h_, p_, i_, v_) {
-                mstore(add(h_, shl(6, p_)), v_)
-                mstore(add(0x20, add(h_, shl(6, p_))), i_)
-            }
-            function pSiftdown(h_, p_, i_, v_) {
-                for {} 1 {} {
-                    let u_ := shr(1, sub(p_, 1))
-                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }
-                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))
-                    p_ := u_
-                }
-                pSet(h_, p_, i_, v_)
-            }
-            function pSiftup(h_, e_, i_, v_) {
-                let p_ := 0
-                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {
-                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))
-                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))
-                    p_ := c_
-                }
-                pSiftdown(h_, p_, i_, v_)
-            }
-            a := mload(0x40)
-            let sOffset := add(mload(heap), 0x20)
-            let o := add(a, 0x20) // Offset into `a`.
-            let n := mload(mload(heap)) // The number of items in the heap.
-            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.
-            let h := add(o, shl(5, m)) // Priority queue.
-            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.
-            for { let e := iszero(eq(o, h)) } e {} {
-                mstore(o, pValue(h, 0))
-                o := add(0x20, o)
-                if eq(o, h) { break }
-                let childPos := add(shl(1, pIndex(h, 0)), 1)
-                if iszero(lt(childPos, n)) {
-                    e := sub(e, 1)
-                    pSiftup(h, e, pIndex(h, e), pValue(h, e))
-                    continue
-                }
-                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))
-                childPos := add(1, childPos)
-                if iszero(eq(childPos, n)) {
-                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))
-                    e := add(e, 1)
-                }
-            }
-            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.
-            mstore(0x40, o) // Allocate memory.
-        }
-    }
-
-    /// @dev Returns the number of items in the heap.
-    function length(Heap storage heap) internal view returns (uint256) {
-        return heap.data.length;
-    }
-
-    /// @dev Returns the number of items in the heap.
-    function length(MemHeap memory heap) internal pure returns (uint256) {
-        return heap.data.length;
-    }
-
-    /// @dev Pushes the `value` onto the min-heap.
-    function push(Heap storage heap, uint256 value) internal {
-        _set(heap, value, 0, 3);
-    }
-
-    /// @dev Pushes the `value` onto the min-heap.
-    function push(MemHeap memory heap, uint256 value) internal pure {
-        _set(heap, value, 0, 3);
-    }
-
-    /// @dev Pops the minimum value from the min-heap.
-    /// Reverts if the heap is empty.
-    function pop(Heap storage heap) internal returns (uint256 popped) {
-        (, popped) = _set(heap, 0, 0, 2);
-    }
-
-    /// @dev Pops the minimum value from the min-heap.
-    /// Reverts if the heap is empty.
-    function pop(MemHeap memory heap) internal pure returns (uint256 popped) {
-        (, popped) = _set(heap, 0, 0, 2);
-    }
-
-    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.
-    function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {
-        (, popped) = _set(heap, value, 0, 4);
-    }
-
-    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.
-    function pushPop(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {
-        (, popped) = _set(heap, value, 0, 4);
-    }
-
-    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.
-    /// Reverts if the heap is empty.
-    function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {
-        (, popped) = _set(heap, value, 0, 1);
-    }
-
-    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.
-    /// Reverts if the heap is empty.
-    function replace(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {
-        (, popped) = _set(heap, value, 0, 1);
-    }
-
-    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value
-    /// if the length of the heap exceeds `maxLength`.
-    ///
-    /// Reverts if `maxLength` is zero.
-    ///
-    /// - If the queue is not full:
-    ///   (`success` = true, `hasPopped` = false, `popped` = 0)
-    /// - If the queue is full, and `value` is not greater than the minimum value:
-    ///   (`success` = false, `hasPopped` = false, `popped` = 0)
-    /// - If the queue is full, and `value` is greater than the minimum value:
-    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)
-    ///
-    /// Useful for implementing a bounded priority queue.
-    ///
-    /// It is technically possible for the heap size to exceed `maxLength`
-    /// if `enqueue` has been previously called with a larger `maxLength`.
-    /// In such a case, the heap will be treated exactly as if it is full,
-    /// conditionally popping the minimum value if `value` is greater than it.
-    ///
-    /// Under normal usage, which keeps `maxLength` constant throughout
-    /// the lifetime of a heap, this out-of-spec edge case will not be triggered.
-    function enqueue(Heap storage heap, uint256 value, uint256 maxLength)
-        internal
-        returns (bool success, bool hasPopped, uint256 popped)
-    {
-        (value, popped) = _set(heap, value, maxLength, 0);
-        /// @solidity memory-safe-assembly
-        assembly {
-            hasPopped := eq(3, value)
-            success := value
-        }
-    }
-
-    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value
-    /// if the length of the heap exceeds `maxLength`.
-    ///
-    /// Reverts if `maxLength` is zero.
-    ///
-    /// - If the queue is not full:
-    ///   (`success` = true, `hasPopped` = false, `popped` = 0)
-    /// - If the queue is full, and `value` is not greater than the minimum value:
-    ///   (`success` = false, `hasPopped` = false, `popped` = 0)
-    /// - If the queue is full, and `value` is greater than the minimum value:
-    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)
-    ///
-    /// Useful for implementing a bounded priority queue.
-    function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)
-        internal
-        pure
-        returns (bool success, bool hasPopped, uint256 popped)
-    {
-        (value, popped) = _set(heap, value, maxLength, 0);
-        /// @solidity memory-safe-assembly
-        assembly {
-            hasPopped := eq(3, value)
-            success := value
-        }
-    }
-
-    /// @dev Increments the free memory pointer by a word and fills the word with 0.
-    /// This is if you want to take extra precaution that the memory word slot before
-    /// the `data` array in `MemHeap` doesn't contain a non-zero multiple of prime
-    /// to masquerade as a prime-checksummed capacity.
-    /// If you are not directly assigning some array to `data`,
-    /// you don't have to worry about it.
-    function bumpFreeMemoryPointer() internal pure {
-        uint256 zero;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-            mstore(m, zero)
-            mstore(0x40, add(m, 0x20))
-        }
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Helper function for heap operations.
-    /// Designed for code conciseness, bytecode compactness, and decent performance.
-    function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)
-        private
-        returns (uint256 status, uint256 popped)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let n := sload(heap.slot)
-            mstore(0x00, heap.slot)
-            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.
-            let pos := 0
-            let childPos := not(0)
-            // Operations are ordered from most likely usage to least likely usage.
-            for {} 1 {
-                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.
-                revert(0x1c, 0x04)
-            } {
-                // Mode: `enqueue`.
-                if iszero(mode) {
-                    if iszero(maxLength) { continue }
-                    // If queue is full.
-                    if iszero(lt(n, maxLength)) {
-                        let r := sload(sOffset)
-                        if iszero(lt(r, value)) { break }
-                        status := 3
-                        childPos := 1
-                        popped := r
-                        break
-                    }
-                    status := 1
-                    pos := n
-                    // Increment and update the length.
-                    sstore(heap.slot, add(pos, 1))
-                    childPos := sOffset
-                    break
-                }
-                if iszero(gt(mode, 2)) {
-                    if iszero(n) { continue }
-                    // Mode: `pop`.
-                    if eq(mode, 2) {
-                        // Decrement and update the length.
-                        n := sub(n, 1)
-                        sstore(heap.slot, n)
-                        // Set the `value` to the last item.
-                        value := sload(add(sOffset, n))
-                        popped := value
-                        if iszero(n) { break }
-                    }
-                    // Mode: `replace`.
-                    popped := sload(sOffset)
-                    childPos := 1
-                    break
-                }
-                // Mode: `push`.
-                if eq(mode, 3) {
-                    // Increment and update the length.
-                    pos := n
-                    sstore(heap.slot, add(pos, 1))
-                    // `sOffset` is used as a value that is `>= n` and `< not(0)`.
-                    childPos := sOffset
-                    break
-                }
-                // Mode: `pushPop`.
-                popped := value
-                if iszero(n) { break }
-                let r := sload(sOffset)
-                if iszero(lt(r, value)) { break }
-                popped := r
-                childPos := 1
-                break
-            }
-            // Siftup.
-            for {} lt(childPos, n) {} {
-                let child := sload(add(sOffset, childPos))
-                let rightPos := add(childPos, 1)
-                let right := sload(add(sOffset, rightPos))
-                if iszero(gt(lt(rightPos, n), lt(child, right))) {
-                    right := child
-                    rightPos := childPos
-                }
-                sstore(add(sOffset, pos), right)
-                pos := rightPos
-                childPos := add(shl(1, pos), 1)
-            }
-            // Siftdown.
-            for {} pos {} {
-                let parentPos := shr(1, sub(pos, 1))
-                let parent := sload(add(sOffset, parentPos))
-                if iszero(lt(value, parent)) { break }
-                sstore(add(sOffset, pos), parent)
-                pos := parentPos
-            }
-            // If `childPos` has been changed from `not(0)`.
-            if add(childPos, 1) { sstore(add(sOffset, pos), value) }
-        }
-    }
-
-    /// @dev Helper function for heap operations.
-    /// Designed for code conciseness, bytecode compactness, and decent performance.
-    function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)
-        private
-        pure
-        returns (uint256 status, uint256 popped)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            let data := mload(heap)
-            let n := mload(data)
-            // Allocation / reallocation.
-            for {
-                let cap := not(mload(sub(data, 0x20)))
-                let prime := 204053801631428327883786711931463459222251954273621
-                cap := mul(iszero(mod(cap, prime)), div(cap, prime))
-            } iszero(lt(n, cap)) {} {
-                let newCap := add(add(cap, cap), shl(5, iszero(cap)))
-                if iszero(or(cap, iszero(n))) {
-                    for { cap := n } iszero(gt(newCap, n)) {} { newCap := add(newCap, newCap) }
-                }
-                mstore(mload(0x40), not(mul(newCap, prime))) // Update `heap.capacity`.
-                let m := add(mload(0x40), 0x20)
-                mstore(m, n) // Store the length.
-                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.
-                if cap {
-                    let w := not(0x1f)
-                    for { let i := shl(5, cap) } 1 {} {
-                        mstore(add(m, i), mload(add(data, i)))
-                        i := add(i, w)
-                        if iszero(i) { break }
-                    }
-                }
-                mstore(heap, m) // Update `heap.data`.
-                data := m
-                break
-            }
-            let sOffset := add(data, 0x20) // Array memory offset.
-            let pos := 0
-            let childPos := not(0)
-            // Operations are ordered from most likely usage to least likely usage.
-            for {} 1 {
-                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.
-                revert(0x1c, 0x04)
-            } {
-                // Mode: `enqueue`.
-                if iszero(mode) {
-                    if iszero(maxLength) { continue }
-                    // If the queue is full.
-                    if iszero(lt(n, maxLength)) {
-                        if iszero(lt(mload(sOffset), value)) { break }
-                        status := 3
-                        childPos := 1
-                        popped := mload(sOffset)
-                        break
-                    }
-                    status := 1
-                    pos := n
-                    // Increment and update the length.
-                    mstore(data, add(pos, 1))
-                    childPos := 0xff0000000000000000
-                    break
-                }
-                if iszero(gt(mode, 2)) {
-                    if iszero(n) { continue }
-                    // Mode: `pop`.
-                    if eq(mode, 2) {
-                        // Decrement and update the length.
-                        n := sub(n, 1)
-                        mstore(data, n)
-                        // Set the `value` to the last item.
-                        value := mload(add(sOffset, shl(5, n)))
-                        popped := value
-                        if iszero(n) { break }
-                    }
-                    // Mode: `replace`.
-                    popped := mload(sOffset)
-                    childPos := 1
-                    break
-                }
-                // Mode: `push`.
-                if eq(mode, 3) {
-                    // Increment and update the length.
-                    pos := n
-                    mstore(data, add(pos, 1))
-                    childPos := 0xff0000000000000000
-                    break
-                }
-                // Mode: `pushPop`.
-                if iszero(mul(n, lt(mload(sOffset), value))) {
-                    popped := value
-                    break
-                }
-                popped := mload(sOffset)
-                childPos := 1
-                break
-            }
-            // Siftup.
-            for {} lt(childPos, n) {} {
-                let child := mload(add(sOffset, shl(5, childPos)))
-                let rightPos := add(childPos, 1)
-                let right := mload(add(sOffset, shl(5, rightPos)))
-                if iszero(gt(lt(rightPos, n), lt(child, right))) {
-                    mstore(add(sOffset, shl(5, pos)), child)
-                    pos := childPos
-                    childPos := add(shl(1, pos), 1)
-                    continue
-                }
-                mstore(add(sOffset, shl(5, pos)), right)
-                pos := rightPos
-                childPos := add(shl(1, pos), 1)
-            }
-            // Siftdown.
-            for {} pos {} {
-                let parentPos := shr(1, sub(pos, 1))
-                let parent := mload(add(sOffset, shl(5, parentPos)))
-                if iszero(lt(value, parent)) { break }
-                mstore(add(sOffset, shl(5, pos)), parent)
-                pos := parentPos
-            }
-            // If `childPos` has been changed from `not(0)`.
-            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }
-        }
-    }
-}
diff --git a/src/utils/g/RedBlackTreeLib.sol b/src/utils/g/RedBlackTreeLib.sol
deleted file mode 100644
index efa863c..0000000
--- a/src/utils/g/RedBlackTreeLib.sol
+++ /dev/null
@@ -1,722 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev A red-black-tree in storage.
-struct Tree {
-    uint256 _spacer;
-}
-
-using RedBlackTreeLib for Tree global;
-
-/// @notice Library for managing a red-black-tree in storage.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/RedBlackTreeLib.sol)
-/// @author Modified from BokkyPooBahsRedBlackTreeLibrary (https://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary)
-/// @dev This implementation does not support the zero (i.e. empty) value.
-///      This implementation supports up to 2147483647 values.
-library RedBlackTreeLib {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                       CUSTOM ERRORS                        */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev The value cannot be zero.
-    error ValueIsEmpty();
-
-    /// @dev Cannot insert a value that already exists.
-    error ValueAlreadyExists();
-
-    /// @dev Cannot remove a value that does not exist.
-    error ValueDoesNotExist();
-
-    /// @dev The pointer is out of bounds.
-    error PointerOutOfBounds();
-
-    /// @dev The tree is full.
-    error TreeIsFull();
-
-    /// @dev `bytes4(keccak256(bytes("ValueAlreadyExists()")))`.
-    uint256 internal constant ERROR_VALUE_ALREADY_EXISTS = 0xbb33e6ac;
-
-    /// @dev `bytes4(keccak256(bytes("ValueDoesNotExist()")))`.
-    uint256 internal constant ERROR_VALUE_DOES_NOT_EXISTS = 0xb113638a;
-
-    /// @dev `bytes4(keccak256(bytes("PointerOutOfBounds()")))`.
-    uint256 internal constant ERROR_POINTER_OUT_OF_BOUNDS = 0xccd52fbc;
-
-    /// @dev `bytes4(keccak256(bytes("TreeIsFull()")))`.
-    uint256 internal constant ERROR_TREE_IS_FULL = 0xed732d0c;
-
-    // Custom storage:
-    // ```
-    // mstore(0x20, tree.slot)
-    // mstore(0x00, _NODES_SLOT_SEED)
-    // let nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))
-    //
-    // let root := shr(128, sload(nodes))
-    // let totalNodes := and(sload(nodes), _BITMASK_KEY)
-    //
-    // let nodePacked := sload(or(nodes, nodeIndex))
-    // let nodeLeft   := and(nodePacked, _BITMASK_KEY)
-    // let nodeRight  := and(shr(_BITPOS_RIGHT, nodePacked), _BITMASK_KEY)
-    // let nodeParent := and(shr(_BITPOS_PARENT, nodePacked), _BITMASK_KEY)
-    // let nodeRed    := and(shr(_BITPOS_RED, nodePacked), 1)
-    //
-    // let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)
-    // if iszero(nodeValue) {
-    //     nodeValue := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes, nodeIndex)))
-    // }
-    // ```
-    //
-    // Bits Layout of the Root Index Slot:
-    // - [0..30]    `totalNodes`
-    // - [128..159] `rootNodeIndex`
-    //
-    // Bits Layout of a Node:
-    // - [0..30]   `leftChildIndex`
-    // - [31..61]  `rightChildIndex`
-    // - [62..92]  `parentIndex`
-    // - [93]      `isRed`
-    // - [96..255] `nodePackedValue`
-
-    uint256 private constant _NODES_SLOT_SEED = 0x1dc27bb5462fdadcb;
-    uint256 private constant _NODES_SLOT_SHIFT = 32;
-    uint256 private constant _BITMASK_KEY = (1 << 31) - 1;
-    uint256 private constant _BITPOS_LEFT = 0;
-    uint256 private constant _BITPOS_RIGHT = 31;
-    uint256 private constant _BITPOS_PARENT = 31 * 2;
-    uint256 private constant _BITPOS_RED = 31 * 3;
-    uint256 private constant _BITMASK_RED = 1 << (31 * 3);
-    uint256 private constant _BITPOS_PACKED_VALUE = 96;
-    uint256 private constant _BITMASK_PACKED_VALUE = (1 << 160) - 1;
-    uint256 private constant _BIT_FULL_VALUE_SLOT = 1 << 31;
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                         OPERATIONS                         */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns the number of unique values in the tree.
-    function size(Tree storage tree) internal view returns (uint256 result) {
-        uint256 nodes = _nodes(tree);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := and(sload(nodes), _BITMASK_KEY)
-        }
-    }
-
-    /// @dev Returns an array of all the values in the tree in ascending sorted order.
-    /// WARNING! This function can exhaust the block gas limit if the tree is big.
-    /// It is intended for usage in off-chain view functions.
-    function values(Tree storage tree) internal view returns (uint256[] memory result) {
-        uint256 nodes = _nodes(tree);
-        /// @solidity memory-safe-assembly
-        assembly {
-            function visit(current_) {
-                if iszero(current_) { leave } // If the current node is null, leave.
-                current_ := or(mload(0x00), current_) // Current node's storage slot.
-                let packed_ := sload(current_)
-                visit(and(packed_, _BITMASK_KEY)) // Visit left child.
-                let value_ := shr(_BITPOS_PACKED_VALUE, packed_) // Current value.
-                if iszero(value_) { value_ := sload(or(current_, _BIT_FULL_VALUE_SLOT)) }
-                mstore(mload(0x20), value_) // Append the value to `results`.
-                mstore(0x20, add(0x20, mload(0x20))) // Advance the offset into `results`.
-                visit(and(shr(_BITPOS_RIGHT, packed_), _BITMASK_KEY)) // Visit right child.
-            }
-            result := mload(0x40)
-            let rootPacked := sload(nodes)
-            mstore(result, and(rootPacked, _BITMASK_KEY)) // Length of `result`.
-            mstore(0x00, nodes) // Cache the nodes pointer in scratch space.
-            mstore(0x20, add(result, 0x20)) // Cache the offset into `results` in scratch space.
-            mstore(0x40, add(mload(0x20), shl(5, mload(result)))) // Allocate memory.
-            visit(shr(128, rootPacked)) // Start the tree traversal from the root node.
-        }
-    }
-
-    /// @dev Returns a pointer to the value `x`.
-    /// If the value `x` is not in the tree, the returned pointer will be empty.
-    function find(Tree storage tree, uint256 x) internal view returns (bytes32 result) {
-        (uint256 nodes,, uint256 key) = _find(tree, x);
-        result = _pack(nodes, key);
-    }
-
-    /// @dev Returns a pointer to the nearest value to `x`.
-    /// In a tie-breaker, the returned pointer will point to the smaller value.
-    /// If the tree is empty, the returned pointer will be empty.
-    function nearest(Tree storage tree, uint256 x) internal view returns (bytes32 result) {
-        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);
-        unchecked {
-            if (cursor == uint256(0)) return result; // Nothing found -- empty tree.
-            if (key != uint256(0)) return _pack(nodes, key); // Exact match.
-            bytes32 a = _pack(nodes, cursor);
-            uint256 aValue = value(a);
-            bytes32 b = x < aValue ? prev(a) : next(a);
-            if (b == bytes32(0)) return a; // Only node found.
-            uint256 bValue = value(b);
-            uint256 aDist = x < aValue ? aValue - x : x - aValue;
-            uint256 bDist = x < bValue ? bValue - x : x - bValue;
-            return (aDist == bDist ? aValue < bValue : aDist < bDist) ? a : b;
-        }
-    }
-
-    /// @dev Returns a pointer to the nearest value lesser or equal to `x`.
-    /// If there is no value lesser or equal to `x`, the returned pointer will be empty.
-    function nearestBefore(Tree storage tree, uint256 x) internal view returns (bytes32 result) {
-        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);
-        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.
-        if (key != uint256(0)) return _pack(nodes, key); // Exact match.
-        bytes32 a = _pack(nodes, cursor);
-        return value(a) < x ? a : prev(a);
-    }
-
-    /// @dev Returns a pointer to the nearest value greater or equal to `x`.
-    /// If there is no value greater or equal to `x`, the returned pointer will be empty.
-    function nearestAfter(Tree storage tree, uint256 x) internal view returns (bytes32 result) {
-        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);
-        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.
-        if (key != uint256(0)) return _pack(nodes, key); // Exact match.
-        bytes32 a = _pack(nodes, cursor);
-        return value(a) > x ? a : next(a);
-    }
-
-    /// @dev Returns whether the value `x` exists.
-    function exists(Tree storage tree, uint256 x) internal view returns (bool result) {
-        (,, uint256 key) = _find(tree, x);
-        result = key != 0;
-    }
-
-    /// @dev Inserts the value `x` into the tree.
-    /// Reverts if the value `x` already exists.
-    function insert(Tree storage tree, uint256 x) internal {
-        uint256 err = tryInsert(tree, x);
-        if (err != 0) _revert(err);
-    }
-
-    /// @dev Inserts the value `x` into the tree.
-    /// Returns a non-zero error code upon failure instead of reverting
-    /// (except for reverting if `x` is an empty value).
-    function tryInsert(Tree storage tree, uint256 x) internal returns (uint256 err) {
-        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);
-        err = _update(nodes, cursor, key, x, 0);
-    }
-
-    /// @dev Removes the value `x` from the tree.
-    /// Reverts if the value does not exist.
-    function remove(Tree storage tree, uint256 x) internal {
-        uint256 err = tryRemove(tree, x);
-        if (err != 0) _revert(err);
-    }
-
-    /// @dev Removes the value `x` from the tree.
-    /// Returns a non-zero error code upon failure instead of reverting
-    /// (except for reverting if `x` is an empty value).
-    function tryRemove(Tree storage tree, uint256 x) internal returns (uint256 err) {
-        (uint256 nodes,, uint256 key) = _find(tree, x);
-        err = _update(nodes, 0, key, 0, 1);
-    }
-
-    /// @dev Removes the value at pointer `ptr` from the tree.
-    /// Reverts if `ptr` is empty (i.e. value does not exist),
-    /// or if `ptr` is out of bounds.
-    /// After removal, `ptr` may point to another existing value.
-    /// For safety, do not reuse `ptr` after calling remove on it.
-    function remove(bytes32 ptr) internal {
-        uint256 err = tryRemove(ptr);
-        if (err != 0) _revert(err);
-    }
-
-    /// @dev Removes the value at pointer `ptr` from the tree.
-    /// Returns a non-zero error code upon failure instead of reverting.
-    function tryRemove(bytes32 ptr) internal returns (uint256 err) {
-        (uint256 nodes, uint256 key) = _unpack(ptr);
-        err = _update(nodes, 0, key, 0, 1);
-    }
-
-    /// @dev Returns the value at pointer `ptr`.
-    /// If `ptr` is empty, the result will be zero.
-    function value(bytes32 ptr) internal view returns (uint256 result) {
-        if (ptr == bytes32(0)) return result;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let packed := sload(ptr)
-            result := shr(_BITPOS_PACKED_VALUE, packed)
-            if iszero(result) { result := sload(or(ptr, _BIT_FULL_VALUE_SLOT)) }
-        }
-    }
-
-    /// @dev Returns a pointer to the smallest value in the tree.
-    /// If the tree is empty, the returned pointer will be empty.
-    function first(Tree storage tree) internal view returns (bytes32 result) {
-        result = _end(tree, _BITPOS_LEFT);
-    }
-
-    /// @dev Returns a pointer to the largest value in the tree.
-    /// If the tree is empty, the returned pointer will be empty.
-    function last(Tree storage tree) internal view returns (bytes32 result) {
-        result = _end(tree, _BITPOS_RIGHT);
-    }
-
-    /// @dev Returns the pointer to the next largest value.
-    /// If there is no next value, or if `ptr` is empty,
-    /// the returned pointer will be empty.
-    function next(bytes32 ptr) internal view returns (bytes32 result) {
-        result = _step(ptr, _BITPOS_LEFT, _BITPOS_RIGHT);
-    }
-
-    /// @dev Returns the pointer to the next smallest value.
-    /// If there is no previous value, or if `ptr` is empty,
-    /// the returned pointer will be empty.
-    function prev(bytes32 ptr) internal view returns (bytes32 result) {
-        result = _step(ptr, _BITPOS_RIGHT, _BITPOS_LEFT);
-    }
-
-    /// @dev Returns whether the pointer is empty.
-    function isEmpty(bytes32 ptr) internal pure returns (bool result) {
-        result = ptr == bytes32(0);
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                      PRIVATE HELPERS                       */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Unpacks the pointer `ptr` to its components.
-    function _unpack(bytes32 ptr) private pure returns (uint256 nodes, uint256 key) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            nodes := shl(_NODES_SLOT_SHIFT, shr(_NODES_SLOT_SHIFT, ptr))
-            key := and(_BITMASK_KEY, ptr)
-        }
-    }
-
-    /// @dev Packs `nodes` and `key` into a single pointer.
-    function _pack(uint256 nodes, uint256 key) private pure returns (bytes32 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mul(or(nodes, key), iszero(iszero(key)))
-        }
-    }
-
-    /// @dev Returns the pointer to either end of the tree.
-    function _end(Tree storage tree, uint256 L) private view returns (bytes32 result) {
-        uint256 nodes = _nodes(tree);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := shr(128, sload(nodes))
-            if result {
-                for {} 1 {} {
-                    let packed := sload(or(nodes, result))
-                    let left := and(shr(L, packed), _BITMASK_KEY)
-                    if iszero(left) { break }
-                    result := left
-                }
-            }
-        }
-        result = _pack(nodes, uint256(result));
-    }
-
-    /// @dev Step the pointer `ptr` forwards or backwards.
-    function _step(bytes32 ptr, uint256 L, uint256 R) private view returns (bytes32 result) {
-        if (ptr == bytes32(0)) return ptr;
-        (uint256 nodes, uint256 target) = _unpack(ptr);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let packed := sload(ptr)
-            for { result := and(shr(R, packed), _BITMASK_KEY) } 1 {} {
-                if iszero(result) {
-                    result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)
-                    for {} 1 {} {
-                        if iszero(result) { break }
-                        packed := sload(or(nodes, result))
-                        if iszero(eq(target, and(shr(R, packed), _BITMASK_KEY))) { break }
-                        target := result
-                        result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)
-                    }
-                    break
-                }
-                for {} 1 {} {
-                    packed := sload(or(nodes, result))
-                    let left := and(shr(L, packed), _BITMASK_KEY)
-                    if iszero(left) { break }
-                    result := left
-                }
-                break
-            }
-        }
-        result = _pack(nodes, uint256(result));
-    }
-
-    /// @dev Inserts or delete the value `x` from the tree.
-    function _update(uint256 nodes, uint256 cursor, uint256 key, uint256 x, uint256 mode)
-        private
-        returns (uint256 err)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function getKey(packed_, bitpos_) -> index_ {
-                index_ := and(_BITMASK_KEY, shr(bitpos_, packed_))
-            }
-
-            function setKey(packed_, bitpos_, key_) -> result_ {
-                result_ := or(and(not(shl(bitpos_, _BITMASK_KEY)), packed_), shl(bitpos_, key_))
-            }
-
-            function rotate(nodes_, key_, L, R) {
-                let packed_ := sload(or(nodes_, key_))
-                let cursor_ := getKey(packed_, R)
-                let parent_ := getKey(packed_, _BITPOS_PARENT)
-                let cursorPacked_ := sload(or(nodes_, cursor_))
-                let cursorLeft_ := getKey(cursorPacked_, L)
-
-                if cursorLeft_ {
-                    let s_ := or(nodes_, cursorLeft_)
-                    sstore(s_, setKey(sload(s_), _BITPOS_PARENT, key_))
-                }
-
-                for {} 1 {} {
-                    if iszero(parent_) {
-                        mstore(0x00, cursor_)
-                        break
-                    }
-                    let s_ := or(nodes_, parent_)
-                    let parentPacked_ := sload(s_)
-                    if eq(key_, getKey(parentPacked_, L)) {
-                        sstore(s_, setKey(parentPacked_, L, cursor_))
-                        break
-                    }
-                    sstore(s_, setKey(parentPacked_, R, cursor_))
-                    break
-                }
-                packed_ := setKey(packed_, R, cursorLeft_)
-                sstore(or(nodes_, key_), setKey(packed_, _BITPOS_PARENT, cursor_))
-                cursorPacked_ := setKey(cursorPacked_, _BITPOS_PARENT, parent_)
-                sstore(or(nodes_, cursor_), setKey(cursorPacked_, L, key_))
-            }
-
-            function insert(nodes_, cursor_, key_, x_) -> err_ {
-                if key_ {
-                    err_ := ERROR_VALUE_ALREADY_EXISTS
-                    leave
-                }
-
-                let totalNodes_ := add(shr(128, mload(0x20)), 1)
-                if gt(totalNodes_, _BITMASK_KEY) {
-                    err_ := ERROR_TREE_IS_FULL
-                    leave
-                }
-
-                mstore(0x20, shl(128, totalNodes_))
-
-                {
-                    let packed_ := or(_BITMASK_RED, shl(_BITPOS_PARENT, cursor_))
-                    let nodePointer_ := or(nodes_, totalNodes_)
-
-                    for {} 1 {} {
-                        if iszero(gt(x_, _BITMASK_PACKED_VALUE)) {
-                            packed_ := or(shl(_BITPOS_PACKED_VALUE, x_), packed_)
-                            break
-                        }
-                        sstore(or(nodePointer_, _BIT_FULL_VALUE_SLOT), x_)
-                        break
-                    }
-                    sstore(nodePointer_, packed_)
-
-                    for {} 1 {} {
-                        if iszero(cursor_) {
-                            mstore(0x00, totalNodes_)
-                            break
-                        }
-                        let s_ := or(nodes_, cursor_)
-                        let cPacked_ := sload(s_)
-                        let cValue_ := shr(_BITPOS_PACKED_VALUE, cPacked_)
-                        if iszero(cValue_) { cValue_ := sload(or(s_, _BIT_FULL_VALUE_SLOT)) }
-                        if iszero(lt(x_, cValue_)) {
-                            sstore(s_, setKey(cPacked_, _BITPOS_RIGHT, totalNodes_))
-                            break
-                        }
-                        sstore(s_, setKey(cPacked_, _BITPOS_LEFT, totalNodes_))
-                        break
-                    }
-                }
-
-                // Insert fixup workflow:
-
-                key_ := totalNodes_
-                let BR := _BITMASK_RED
-                for {} iszero(eq(key_, mload(0x00))) {} {
-                    let packed_ := sload(or(nodes_, key_))
-                    let parent_ := getKey(packed_, _BITPOS_PARENT)
-                    let parentPacked_ := sload(or(nodes_, parent_))
-                    if iszero(and(BR, parentPacked_)) { break }
-
-                    let grandParent_ := getKey(parentPacked_, _BITPOS_PARENT)
-                    let grandParentPacked_ := sload(or(nodes_, grandParent_))
-
-                    let R := mul(eq(parent_, getKey(grandParentPacked_, 0)), _BITPOS_RIGHT)
-                    let L := xor(R, _BITPOS_RIGHT)
-
-                    let c_ := getKey(grandParentPacked_, R)
-                    let cPacked_ := sload(or(nodes_, c_))
-                    if iszero(and(BR, cPacked_)) {
-                        if eq(key_, getKey(parentPacked_, R)) {
-                            key_ := parent_
-                            rotate(nodes_, key_, L, R)
-                            parent_ := getKey(sload(or(nodes_, key_)), _BITPOS_PARENT)
-                            parentPacked_ := sload(or(nodes_, parent_))
-                        }
-                        sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))
-                        let s_ := or(nodes_, grandParent_)
-                        sstore(s_, or(sload(s_), BR))
-                        rotate(nodes_, grandParent_, R, L)
-                        break
-                    }
-                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))
-                    sstore(or(nodes_, c_), and(cPacked_, not(BR)))
-                    sstore(or(nodes_, grandParent_), or(grandParentPacked_, BR))
-                    key_ := grandParent_
-                }
-                let root_ := or(nodes_, mload(0x00))
-                sstore(root_, and(sload(root_), not(BR)))
-            }
-
-            function removeFixup(nodes_, key_) {
-                let BR := _BITMASK_RED
-                for {} iszero(eq(key_, mload(0x00))) {} {
-                    let packed_ := sload(or(nodes_, key_))
-                    if and(BR, packed_) { break }
-
-                    let parent_ := getKey(packed_, _BITPOS_PARENT)
-                    let parentPacked_ := sload(or(nodes_, parent_))
-
-                    let R := mul(eq(key_, getKey(parentPacked_, 0)), _BITPOS_RIGHT)
-                    let L := xor(R, _BITPOS_RIGHT)
-
-                    let cursor_ := getKey(parentPacked_, R)
-                    let cursorPacked_ := sload(or(nodes_, cursor_))
-
-                    if and(BR, cursorPacked_) {
-                        sstore(or(nodes_, cursor_), and(cursorPacked_, not(BR)))
-                        sstore(or(nodes_, parent_), or(parentPacked_, BR))
-                        rotate(nodes_, parent_, L, R)
-                        cursor_ := getKey(sload(or(nodes_, parent_)), R)
-                        cursorPacked_ := sload(or(nodes_, cursor_))
-                    }
-
-                    let cursorLeft_ := getKey(cursorPacked_, L)
-                    let cursorLeftPacked_ := sload(or(nodes_, cursorLeft_))
-                    let cursorRight_ := getKey(cursorPacked_, R)
-                    let cursorRightPacked_ := sload(or(nodes_, cursorRight_))
-
-                    if iszero(and(BR, or(cursorLeftPacked_, cursorRightPacked_))) {
-                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))
-                        key_ := parent_
-                        continue
-                    }
-
-                    if iszero(and(BR, cursorRightPacked_)) {
-                        sstore(or(nodes_, cursorLeft_), and(cursorLeftPacked_, not(BR)))
-                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))
-                        rotate(nodes_, cursor_, R, L)
-                        cursor_ := getKey(sload(or(nodes_, parent_)), R)
-                        cursorPacked_ := sload(or(nodes_, cursor_))
-                        cursorRight_ := getKey(cursorPacked_, R)
-                        cursorRightPacked_ := sload(or(nodes_, cursorRight_))
-                    }
-
-                    parentPacked_ := sload(or(nodes_, parent_))
-                    // forgefmt: disable-next-item
-                    sstore(or(nodes_, cursor_), xor(cursorPacked_, and(BR, xor(cursorPacked_, parentPacked_))))
-                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))
-                    sstore(or(nodes_, cursorRight_), and(cursorRightPacked_, not(BR)))
-                    rotate(nodes_, parent_, L, R)
-                    break
-                }
-                sstore(or(nodes_, key_), and(sload(or(nodes_, key_)), not(BR)))
-            }
-
-            function replaceParent(nodes_, parent_, a_, b_) {
-                if iszero(parent_) {
-                    mstore(0x00, a_)
-                    leave
-                }
-                let s_ := or(nodes_, parent_)
-                let p_ := sload(s_)
-                let t_ := iszero(eq(b_, getKey(p_, _BITPOS_LEFT)))
-                sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), a_))
-            }
-
-            // In `remove`, the parent of the null value (index 0) may be temporarily set
-            // to a non-zero value. This is an optimization that unifies the removal cases.
-            function remove(nodes_, key_) -> err_ {
-                if gt(key_, shr(128, mload(0x20))) {
-                    err_ := ERROR_POINTER_OUT_OF_BOUNDS
-                    leave
-                }
-                if iszero(key_) {
-                    err_ := ERROR_VALUE_DOES_NOT_EXISTS
-                    leave
-                }
-
-                let cursor_ := key_
-                {
-                    let packed_ := sload(or(nodes_, key_))
-                    let left_ := getKey(packed_, _BITPOS_LEFT)
-                    let right_ := getKey(packed_, _BITPOS_RIGHT)
-                    if mul(left_, right_) {
-                        for { cursor_ := right_ } 1 {} {
-                            let cursorLeft_ := getKey(sload(or(nodes_, cursor_)), _BITPOS_LEFT)
-                            if iszero(cursorLeft_) { break }
-                            cursor_ := cursorLeft_
-                        }
-                    }
-                }
-
-                let cursorPacked_ := sload(or(nodes_, cursor_))
-                let probe_ := getKey(cursorPacked_, _BITPOS_LEFT)
-                probe_ := getKey(cursorPacked_, mul(iszero(probe_), _BITPOS_RIGHT))
-
-                let yParent_ := getKey(cursorPacked_, _BITPOS_PARENT)
-                let probeSlot_ := or(nodes_, probe_)
-                sstore(probeSlot_, setKey(sload(probeSlot_), _BITPOS_PARENT, yParent_))
-                replaceParent(nodes_, yParent_, probe_, cursor_)
-
-                if iszero(eq(cursor_, key_)) {
-                    let packed_ := sload(or(nodes_, key_))
-                    replaceParent(nodes_, getKey(packed_, _BITPOS_PARENT), cursor_, key_)
-
-                    let leftSlot_ := or(nodes_, getKey(packed_, _BITPOS_LEFT))
-                    sstore(leftSlot_, setKey(sload(leftSlot_), _BITPOS_PARENT, cursor_))
-
-                    let rightSlot_ := or(nodes_, getKey(packed_, _BITPOS_RIGHT))
-                    sstore(rightSlot_, setKey(sload(rightSlot_), _BITPOS_PARENT, cursor_))
-
-                    // Copy `left`, `right`, `red` from `key_` to `cursor_`.
-                    // forgefmt: disable-next-item
-                    sstore(or(nodes_, cursor_), xor(cursorPacked_,
-                        and(xor(packed_, cursorPacked_), sub(shl(_BITPOS_PACKED_VALUE, 1), 1))))
-
-                    let t_ := cursor_
-                    cursor_ := key_
-                    key_ := t_
-                }
-
-                if iszero(and(_BITMASK_RED, cursorPacked_)) { removeFixup(nodes_, probe_) }
-
-                // Remove last workflow:
-
-                let last_ := shr(128, mload(0x20))
-                let lastPacked_ := sload(or(nodes_, last_))
-                let lastValue_ := shr(_BITPOS_PACKED_VALUE, lastPacked_)
-                let lastFullValue_ := 0
-                if iszero(lastValue_) {
-                    lastValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)))
-                    lastFullValue_ := lastValue_
-                }
-
-                let cursorValue_ := shr(_BITPOS_PACKED_VALUE, sload(or(nodes_, cursor_)))
-                let cursorFullValue_ := 0
-                if iszero(cursorValue_) {
-                    cursorValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)))
-                    cursorFullValue_ := cursorValue_
-                }
-
-                if iszero(eq(lastValue_, cursorValue_)) {
-                    sstore(or(nodes_, cursor_), lastPacked_)
-                    if iszero(eq(lastFullValue_, cursorFullValue_)) {
-                        sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)), lastFullValue_)
-                    }
-                    for { let lastParent_ := getKey(lastPacked_, _BITPOS_PARENT) } 1 {} {
-                        if iszero(lastParent_) {
-                            mstore(0x00, cursor_)
-                            break
-                        }
-                        let s_ := or(nodes_, lastParent_)
-                        let p_ := sload(s_)
-                        let t_ := iszero(eq(last_, getKey(p_, _BITPOS_LEFT)))
-                        sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), cursor_))
-                        break
-                    }
-                    let lastRight_ := getKey(lastPacked_, _BITPOS_RIGHT)
-                    if lastRight_ {
-                        let s_ := or(nodes_, lastRight_)
-                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))
-                    }
-                    let lastLeft_ := getKey(lastPacked_, _BITPOS_LEFT)
-                    if lastLeft_ {
-                        let s_ := or(nodes_, lastLeft_)
-                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))
-                    }
-                }
-                sstore(or(nodes_, last_), 0)
-                if lastFullValue_ { sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)), 0) }
-
-                mstore(0x20, shl(128, sub(last_, 1)))
-            }
-
-            mstore(0x00, codesize()) // Zeroize the first 0x10 bytes.
-            mstore(0x10, sload(nodes))
-
-            for {} 1 {} {
-                if iszero(mode) {
-                    err := insert(nodes, cursor, key, x)
-                    break
-                }
-                err := remove(nodes, key)
-                break
-            }
-
-            sstore(nodes, mload(0x10))
-        }
-    }
-
-    /// @dev Returns the pointer to the `nodes` for the tree.
-    function _nodes(Tree storage tree) private pure returns (uint256 nodes) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, tree.slot)
-            mstore(0x00, _NODES_SLOT_SEED)
-            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))
-        }
-    }
-
-    /// @dev Finds `x` in `tree`. The `key` will be zero if `x` is not found.
-    function _find(Tree storage tree, uint256 x)
-        private
-        view
-        returns (uint256 nodes, uint256 cursor, uint256 key)
-    {
-        if (x == uint256(0)) _revert(0xc94f1877); // `ValueIsEmpty()`.
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x20, tree.slot)
-            mstore(0x00, _NODES_SLOT_SEED)
-            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))
-            // Layout scratch space so that `mload(0x00) == 0`, `mload(0x01) == _BITPOS_RIGHT`.
-            mstore(0x01, _BITPOS_RIGHT) // `_BITPOS_RIGHT` is 31.
-            for { let probe := shr(128, sload(nodes)) } probe {} {
-                cursor := probe
-                let nodePacked := sload(or(nodes, probe))
-                let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)
-                if iszero(nodeValue) {
-                    nodeValue := sload(or(or(nodes, probe), _BIT_FULL_VALUE_SLOT))
-                }
-                if eq(nodeValue, x) {
-                    key := cursor
-                    break
-                }
-                probe := and(shr(mload(gt(x, nodeValue)), nodePacked), _BITMASK_KEY)
-            }
-        }
-    }
-
-    /// @dev Helper to revert `err` efficiently.
-    function _revert(uint256 err) private pure {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, err)
-            revert(0x1c, 0x04)
-        }
-    }
-}
diff --git a/src/utils/g/WebAuthn.sol b/src/utils/g/WebAuthn.sol
deleted file mode 100644
index d9b66f9..0000000
--- a/src/utils/g/WebAuthn.sol
+++ /dev/null
@@ -1,340 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.13;
-
-// This file is auto-generated.
-
-/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-/*                          STRUCTS                           */
-/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-/// @dev Helps make encoding and decoding easier, alleviates stack-too-deep.
-struct WebAuthnAuth {
-    // The WebAuthn authenticator data.
-    // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata.
-    bytes authenticatorData;
-    // The WebAuthn client data JSON.
-    // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson.
-    string clientDataJSON;
-    // Start index of "challenge":"..." in `clientDataJSON`.
-    uint256 challengeIndex;
-    // Start index of "type":"..." in `clientDataJSON`.
-    uint256 typeIndex;
-    // The r value of secp256r1 signature.
-    bytes32 r;
-    // The s value of secp256r1 signature.
-    bytes32 s;
-}
-
-using WebAuthn for WebAuthnAuth global;
-
-import {Base64} from "../Base64.sol";
-import {P256} from "../P256.sol";
-
-/// @notice WebAuthn helper.
-/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/g/WebAuthn.sol)
-/// @author Modified from Daimo WebAuthn (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)
-/// @author Modified from Coinbase WebAuthn (https://github.com/base-org/webauthn-sol/blob/main/src/WebAuthn.sol)
-library WebAuthn {
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*              WEBAUTHN VERIFICATION OPERATIONS              */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Verifies a Webauthn Authentication Assertion.
-    /// See: https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion.
-    ///
-    /// We do not verify all the steps as described in the specification, only ones
-    /// relevant to our context. Please carefully read through this list before usage.
-    ///
-    /// Specifically, we do verify the following:
-    /// - Verify that `authenticatorData` (which comes from the authenticator,
-    ///   such as iCloud Keychain) indicates a well-formed assertion with the
-    ///   "User Present" bit set. If `requireUserVerification` is set, checks that the
-    ///   authenticator enforced user verification. User verification should be required
-    ///   if, and only if, `options.userVerification` is set to required in the request.
-    /// - Verifies that the client JSON is of type "webauthn.get",
-    ///   i.e. the client was responding to a request to assert authentication.
-    /// - Verifies that the client JSON contains the requested challenge.
-    /// - Verifies that (r, s) constitute a valid signature over both the
-    ///   `authData` and client JSON, for public key (x, y).
-    ///
-    /// We make some assumptions about the particular use case of this verifier,
-    /// so we do NOT verify the following:
-    /// - Does NOT verify that the origin in the `clientDataJSON` matches the
-    ///   Relying Party's origin: it is considered the authenticator's responsibility to
-    ///   ensure that the user is interacting with the correct RP. This is enforced by
-    ///   most high quality authenticators properly, particularly the iCloud Keychain
-    ///   and Google Password Manager were tested.
-    /// - Does NOT verify That `topOrigin` in `clientDataJSON` is well-formed:
-    ///   We assume it would never be present, i.e. the credentials are never used in a
-    ///   cross-origin/iframe context. The website/app set up should disallow cross-origin
-    ///   usage of the credentials. This is the default behavior for created credentials
-    ///   in common settings.
-    /// - Does NOT verify that the `rpIdHash` in `authenticatorData` is the SHA-256 hash
-    ///   of the RP ID expected by the Relying Party:
-    ///   this means that we rely on the authenticator to properly enforce
-    ///   credentials to be used only by the correct RP.
-    ///   This is generally enforced with features like Apple App Site Association
-    ///   and Google Asset Links. To protect from edge cases in which a previously-linked
-    ///   RP ID is removed from the authorized RP IDs, we recommend that messages
-    ///   signed by the authenticator include some expiry mechanism.
-    /// - Does NOT verify the credential backup state: this assumes the credential backup
-    ///   state is NOT used as part of Relying Party business logic or policy.
-    /// - Does NOT verify the values of the client extension outputs:
-    ///   this assumes that the Relying Party does not use client extension outputs.
-    /// - Does NOT verify the signature counter: signature counters are intended to enable
-    ///   risk scoring for the Relying Party. This assumes risk scoring is not used as part
-    ///   of Relying Party business logic or policy.
-    /// - Does NOT verify the attestation object: this assumes that
-    ///   response.attestationObject is NOT present in the response,
-    ///   i.e. the RP does not intend to verify an attestation.
-    function verify(
-        bytes memory challenge,
-        bool requireUserVerification,
-        WebAuthnAuth memory auth,
-        bytes32 x,
-        bytes32 y
-    ) internal view returns (bool result) {
-        bytes32 messageHash;
-        string memory encoded = Base64.encode(challenge, true, true);
-        /// @solidity memory-safe-assembly
-        assembly {
-            let clientDataJSON := mload(add(auth, 0x20))
-            let n := mload(clientDataJSON) // `clientDataJSON`'s length.
-            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.
-            {
-                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.
-                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.
-                let l := mload(encoded) // Cache `encoded`'s length.
-                let q := add(l, 0x0d) // Length of `encoded` prefixed with '"challenge":"'.
-                mstore(encoded, shr(152, '"challenge":"')) // Temp prefix with '"challenge":"'.
-                result :=
-                    and(
-                        // 11. Verify JSON's type. Also checks for possible addition overflows.
-                        and(
-                            eq(shr(88, mload(add(o, t))), shr(88, '"type":"webauthn.get"')),
-                            lt(shr(128, or(t, c)), lt(add(0x14, t), n))
-                        ),
-                        // 12. Verify JSON's challenge. Includes a check for the closing '"'.
-                        and(
-                            eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),
-                            and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))
-                        )
-                    )
-                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.
-            }
-            // Skip 13., 14., 15.
-            let l := mload(mload(auth)) // Length of `authenticatorData`.
-            // 16. Verify that the "User Present" flag is set (bit 0).
-            // 17. Verify that the "User Verified" flag is set (bit 2), if required.
-            // See: https://www.w3.org/TR/webauthn-2/#flags.
-            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))
-            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))
-            if result {
-                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.
-                let e := add(p, l) // Location of the word after `authenticatorData`.
-                let w := mload(e) // Cache the word after `authenticatorData`.
-                // 19. Compute `sha256(clientDataJSON)`.
-                // 20. Compute `sha256(authenticatorData ‖ sha256(clientDataJSON))`.
-                // forgefmt: disable-next-item
-                messageHash := mload(staticcall(gas(),
-                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))
-                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.
-                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.
-                if iszero(returndatasize()) { invalid() }
-            }
-        }
-        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.
-        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);
-    }
-
-    /// @dev Plain variant of verify.
-    function verify(
-        bytes memory challenge,
-        bool requireUserVerification,
-        bytes memory authenticatorData,
-        string memory clientDataJSON,
-        uint256 challengeIndex,
-        uint256 typeIndex,
-        bytes32 r,
-        bytes32 s,
-        bytes32 x,
-        bytes32 y
-    ) internal view returns (bool) {
-        return verify(
-            challenge,
-            requireUserVerification,
-            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),
-            x,
-            y
-        );
-    }
-
-    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
-    /*                ENCODING / DECODING HELPERS                 */
-    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
-
-    /// @dev Returns `abi.encode(auth)`.
-    function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {
-        return abi.encode(auth);
-    }
-
-    /// @dev Performs a best-effort attempt to `abi.decode(auth)`. Won't revert.
-    /// If any fields cannot be successfully extracted, `decoded` will not be populated,
-    /// which will cause `verify` to return false (as `clientDataJSON` is empty).
-    function tryDecodeAuth(bytes memory encodedAuth)
-        internal
-        pure
-        returns (WebAuthnAuth memory decoded)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {
-                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.
-                let e := add(o, n) // End of `encodedAuth` in memory.
-                let p := add(mload(o), o) // Start of `encodedAuth`.
-                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }
-                let authenticatorData := add(mload(p), p)
-                let clientDataJSON := add(mload(add(p, 0x20)), p)
-                if or(
-                    or(gt(authenticatorData, e), lt(authenticatorData, p)),
-                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))
-                ) { break }
-                if or(
-                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),
-                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)
-                ) { break }
-                mstore(decoded, authenticatorData) // `authenticatorData`.
-                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.
-                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.
-                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.
-                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.
-                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.
-                break
-            }
-        }
-    }
-
-    /// @dev Returns the compact encoding of `auth`:
-    /// ```
-    ///     abi.encodePacked(
-    ///         uint16(auth.authenticatorData.length),
-    ///         bytes(auth.authenticatorData),
-    ///         bytes(auth.clientDataJSON),
-    ///         uint16(auth.challengeIndex),
-    ///         uint16(auth.typeIndex),
-    ///         bytes32(auth.r),
-    ///         bytes32(auth.s)
-    ///     )
-    /// ```
-    /// Returns the empty string if any length or index exceeds 16 bits.
-    function tryEncodeAuthCompact(WebAuthnAuth memory auth)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function copyBytes(o_, s_, c_) -> _e {
-                mstore(o_, shl(240, mload(s_)))
-                o_ := add(o_, c_)
-                _e := add(o_, mload(s_)) // The end of the bytes.
-                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {
-                    mstore(o_, mload(add(d_, o_)))
-                    o_ := add(o_, 0x20)
-                    if iszero(lt(o_, _e)) { break }
-                }
-            }
-            let clientDataJSON := mload(add(0x20, auth))
-            let c := mload(add(0x40, auth)) // `challengeIndex`.
-            let t := mload(add(0x60, auth)) // `typeIndex`.
-            // If none of the lengths are more than `0xffff`.
-            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {
-                result := mload(0x40)
-                // `authenticatorData`, `clientDataJSON`.
-                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)
-                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.
-                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.
-                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.
-                mstore(result, sub(add(o, 0x24), result)) // Store the length.
-                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.
-                mstore(0x40, add(o, 0x64)) // Allocate memory .
-            }
-        }
-    }
-
-    /// @dev Approximately the same gas as `tryDecodeAuth`, but helps save on calldata.
-    /// If any fields cannot be successfully extracted, `decoded` will not be populated,
-    /// which will cause `verify` to return false (as `clientDataJSON` is empty).
-    function tryDecodeAuthCompact(bytes memory encodedAuth)
-        internal
-        pure
-        returns (WebAuthnAuth memory decoded)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function extractBytes(o_, l_) -> _m {
-                _m := mload(0x40) // Grab the free memory pointer.
-                let s_ := add(_m, 0x20)
-                for { let i_ := 0 } 1 {} {
-                    mstore(add(s_, i_), mload(add(o_, i_)))
-                    i_ := add(i_, 0x20)
-                    if iszero(lt(i_, l_)) { break }
-                }
-                mstore(_m, l_) // Store the length.
-                mstore(add(l_, s_), 0) // Zeroize the slot after the string.
-                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.
-            }
-            let n := mload(encodedAuth)
-            if iszero(lt(n, 0x46)) {
-                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.
-                let e := add(o, n) // End of `encodedAuth` in memory.
-                n := shr(240, mload(o)) // Length of `authenticatorData`.
-                let a := add(o, 0x02) // Start of `authenticatorData`.
-                let c := add(a, n) // Start of `clientDataJSON`.
-                let j := sub(e, 0x44) // Start of `challengeIndex`.
-                if iszero(gt(c, j)) {
-                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.
-                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.
-                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.
-                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.
-                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.
-                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.
-                }
-            }
-        }
-    }
-
-    /// @dev Calldata variant of `tryDecodeAuthCompact`.
-    function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)
-        internal
-        pure
-        returns (WebAuthnAuth memory decoded)
-    {
-        /// @solidity memory-safe-assembly
-        assembly {
-            function extractBytes(o_, l_) -> _m {
-                _m := mload(0x40) // Grab the free memory pointer.
-                let s_ := add(_m, 0x20)
-                calldatacopy(s_, o_, l_)
-                mstore(_m, l_) // Store the length.
-                mstore(add(l_, s_), 0) // Zeroize the slot after the string.
-                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.
-            }
-            if iszero(lt(encodedAuth.length, 0x46)) {
-                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.
-                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.
-                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.
-                let c := add(a, n) // Start of `clientDataJSON`.
-                let j := sub(e, 0x44) // Start of `challengeIndex`.
-                if iszero(gt(c, j)) {
-                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.
-                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.
-                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.
-                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.
-                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.
-                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.
-                }
-            }
-        }
-    }
-}
diff --git a/test/EIP7702Proxy.t.sol b/test/EIP7702Proxy.t.sol
deleted file mode 100644
index 7b0261f..0000000
--- a/test/EIP7702Proxy.t.sol
+++ /dev/null
@@ -1,293 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./utils/SoladyTest.sol";
-import {LibEIP7702} from "../src/accounts/LibEIP7702.sol";
-
-interface IEIP7702ProxyWithAdminABI {
-    function implementation() external view returns (address);
-    function admin() external view returns (address);
-    function changeAdmin(address) external returns (bool);
-    function upgrade(address) external returns (bool);
-    function bad() external;
-}
-
-contract Implementation2 {
-    uint256 public value;
-
-    function version() external pure returns (uint256) {
-        return 2;
-    }
-
-    function setValue(uint256 value_) public {
-        value = value_;
-        LibEIP7702.requestProxyDelegationInitialization();
-    }
-
-    function upgradeProxyDelegation(address newImplementation) public {
-        LibEIP7702.upgradeProxyDelegation(newImplementation);
-    }
-}
-
-contract EIP7702ProxyTest is SoladyTest {
-    error CustomError(uint256 currentValue);
-
-    uint256 public value;
-
-    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =
-        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
-
-    bytes32 internal constant _ERC1967_ADMIN_SLOT =
-        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
-
-    function setValue(uint256 value_) public {
-        value = value_;
-        LibEIP7702.requestProxyDelegationInitialization();
-    }
-
-    function revertWithError() public view {
-        revert CustomError(value);
-    }
-
-    function version() external pure returns (uint256) {
-        return 1;
-    }
-
-    function unsetProxyDelegation() public {
-        LibEIP7702.upgradeProxyDelegation(address(0));
-    }
-
-    function _checkBehavesLikeProxy(address instance) internal {
-        assertTrue(instance != address(0));
-
-        assertEq(EIP7702ProxyTest(instance).version(), 1);
-
-        uint256 v = _randomUniform();
-        uint256 thisValue = this.value();
-        if (thisValue == v) {
-            v ^= 1;
-        }
-        EIP7702ProxyTest(instance).setValue(v);
-        assertEq(v, EIP7702ProxyTest(instance).value());
-
-        assertEq(thisValue, this.value());
-        vm.expectRevert(abi.encodeWithSelector(CustomError.selector, v));
-        EIP7702ProxyTest(instance).revertWithError();
-    }
-
-    function upgradeProxyDelegation(address newImplementation) public {
-        LibEIP7702.upgradeProxyDelegation(newImplementation);
-    }
-
-    function testEIP7702Proxy(bytes32, bool f) public {
-        vm.pauseGasMetering();
-
-        address admin = _randomUniqueHashedAddress();
-        IEIP7702ProxyWithAdminABI eip7702Proxy =
-            IEIP7702ProxyWithAdminABI(LibEIP7702.deployProxy(address(this), admin));
-        assertEq(eip7702Proxy.admin(), admin);
-        assertEq(LibEIP7702.proxyAdmin(address(eip7702Proxy)), admin);
-        assertEq(eip7702Proxy.implementation(), address(this));
-        assertEq(LibEIP7702.implementationOf(address(eip7702Proxy)), address(this));
-
-        if (!f && _randomChance(16)) {
-            address newAdmin = _randomUniqueHashedAddress();
-            vm.startPrank(admin);
-            if (_randomChance(2)) {
-                eip7702Proxy.changeAdmin(newAdmin);
-            } else {
-                LibEIP7702.changeProxyAdmin(address(eip7702Proxy), newAdmin);
-            }
-            assertEq(eip7702Proxy.admin(), newAdmin);
-            vm.stopPrank();
-            admin = newAdmin;
-            vm.startPrank(_randomUniqueHashedAddress());
-            vm.expectRevert();
-            eip7702Proxy.changeAdmin(newAdmin);
-            vm.stopPrank();
-        }
-
-        if (!f && _randomChance(16)) {
-            address newImplementation = _randomUniqueHashedAddress();
-            vm.startPrank(admin);
-            if (_randomChance(2)) {
-                eip7702Proxy.upgrade(newImplementation);
-            } else {
-                LibEIP7702.upgradeProxy(address(eip7702Proxy), newImplementation);
-            }
-            assertEq(eip7702Proxy.implementation(), newImplementation);
-            eip7702Proxy.upgrade(address(this));
-            assertEq(eip7702Proxy.implementation(), address(this));
-            vm.stopPrank();
-        }
-
-        if (!f && _randomChance(16)) {
-            vm.startPrank(admin);
-            vm.expectRevert();
-            eip7702Proxy.bad();
-            vm.stopPrank();
-        }
-
-        // Generate some random value that has the lower 160 bits zeroized,
-        // to test if the proxy can handle dirty bits.
-        uint256 r = (_random() >> 160) << 160;
-        vm.store(address(this), _ERC1967_IMPLEMENTATION_SLOT, bytes32(r));
-
-        if (!f && _randomChance(16)) {
-            address newImplementation = _randomUniqueHashedAddress();
-            LibEIP7702.upgradeProxyDelegation(newImplementation);
-            uint256 loaded = uint256(vm.load(address(this), _ERC1967_IMPLEMENTATION_SLOT));
-            assertEq(address(uint160(loaded)), newImplementation);
-            assertEq(loaded >> 160, r >> 160);
-        }
-
-        address authority = _randomUniqueHashedAddress();
-        assertEq(LibEIP7702.delegationOf(authority), address(0));
-        vm.etch(authority, abi.encodePacked(hex"ef0100", address(eip7702Proxy)));
-
-        vm.store(authority, _ERC1967_IMPLEMENTATION_SLOT, bytes32(r));
-
-        emit LogAddress("authority", authority);
-        emit LogAddress("proxy", address(eip7702Proxy));
-        emit LogAddress("address(this)", address(this));
-
-        // Runtime REVM detection.
-        // If this check fails, then we are not ready to test it in CI.
-        // The exact length is 23 at the time of writing as of the EIP7702 spec,
-        // but we give our heuristic some leeway.
-        if (authority.code.length > 0x20) return;
-
-        vm.resumeGasMetering();
-
-        _checkBehavesLikeProxy(authority);
-
-        vm.pauseGasMetering();
-
-        if (!f) assertEq(LibEIP7702.delegationOf(authority), address(eip7702Proxy));
-
-        // Check that upgrading the proxy won't cause the authority's implementation to change.
-        if (!f && _randomChance(2)) {
-            vm.startPrank(admin);
-            eip7702Proxy.upgrade(address(1));
-        }
-
-        _checkBehavesLikeProxy(authority);
-
-        if (!f && _randomChance(2)) {
-            EIP7702ProxyTest(authority).upgradeProxyDelegation(address(new Implementation2()));
-            assertEq(Implementation2(authority).version(), 2);
-            Implementation2(authority).upgradeProxyDelegation(address(this));
-        }
-
-        if (!f && _randomChance(2) && (r >> 160) > 0) {
-            vm.startPrank(admin);
-            eip7702Proxy.upgrade(address(new Implementation2()));
-            vm.stopPrank();
-            EIP7702ProxyTest(authority).unsetProxyDelegation();
-            assertEq(Implementation2(authority).version(), 2);
-
-            uint256 loaded = uint256(vm.load(authority, _ERC1967_IMPLEMENTATION_SLOT));
-            assertEq(address(uint160(loaded)), address(0));
-            assertEq(loaded >> 160, r >> 160);
-
-            EIP7702ProxyTest(authority).setValue(123);
-            assertEq(Implementation2(authority).version(), 2);
-
-            loaded = uint256(vm.load(authority, _ERC1967_IMPLEMENTATION_SLOT));
-            assertEq(address(uint160(loaded)), eip7702Proxy.implementation());
-            assertEq(loaded >> 160, r >> 160);
-        }
-
-        vm.resumeGasMetering();
-    }
-
-    function testEIP7702Proxy() public {
-        testEIP7702Proxy(0, true);
-    }
-
-    function testEIP7702DelegationAndImplementationOf(bytes32) public {
-        address defaultImplementation = _randomUniqueHashedAddress();
-        address defaultAdmin = _randomUniqueHashedAddress();
-
-        if (_randomChance(2)) {
-            defaultImplementation = address(this);
-        }
-        if (_randomChance(2)) {
-            defaultAdmin = address(0);
-        }
-        address proxy = LibEIP7702.deployProxy(defaultImplementation, defaultAdmin);
-        address authority = _randomUniqueHashedAddress();
-        vm.etch(authority, abi.encodePacked(hex"ef0100", proxy));
-        if (authority.code.length > 0x20) return;
-
-        (address accountDelegation, address implementation) =
-            LibEIP7702.delegationAndImplementationOf(authority);
-        assertEq(accountDelegation, proxy);
-        assertEq(implementation, defaultImplementation);
-
-        if (defaultAdmin != address(0)) {
-            address newImplementation = address(new Implementation2());
-            vm.startPrank(defaultAdmin);
-            IEIP7702ProxyWithAdminABI(proxy).upgrade(newImplementation);
-            vm.stopPrank();
-            (accountDelegation, implementation) =
-                LibEIP7702.delegationAndImplementationOf(authority);
-            assertEq(accountDelegation, proxy);
-            assertEq(implementation, newImplementation);
-            vm.startPrank(defaultAdmin);
-            IEIP7702ProxyWithAdminABI(proxy).upgrade(address(this));
-            vm.stopPrank();
-        }
-
-        if (defaultImplementation == address(this)) {
-            address newImplementation = address(new Implementation2());
-            EIP7702ProxyTest(authority).upgradeProxyDelegation(newImplementation);
-            (accountDelegation, implementation) =
-                LibEIP7702.delegationAndImplementationOf(authority);
-            assertEq(accountDelegation, proxy);
-            assertEq(implementation, newImplementation);
-            Implementation2(authority).upgradeProxyDelegation(address(this));
-        }
-    }
-
-    function testEIP7702ProxyWithDefaultImplementation(bytes32, bool f) public {
-        vm.pauseGasMetering();
-
-        IEIP7702ProxyWithAdminABI eip7702Proxy =
-            IEIP7702ProxyWithAdminABI(LibEIP7702.deployProxy(address(this), address(0)));
-
-        assertEq(eip7702Proxy.admin(), address(0));
-        assertEq(LibEIP7702.proxyAdmin(address(eip7702Proxy)), address(0));
-        assertEq(eip7702Proxy.implementation(), address(this));
-        assertEq(LibEIP7702.implementationOf(address(eip7702Proxy)), address(this));
-
-        address authority = _randomUniqueHashedAddress();
-        assertEq(LibEIP7702.delegationOf(authority), address(0));
-        vm.etch(authority, abi.encodePacked(hex"ef0100", address(eip7702Proxy)));
-
-        // Generate some random value that has the lower 160 bits zeroized,
-        // to test if the proxy can handle dirty bits.
-        uint256 r = (_random() >> 160) << 160;
-        vm.store(authority, _ERC1967_IMPLEMENTATION_SLOT, bytes32(r));
-
-        if (authority.code.length > 0x20) return;
-
-        vm.resumeGasMetering();
-
-        _checkBehavesLikeProxy(authority);
-
-        vm.pauseGasMetering();
-
-        if (!f && _randomChance(2)) {
-            EIP7702ProxyTest(authority).upgradeProxyDelegation(address(new Implementation2()));
-            assertEq(Implementation2(authority).version(), 2);
-            Implementation2(authority).upgradeProxyDelegation(address(this));
-        }
-
-        vm.resumeGasMetering();
-    }
-
-    function testEIP7702ProxyWithDefaultImplementation() public {
-        testEIP7702ProxyWithDefaultImplementation(0, true);
-    }
-}
diff --git a/test/LibTransient.t.sol b/test/LibTransient.t.sol
deleted file mode 100644
index 1a279d2..0000000
--- a/test/LibTransient.t.sol
+++ /dev/null
@@ -1,532 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-import "./utils/SoladyTest.sol";
-import {LibTransient} from "../src/utils/LibTransient.sol";
-import {LibClone} from "../src/utils/LibClone.sol";
-
-contract A {
-    address public immutable b;
-
-    constructor() {
-        b = abi.decode(LibTransient.registryGet("b"), (address));
-    }
-}
-
-contract B {
-    address public immutable a;
-
-    constructor() {
-        a = abi.decode(LibTransient.registryGet("a"), (address));
-    }
-}
-
-contract LibTransientTest is SoladyTest {
-    using LibTransient for *;
-
-    function testSetAndGetBytesTransient() public {
-        vm.chainId(2);
-        _testSetAndGetBytesTransient("123");
-        _testSetAndGetBytesTransient("12345678901234567890123456789012345678901234567890");
-        _testSetAndGetBytesTransient("123");
-    }
-
-    function _testSetAndGetBytesTransient(bytes memory data) internal {
-        LibTransient.TBytes storage p = LibTransient.tBytes(uint256(0));
-        p.setCompat(data);
-        assertEq(p.lengthCompat(), data.length);
-        assertEq(p.getCompat(), data);
-    }
-
-    function testSetAndGetBytesTransientCalldata(
-        uint256 tSlot,
-        bytes calldata data0,
-        bytes calldata data1
-    ) public {
-        vm.chainId(_randomUniform() & 3);
-        unchecked {
-            LibTransient.TBytes storage p0 = LibTransient.tBytes(tSlot);
-            LibTransient.TBytes storage p1 = LibTransient.tBytes(tSlot + 1);
-            if (_randomChance(2)) {
-                p0.setCalldataCompat(data0);
-                p1.setCalldataCompat(data1);
-            } else {
-                p0.setCompat(data0);
-                p1.setCompat(data1);
-            }
-            assertEq(p0.getCompat(), data0);
-            assertEq(p1.getCompat(), data1);
-            if (_randomChance(2)) {
-                p0.setCalldataCompat(data1);
-                p1.setCalldataCompat(data0);
-            } else {
-                p0.setCompat(data1);
-                p1.setCompat(data0);
-            }
-            assertEq(p0.getCompat(), data1);
-            assertEq(p1.getCompat(), data0);
-            p0.clearCompat();
-            assertEq(p0.lengthCompat(), 0);
-            assertEq(p0.getCompat(), "");
-            assertEq(p1.getCompat(), data0);
-            p1.clearCompat();
-            assertEq(p1.lengthCompat(), 0);
-            assertEq(p1.getCompat(), "");
-            assertEq(p0.lengthCompat(), 0);
-            assertEq(p0.getCompat(), "");
-        }
-    }
-
-    function testSetAndGetBytesTransient(uint256 tSlot, bytes memory data) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TBytes storage p = LibTransient.tBytes(tSlot);
-        if (_randomChance(8)) data = _randomBytes();
-        p.setCompat(data);
-        assertEq(p.lengthCompat(), data.length);
-        if (_randomChance(8)) {
-            _misalignFreeMemoryPointer();
-            _brutalizeMemory();
-        }
-        bytes memory retrieved = p.getCompat();
-        _checkMemory(retrieved);
-        assertEq(retrieved, data);
-        p.clearCompat();
-        assertEq(p.lengthCompat(), 0);
-        assertEq(p.getCompat(), "");
-    }
-
-    function testSetAndGetBytesTransientCalldata(uint256 tSlot, bytes calldata data) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TBytes storage p = LibTransient.tBytes(tSlot);
-        p.setCompat(data);
-        assertEq(p.lengthCompat(), data.length);
-        assertEq(p.getCompat(), data);
-        p.clearCompat();
-        assertEq(p.lengthCompat(), 0);
-        assertEq(p.getCompat(), "");
-    }
-
-    function testSetAndGetUint256Transient(uint256 tSlot, uint256 value) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TUint256 storage p = LibTransient.tUint256(tSlot);
-        p.setCompat(value);
-        assertEq(p.getCompat(), value);
-        p.clearCompat();
-        assertEq(p.getCompat(), 0);
-    }
-
-    function testSetAndGetInt256Transient(uint256 tSlot, int256 value) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TInt256 storage p = LibTransient.tInt256(tSlot);
-        p.setCompat(value);
-        assertEq(p.getCompat(), value);
-        p.clearCompat();
-        assertEq(p.getCompat(), 0);
-    }
-
-    function testSetAndGetAddressTransient(uint256 tSlot, address value) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TAddress storage p = LibTransient.tAddress(tSlot);
-        p.setCompat(_brutalized(value));
-        assertEq(p.getCompat(), value);
-        p.clearCompat();
-        assertEq(p.getCompat(), address(0));
-    }
-
-    function testSetAndGetBytes32Transient(uint256 tSlot, bytes32 value) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TBytes32 storage p = LibTransient.tBytes32(tSlot);
-        p.setCompat(value);
-        assertEq(p.getCompat(), value);
-        p.clearCompat();
-        assertEq(p.getCompat(), bytes32(0));
-    }
-
-    function testSetAndGetBoolTransient(uint256 tSlot, bool value) public {
-        vm.chainId(_randomUniform() & 3);
-        LibTransient.TBool storage p = LibTransient.tBool(tSlot);
-        p.setCompat(_brutalized(value));
-        assertEq(p.getCompat(), value);
-        p.clearCompat();
-        assertEq(p.getCompat(), false);
-    }
-
-    function testUint256IncDecTransient() public {
-        for (uint256 c; c < 3; ++c) {
-            vm.chainId(c);
-            uint256 tSlot;
-            LibTransient.TUint256 storage p = LibTransient.tUint256(tSlot);
-            p.setCompat(10);
-            assertEq(this.tUintIncCompat(tSlot), 11);
-            assertEq(p.getCompat(), 11);
-            assertEq(this.tUintIncCompat(tSlot, 20), 31);
-            assertEq(p.getCompat(), 31);
-            p.setCompat(2 ** 256 - 2);
-            assertEq(this.tUintIncCompat(tSlot), 2 ** 256 - 1);
-            assertEq(p.getCompat(), 2 ** 256 - 1);
-            vm.expectRevert();
-            this.tUintIncCompat(tSlot);
-            vm.expectRevert();
-            this.tUintIncCompat(tSlot, 10);
-            assertEq(this.tUintDecCompat(tSlot), 2 ** 256 - 2);
-            assertEq(p.getCompat(), 2 ** 256 - 2);
-            p.setCompat(10);
-            assertEq(this.tUintDecCompat(tSlot, 5), 5);
-            assertEq(p.getCompat(), 5);
-            assertEq(this.tUintDecCompat(tSlot, 5), 0);
-            assertEq(p.getCompat(), 0);
-            vm.expectRevert();
-            this.tUintDecCompat(tSlot);
-            vm.expectRevert();
-            this.tUintDecCompat(tSlot, 5);
-            p.setCompat(10);
-            assertEq(this.tUintIncSignedCompat(tSlot, 1), 11);
-            assertEq(p.getCompat(), 11);
-            assertEq(this.tUintIncSignedCompat(tSlot, -1), 10);
-            assertEq(p.getCompat(), 10);
-            assertEq(this.tUintDecSignedCompat(tSlot, 1), 9);
-            assertEq(p.getCompat(), 9);
-            assertEq(this.tUintDecSignedCompat(tSlot, -1), 10);
-            assertEq(p.getCompat(), 10);
-        }
-    }
-
-    function tUintIncSignedCompat(uint256 tSlot, int256 delta) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).incSignedCompat(delta);
-    }
-
-    function tUintDecSignedCompat(uint256 tSlot, int256 delta) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).decSignedCompat(delta);
-    }
-
-    function tUintIncCompat(uint256 tSlot, uint256 delta) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).incCompat(delta);
-    }
-
-    function tUintDecCompat(uint256 tSlot, uint256 delta) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).decCompat(delta);
-    }
-
-    function tUintIncCompat(uint256 tSlot) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).incCompat();
-    }
-
-    function tUintDecCompat(uint256 tSlot) public returns (uint256) {
-        return LibTransient.tUint256(tSlot).decCompat();
-    }
-
-    function tIntIncCompat(uint256 tSlot, int256 delta) public returns (int256) {
-        return LibTransient.tInt256(tSlot).incCompat(delta);
-    }
-
-    function tIntDecCompat(uint256 tSlot, int256 delta) public returns (int256) {
-        return LibTransient.tInt256(tSlot).decCompat(delta);
-    }
-
-    function tIntIncCompat(uint256 tSlot) public returns (int256) {
-        return LibTransient.tInt256(tSlot).incCompat();
-    }
-
-    function tIntDecCompat(uint256 tSlot) public returns (int256) {
-        return LibTransient.tInt256(tSlot).decCompat();
-    }
-
-    function testSetBytesTransientRevertsIfLengthTooBig(uint256 n) public {
-        n = _bound(n, 0x100000000, type(uint256).max);
-        vm.chainId(_randomUniform() & 3);
-        vm.expectRevert();
-        this.setBytesTransientWithLengthTooBig(n);
-    }
-
-    function testSetBytesTransientRevertsIfLengthTooBigCalldata(uint256 n) public {
-        n = _bound(n, 0x100000000, type(uint256).max);
-        vm.chainId(_randomUniform() & 3);
-        vm.expectRevert();
-        this.setBytesTransientWithLengthTooBigCalldata(n);
-    }
-
-    function setBytesTransientWithLengthTooBig(uint256 n) public {
-        bytes memory data;
-        /// @solidity memory-safe-assembly
-        assembly {
-            data := mload(0x40)
-            mstore(data, n)
-            mstore(0x40, add(data, 0x20))
-        }
-        LibTransient.tBytes(uint256(0)).setCompat(data);
-    }
-
-    function setBytesTransientWithLengthTooBigCalldata(uint256 n) public {
-        bytes calldata data;
-        /// @solidity memory-safe-assembly
-        assembly {
-            data.offset := 0
-            data.length := n
-        }
-        LibTransient.tBytes(uint256(0)).setCalldataCompat(data);
-    }
-
-    function testStackPlacePopBytes() public {
-        testStackPlacePopBytes(type(uint256).max, 0, 1);
-    }
-
-    function testStackPlacePopBytes(uint256 r, uint256 aStackSlot, uint256 bStackSlot) public {
-        bytes[] memory aValues = new bytes[]((r >> 8) & 0x7);
-        bytes[] memory bValues = new bytes[]((r >> 16) & 0x7);
-        if (aStackSlot == bStackSlot) {
-            bStackSlot = aStackSlot ^ 1;
-        }
-        for (uint256 i; i < aValues.length; ++i) {
-            aValues[i] = abi.encodePacked(keccak256(abi.encode(i, aStackSlot)), "hehe");
-            LibTransient.tStack(aStackSlot).place().tBytes().set(aValues[i]);
-        }
-        for (uint256 i; i < bValues.length; ++i) {
-            bValues[i] = abi.encodePacked(keccak256(abi.encode(i, bStackSlot)));
-            LibTransient.tStack(bStackSlot).place().tBytes().set(bValues[i]);
-        }
-        if (aValues.length > 0) {
-            bytes memory expected = aValues[aValues.length - 1];
-            assertEq(LibTransient.tStack(aStackSlot).top().tBytes().get(), expected);
-            assertEq(LibTransient.tStack(aStackSlot).peek().tBytes().get(), expected);
-            assertGt(uint256(LibTransient.tStack(aStackSlot).peek()), 0);
-        } else {
-            assertEq(uint256(LibTransient.tStack(aStackSlot).peek()), 0);
-            assertEq(LibTransient.tStack(aStackSlot).peek().tBytes().get(), "");
-        }
-        if (bValues.length > 0) {
-            bytes memory expected = bValues[bValues.length - 1];
-            assertEq(LibTransient.tStack(bStackSlot).top().tBytes().get(), expected);
-            assertEq(LibTransient.tStack(bStackSlot).peek().tBytes().get(), expected);
-            assertGt(uint256(LibTransient.tStack(bStackSlot).peek()), 0);
-        } else {
-            assertEq(uint256(LibTransient.tStack(bStackSlot).peek()), 0);
-            assertEq(LibTransient.tStack(bStackSlot).peek().tBytes().get(), "");
-        }
-        for (uint256 i; i < aValues.length; ++i) {
-            bytes memory expected = aValues[aValues.length - 1 - i];
-            assertEq(LibTransient.tStack(aStackSlot).pop().tBytes().get(), expected);
-        }
-        for (uint256 i; i < bValues.length; ++i) {
-            bytes memory expected = bValues[bValues.length - 1 - i];
-            assertEq(LibTransient.tStack(bStackSlot).pop().tBytes().get(), expected);
-        }
-    }
-
-    function testStackPlacePopClear(bytes32 stackSlot) public {
-        uint256 n = _randomUniform() & 7;
-        for (uint256 i; i < n; ++i) {
-            assertEq(LibTransient.tStack(stackSlot).length(), i);
-            bytes32 x = keccak256(abi.encode(i));
-            LibTransient.tStack(stackSlot).place().tBytes32().set(x);
-            assertEq(LibTransient.tStack(stackSlot).top().tBytes32().get(), x);
-            assertEq(LibTransient.tStack(stackSlot).peek().tBytes32().get(), x);
-        }
-        assertEq(LibTransient.tStack(stackSlot).length(), n);
-
-        LibTransient.tStack(stackSlot).clear();
-        assertEq(LibTransient.tStack(stackSlot).peek(), 0);
-        if (stackSlot != 0) {
-            assertEq(LibTransient.tStack(stackSlot).peek().tBytes32().get(), 0);
-        }
-
-        assertEq(LibTransient.tStack(stackSlot).length(), 0);
-        for (uint256 i; i < n; ++i) {
-            assertEq(LibTransient.tStack(stackSlot).length(), i);
-            assertEq(LibTransient.tStack(stackSlot).place().tBytes32().get(), 0);
-        }
-    }
-
-    function testStackPeekTrick(uint256 base, uint256 n, uint256 r) public pure {
-        check_StackPeekTrick(base, n, r);
-    }
-
-    function check_StackPeekTrick(uint256 base, uint256 n, uint256 r) public pure {
-        n = (n & 0xffffffffffffffff) | 1;
-        unchecked {
-            uint256 s = base * 0x9e076501211e1371b + ((n * 0x100000000) | (r << 128));
-            assert(s != 0);
-        }
-    }
-
-    function testEmptyStackTopReverts() public {
-        vm.expectRevert(LibTransient.StackIsEmpty.selector);
-        this.stackTop(0);
-    }
-
-    function testEmptyStackPopReverts() public {
-        vm.expectRevert(LibTransient.StackIsEmpty.selector);
-        this.stackPop(0);
-    }
-
-    function stackTop(uint256 stackSlot) public view returns (bytes32) {
-        return LibTransient.tStack(stackSlot).top();
-    }
-
-    function stackPop(uint256 stackSlot) public returns (bytes32) {
-        return LibTransient.tStack(stackSlot).pop();
-    }
-
-    function testRegistry(bytes32 key, bytes memory value) public {
-        _etchTransientRegistry();
-        if (_randomChance(2)) {
-            vm.expectRevert(bytes4(keccak256("TransientRegistryUnauthorized()")));
-            this.registryClear(key);
-        }
-
-        this.registrySet(key, value);
-        assertEq(this.registryGet(key), value);
-        assertEq(this.registryAdminOf(key), address(this));
-
-        if (_randomChance(2)) {
-            address newAdmin = _randomUniqueHashedAddress();
-            vm.expectRevert(bytes4(keccak256("TransientRegistryUnauthorized()")));
-            this.registrySet(newAdmin, key, value);
-        }
-
-        if (_randomChance(2)) {
-            vm.expectRevert(bytes4(keccak256("TransientRegistryNewAdminIsZeroAddress()")));
-            this.registryChangeAdmin(key, address(0));
-        }
-
-        if (_randomChance(2)) {
-            address newAdmin = _randomUniqueHashedAddress();
-            uint256 newAdminRaw = uint256(uint160(newAdmin));
-            if (_randomChance(2)) newAdminRaw |= _random() << 160;
-
-            bool success;
-            if (newAdminRaw >> 160 == 0) {
-                if (_randomChance(2)) {
-                    (success,) = LibTransient.REGISTRY.call(
-                        abi.encodeWithSignature("changeAdmin(bytes32,address)", key, newAdminRaw)
-                    );
-                    assertTrue(success);
-                } else {
-                    this.registryChangeAdmin(key, newAdmin);
-                }
-            } else {
-                (success,) = LibTransient.REGISTRY.call(
-                    abi.encodeWithSignature("changeAdmin(bytes32,address)", key, newAdminRaw)
-                );
-                assertFalse(success);
-                newAdminRaw = (newAdminRaw << 96) >> 96;
-                (success,) = LibTransient.REGISTRY.call(
-                    abi.encodeWithSignature("changeAdmin(bytes32,address)", key, newAdminRaw)
-                );
-                assertTrue(success);
-            }
-
-            assertEq(this.registryAdminOf(key), newAdmin);
-            if (_randomChance(2)) return;
-
-            bytes memory anotherValue = _randomBytes();
-            this.registrySet(newAdmin, key, anotherValue);
-            assertEq(this.registryGet(key), anotherValue);
-            assertEq(this.registryAdminOf(key), newAdmin);
-
-            this.registryChangeAdmin(newAdmin, key, address(this));
-        }
-
-        if (_randomChance(2)) {
-            if (_randomChance(2)) this.registryClear(key);
-            bytes memory anotherValue = _randomBytes();
-            this.registrySet(key, anotherValue);
-            assertEq(this.registryGet(key), anotherValue);
-            assertEq(this.registryAdminOf(key), address(this));
-        }
-
-        if (_randomChance(2)) {
-            this.registryClear(key);
-            vm.expectRevert(bytes4(keccak256("TransientRegistryKeyDoesNotExist()")));
-            this.registryGet(key);
-            assertEq(this.registryAdminOf(key), address(0));
-
-            if (_randomChance(2)) return;
-
-            address newAdmin = _randomUniqueHashedAddress();
-            this.registrySet(newAdmin, key, value);
-            assertEq(this.registryGet(key), value);
-            assertEq(this.registryAdminOf(key), newAdmin);
-        }
-    }
-
-    function testRegistryAB() public {
-        _etchTransientRegistry();
-        bytes32 aInitCodeHash = keccak256(type(A).creationCode);
-        bytes32 bInitCodeHash = keccak256(type(B).creationCode);
-        address aAddress = LibClone.predictDeterministicAddress(aInitCodeHash, 0, _NICKS_FACTORY);
-        address bAddress = LibClone.predictDeterministicAddress(bInitCodeHash, 0, _NICKS_FACTORY);
-        this.registrySet("a", abi.encode(aAddress));
-        this.registrySet("b", abi.encode(bAddress));
-        A a = new A();
-        B b = new B();
-        assertEq(a.b(), bAddress);
-        assertEq(b.a(), aAddress);
-    }
-
-    function testRegistryNotDeployed() public {
-        bytes memory value = _randomBytes();
-        bytes memory empty;
-
-        vm.expectRevert(empty);
-        this.registrySet(bytes32(_randomUniform()), value);
-
-        vm.expectRevert(empty);
-        this.registryGet(bytes32(_randomUniform()));
-
-        vm.expectRevert(empty);
-        this.registryClear(bytes32(_randomUniform()));
-
-        vm.expectRevert(empty);
-        this.registryChangeAdmin(bytes32(_randomUniform()), _randomUniqueHashedAddress());
-
-        vm.expectRevert(empty);
-        this.registryAdminOf(bytes32(_randomUniform()));
-    }
-
-    function registrySet(bytes32 hash, bytes memory value) public {
-        LibTransient.registrySet(hash, value);
-        _checkMemory();
-    }
-
-    function registrySet(address pranker, bytes32 hash, bytes memory value) public {
-        vm.prank(pranker);
-        registrySet(hash, value);
-    }
-
-    function registryGet(bytes32 hash) public view returns (bytes memory result) {
-        result = LibTransient.registryGet(hash);
-        _checkMemory(result);
-    }
-
-    function registryClear(address pranker, bytes32 hash) public {
-        vm.prank(pranker);
-        registryClear(hash);
-    }
-
-    function registryClear(bytes32 hash) public {
-        LibTransient.registryClear(hash);
-        _checkMemory();
-    }
-
-    function registryChangeAdmin(address pranker, bytes32 hash, address newAdmin) public {
-        vm.prank(pranker);
-        registryChangeAdmin(hash, newAdmin);
-    }
-
-    function registryChangeAdmin(bytes32 hash, address newAdmin) public {
-        LibTransient.registryChangeAdmin(hash, newAdmin);
-        _checkMemory();
-    }
-
-    function registryAdminOf(bytes32 hash) public view returns (address) {
-        return LibTransient.registryAdminOf(hash);
-    }
-
-    function _etchTransientRegistry() internal {
-        bytes32 salt = 0x00000000000000000000000000000000000000001ef0fa4e834693009a3bcdbc;
-        bytes memory initializationCode =
-            hex"6080604052348015600e575f5ffd5b506104d48061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610064575f3560e01c806397040a451161004d57806397040a45146100b0578063aac438c0146100c3578063c5344411146100d6575f5ffd5b8063053b1ca3146100685780638eaa6ac014610090575b5f5ffd5b61007b610076366004610395565b61010e565b60405190151581526020015b60405180910390f35b6100a361009e3660046103db565b61016e565b60405161008791906103f2565b61007b6100be3660046103db565b610227565b61007b6100d1366004610427565b61029f565b6100e96100e43660046103db565b610361565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610087565b5f8161012157634396ac1b5f526004601cfd5b825f527f2c96949beeb8aca2ef85b169c5bca920576b836c1cb3edaa443380aff09df99b60205260405f20805c33146101615763860170335f526004601cfd5b82815d5060015f5260205ff35b6060815f527f2c96949beeb8aca2ef85b169c5bca920576b836c1cb3edaa443380aff09df99b60205260405f205c6101ad57639bdc798f5f526004601cfd5b7fc8f6675aac5818d398110f4d0e7276685c19f1a74e66eed262c8a6aa9aabaedf60205260405f20604051602081015f8152825c601c8201528051806020830101601d821061021757845f528260205f2003603c84015b8082015c81526020018281106102045750505b5f81526020845283810360200184f35b5f815f527f2c96949beeb8aca2ef85b169c5bca920576b836c1cb3edaa443380aff09df99b60205260405f2033815c146102685763860170335f526004601cfd5b5f815d507fc8f6675aac5818d398110f4d0e7276685c19f1a74e66eed262c8a6aa9aabaedf6020525f60405f205d60015f5260205ff35b5f835f527f2c96949beeb8aca2ef85b169c5bca920576b836c1cb3edaa443380aff09df99b60205260405f20805c80156102e7573381146102e75763860170335f526004601cfd5b5033815d507fc8f6675aac5818d398110f4d0e7276685c19f1a74e66eed262c8a6aa9aabaedf60205260405f20833560201c8360e01b17815d601d831061035757805f528284016020858560201c5f036020175f200301601c86015b80358282015d602001828110610343575050505b5060015f5260205ff35b5f815f527f2c96949beeb8aca2ef85b169c5bca920576b836c1cb3edaa443380aff09df99b60205260405f205c5f5260205ff35b5f5f604083850312156103a6575f5ffd5b82359150602083013573ffffffffffffffffffffffffffffffffffffffff811681146103d0575f5ffd5b809150509250929050565b5f602082840312156103eb575f5ffd5b5035919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f5f5f60408486031215610439575f5ffd5b83359250602084013567ffffffffffffffff811115610456575f5ffd5b8401601f81018613610466575f5ffd5b803567ffffffffffffffff81111561047c575f5ffd5b86602082840101111561048d575f5ffd5b93966020919091019550929350505056fea2646970667358221220af8785b9665e5c7f00368ff4d9720b2d4f4b6d2d9eb7be97936fba46cc7e6dcd64736f6c634300081c0033";
-        address deployment = _nicksCreate2(0, salt, initializationCode);
-        assertEq(deployment, LibTransient.REGISTRY);
-    }
-}
diff --git a/test/P256.t.sol b/test/P256.t.sol
index c38b16d..0a88c0b 100644
--- a/test/P256.t.sol
+++ b/test/P256.t.sol
@@ -252,23 +252,23 @@ contract P256Test is P256VerifierEtcher {
         }
     }
 
-    function testP256Normalized(uint256 privateKey, bytes32 hash) public {
-        while (privateKey == 0 || privateKey >= P256.N) {
-            privateKey = uint256(keccak256(abi.encode(privateKey)));
-        }
-        (uint256 x, uint256 y) = vm.publicKeyP256(privateKey);
-
-        // Note that `vm.signP256` can produce `s` above `N / 2`.
-        (bytes32 r, bytes32 s) = vm.signP256(privateKey, hash);
-
-        if (uint256(s) > P256.N / 2) {
-            assertFalse(P256.verifySignature(hash, r, s, bytes32(x), bytes32(y)));
-            assertTrue(P256.verifySignature(hash, r, P256.normalized(s), bytes32(x), bytes32(y)));
-        } else {
-            assertTrue(P256.verifySignature(hash, r, s, bytes32(x), bytes32(y)));
-        }
-        assertTrue(P256.verifySignatureAllowMalleability(hash, r, s, bytes32(x), bytes32(y)));
-    }
+//    function testP256Normalized(uint256 privateKey, bytes32 hash) public {
+//        while (privateKey == 0 || privateKey >= P256.N) {
+//            privateKey = uint256(keccak256(abi.encode(privateKey)));
+//        }
+//        (uint256 x, uint256 y) = vm.publicKeyP256(privateKey);
+//
+//        // Note that `vm.signP256` can produce `s` above `N / 2`.
+//        (bytes32 r, bytes32 s) = vm.signP256(privateKey, hash);
+//
+//        if (uint256(s) > P256.N / 2) {
+//            assertFalse(P256.verifySignature(hash, r, s, bytes32(x), bytes32(y)));
+//            assertTrue(P256.verifySignature(hash, r, P256.normalized(s), bytes32(x), bytes32(y)));
+//        } else {
+//            assertTrue(P256.verifySignature(hash, r, s, bytes32(x), bytes32(y)));
+//        }
+//        assertTrue(P256.verifySignatureAllowMalleability(hash, r, s, bytes32(x), bytes32(y)));
+//    }
 
     function testHasPrecompileOrVerifier(bytes32) public {
         bool etchPrecompile = _randomChance(2);
diff --git a/test/ReentrancyGuardTransient.t.sol b/test/ReentrancyGuardTransient.t.sol
deleted file mode 100644
index 66d35f8..0000000
--- a/test/ReentrancyGuardTransient.t.sol
+++ /dev/null
@@ -1,115 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-import "./utils/SoladyTest.sol";
-import {ReentrancyGuardTransient} from "../src/utils/ReentrancyGuardTransient.sol";
-import {
-    MockReentrancyGuardTransient,
-    ReentrancyAttack
-} from "./utils/mocks/MockReentrancyGuardTransient.sol";
-
-contract ReentrancyGuardTransientTest is SoladyTest {
-    MockReentrancyGuardTransient immutable target = new MockReentrancyGuardTransient();
-    ReentrancyAttack immutable reentrancyAttack = new ReentrancyAttack();
-
-    // Before and after each test, the reentrancy guard should be unlocked.
-    modifier expectBeforeAfterReentrancyGuardTransientUnlocked() {
-        assertEq(target.isReentrancyGuardLocked(), false);
-        _;
-        assertEq(target.isReentrancyGuardLocked(), false);
-    }
-
-    function testRevertGuardLocked(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Attempt to call a `nonReentrant` methiod with an unprotected method.
-        // Expect a success.
-        target.callUnguardedToGuarded();
-        assertEq(target.enterTimes(), 1);
-
-        // Attempt to call a `nonReentrant` method within a `nonReentrant` method.
-        // Expect a revert with the `Reentrancy` error.
-        vm.expectRevert(ReentrancyGuardTransient.Reentrancy.selector);
-        target.callGuardedToGuarded();
-    }
-
-    function testRevertReadGuardLocked(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Attempt to call a `nonReadReentrant` methiod with an unprotected method.
-        // Expect a success.
-        target.callUnguardedToReadGuarded();
-        assertEq(target.enterTimes(), 1);
-
-        // Attempt to call a `nonReadReentrant` method within a `nonReentrant` method.
-        // Expect a revert with the `Reentrancy` error.
-        vm.expectRevert(ReentrancyGuardTransient.Reentrancy.selector);
-        target.callGuardedToReadGuarded();
-    }
-
-    function testRevertRemoteCallback(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Attempt to reenter a `nonReentrant` method from a remote contract.
-        vm.expectRevert(ReentrancyAttack.ReentrancyAttackFailed.selector);
-        target.countAndCall(reentrancyAttack);
-    }
-
-    function testRecursiveDirectUnguardedCall(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Expect to be able to call unguarded methods recursively.
-        // Expect a success.
-        target.countUnguardedDirectRecursive(10);
-        assertEq(target.enterTimes(), 10);
-    }
-
-    function testRevertRecursiveDirectGuardedCall(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Attempt to reenter a `nonReentrant` method from a direct call.
-        // Expect a revert with the `Reentrancy` error.
-        vm.expectRevert(ReentrancyGuardTransient.Reentrancy.selector);
-        target.countGuardedDirectRecursive(10);
-        assertEq(target.enterTimes(), 0);
-    }
-
-    function testRecursiveIndirectUnguardedCall(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Expect to be able to call unguarded methods recursively.
-        // Expect a success.
-        target.countUnguardedIndirectRecursive(10);
-        assertEq(target.enterTimes(), 10);
-    }
-
-    function testRevertRecursiveIndirectGuardedCall(uint8 chainId, bool transientOnlyOnMainnet)
-        external
-        expectBeforeAfterReentrancyGuardTransientUnlocked
-    {
-        vm.chainId(chainId);
-        target.setTransientOnlyOnMainnet(transientOnlyOnMainnet);
-        // Attempt to reenter a `nonReentrant` method from an indirect call.
-        vm.expectRevert(ReentrancyGuardTransient.Reentrancy.selector);
-        target.countGuardedIndirectRecursive(10);
-        assertEq(target.enterTimes(), 0);
-    }
-}
diff --git a/test/ext/ithaca/BLS.t.sol b/test/ext/ithaca/BLS.t.sol
deleted file mode 100644
index 7e3e3d2..0000000
--- a/test/ext/ithaca/BLS.t.sol
+++ /dev/null
@@ -1,293 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./../../utils/SoladyTest.sol";
-import {BLS} from "../../../src/utils/ext/ithaca/BLS.sol";
-
-contract BLSTest is SoladyTest {
-    function G1_GENERATOR() internal pure returns (BLS.G1Point memory) {
-        return BLS.G1Point(
-            _u(31827880280837800241567138048534752271),
-            _u(88385725958748408079899006800036250932223001591707578097800747617502997169851),
-            _u(11568204302792691131076548377920244452),
-            _u(114417265404584670498511149331300188430316142484413708742216858159411894806497)
-        );
-    }
-
-    function NEGATED_G1_GENERATOR() internal pure returns (BLS.G1Point memory) {
-        return BLS.G1Point(
-            _u(31827880280837800241567138048534752271),
-            _u(88385725958748408079899006800036250932223001591707578097800747617502997169851),
-            _u(22997279242622214937712647648895181298),
-            _u(46816884707101390882112958134453447585552332943769894357249934112654335001290)
-        );
-    }
-
-    function _u(uint256 x) internal pure returns (bytes32) {
-        return bytes32(x);
-    }
-
-    function testSignAndVerify() public {
-        // Obtain the private key as a random scalar.
-        bytes32 privateKey = bytes32(_randomUniform());
-
-        // Public key is the generator point multiplied by the private key.
-        BLS.G1Point memory publicKey = _blsg1mul(G1_GENERATOR(), privateKey);
-
-        // Compute the message point by mapping message's keccak256 hash to a point in G2.
-        bytes memory message = "hello world";
-        BLS.G2Point memory messagePoint = BLS.toG2(BLS.Fp2(0, 0, 0, keccak256(message)));
-
-        // Obtain the signature by multiplying the message point by the private key.
-        BLS.G2Point memory signature = _blsg2mul(messagePoint, privateKey);
-
-        // Invoke the pairing check to verify the signature.
-        BLS.G1Point[] memory g1Points = new BLS.G1Point[](2);
-        g1Points[0] = NEGATED_G1_GENERATOR();
-        g1Points[1] = publicKey;
-
-        BLS.G2Point[] memory g2Points = new BLS.G2Point[](2);
-        g2Points[0] = signature;
-        g2Points[1] = messagePoint;
-
-        assertTrue(BLS.pairing(g1Points, g2Points));
-    }
-
-    function testSignAndVerifyAggregated() public {
-        // private keys
-        bytes32 sk1 = bytes32(_randomUniform());
-        bytes32 sk2 = bytes32(_randomUniform());
-
-        // public keys
-        BLS.G1Point memory pk1 = _blsg1mul(G1_GENERATOR(), sk1);
-        BLS.G1Point memory pk2 = _blsg1mul(G1_GENERATOR(), sk2);
-
-        // Compute the message point by mapping message's keccak256 hash to a point in G2.
-        bytes memory message = "hello world";
-        BLS.G2Point memory messagePoint = BLS.toG2(BLS.Fp2(0, 0, 0, keccak256(message)));
-
-        // signatures
-        BLS.G2Point memory sig1 = _blsg2mul(messagePoint, sk1);
-        BLS.G2Point memory sig2 = _blsg2mul(messagePoint, sk2);
-
-        // aggregated signature
-        BLS.G2Point memory sig = BLS.add(sig1, sig2);
-
-        // Invoke the pairing check to verify the signature.
-        BLS.G1Point[] memory g1Points = new BLS.G1Point[](3);
-        g1Points[0] = NEGATED_G1_GENERATOR();
-        g1Points[1] = pk1;
-        g1Points[2] = pk2;
-
-        BLS.G2Point[] memory g2Points = new BLS.G2Point[](3);
-        g2Points[0] = sig;
-        g2Points[1] = messagePoint;
-        g2Points[2] = messagePoint;
-
-        assertTrue(BLS.pairing(g1Points, g2Points));
-    }
-
-    function testHashToCurveG2() public {
-        testHashToCurveG2("hehe");
-    }
-
-    function testHashToCurveG2(bytes memory message) public {
-        bytes memory expected = abi.encode(this.hashToCurveG2Original(message));
-        bytes memory computed = abi.encode(this.hashToCurveG2OptimizedBrutalized(message));
-        assertEq(computed, expected);
-    }
-
-    function hashToCurveG2Optimized(bytes memory message)
-        public
-        view
-        returns (BLS.G2Point memory result)
-    {
-        result = BLS.hashToG2(message);
-    }
-
-    function hashToCurveG2OptimizedBrutalized(bytes memory message)
-        public
-        view
-        returns (BLS.G2Point memory result)
-    {
-        _misalignFreeMemoryPointer();
-        _brutalizeMemory();
-        result = BLS.hashToG2(message);
-        _checkMemory();
-    }
-
-    /// @notice Computes a point in G2 from a message
-    /// @dev Uses the eip-2537 precompiles
-    /// @param message Arbitrarylength byte string to be hashed
-    /// @return A point in G2
-    function hashToCurveG2Original(bytes memory message) public view returns (BLS.G2Point memory) {
-        // 1. u = hash_to_field(msg, 2)
-        BLS.Fp2[2] memory u =
-            _hashToFieldFp2(message, bytes("BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_"));
-        // 2. Q0 = map_to_curve(u[0])
-        BLS.G2Point memory q0 = BLS.toG2(u[0]);
-        // 3. Q1 = map_to_curve(u[1])
-        BLS.G2Point memory q1 = BLS.toG2(u[1]);
-        // 4. R = Q0 + Q1
-        return BLS.add(q0, q1);
-    }
-
-    /// @notice Computes a field point from a message
-    /// @dev Follows https://datatracker.ietf.org/doc/html/rfc9380#section-5.2
-    /// @param message Arbitrarylength byte string to be hashed
-    /// @param dst The domain separation tag
-    /// @return Two field points
-    function _hashToFieldFp2(bytes memory message, bytes memory dst)
-        private
-        view
-        returns (BLS.Fp2[2] memory)
-    {
-        // 1. len_in_bytes = count * m * L
-        // so always 2 * 2 * 64 = 256
-        uint16 lenInBytes = 256;
-        // 2. uniform_bytes = expand_message(msg, DST, len_in_bytes)
-        bytes32[] memory pseudoRandomBytes = _expandMsgXmd(message, dst, lenInBytes);
-        BLS.Fp2[2] memory u;
-        // No loop here saves 800 gas hardcoding offset an additional 300
-        // 3. for i in (0, ..., count - 1):
-        // 4.   for j in (0, ..., m - 1):
-        // 5.     elm_offset = L * (j + i * m)
-        // 6.     tv = substr(uniform_bytes, elm_offset, HTF_L)
-        // uint8 HTF_L = 64;
-        // bytes memory tv = new bytes(64);
-        // 7.     e_j = OS2IP(tv) mod p
-        // 8.   u_i = (e_0, ..., e_(m - 1))
-        // tv = bytes.concat(pseudo_random_bytes[0], pseudo_random_bytes[1]);
-        BLS.Fp memory t;
-        t = _modfield(pseudoRandomBytes[0], pseudoRandomBytes[1]);
-        u[0].c0_a = t.a;
-        u[0].c0_b = t.b;
-        t = _modfield(pseudoRandomBytes[2], pseudoRandomBytes[3]);
-        u[0].c1_a = t.a;
-        u[0].c1_b = t.b;
-        t = _modfield(pseudoRandomBytes[4], pseudoRandomBytes[5]);
-        u[1].c0_a = t.a;
-        u[1].c0_b = t.b;
-        t = _modfield(pseudoRandomBytes[6], pseudoRandomBytes[7]);
-        u[1].c1_a = t.a;
-        u[1].c1_b = t.b;
-        // 9. return (u_0, ..., u_(count - 1))
-        return u;
-    }
-
-    /// @notice Computes a field point from a message
-    /// @dev Follows https://datatracker.ietf.org/doc/html/rfc9380#section-5.3
-    /// @dev bytes32[] because len_in_bytes is always a multiple of 32 in our case even 128
-    /// @param message Arbitrarylength byte string to be hashed
-    /// @param dst The domain separation tag of at most 255 bytes
-    /// @param lenInBytes The length of the requested output in bytes
-    /// @return A field point
-    function _expandMsgXmd(bytes memory message, bytes memory dst, uint16 lenInBytes)
-        private
-        pure
-        returns (bytes32[] memory)
-    {
-        // 1.  ell = ceil(len_in_bytes / b_in_bytes)
-        // b_in_bytes seems to be 32 for sha256
-        // ceil the division
-        uint256 ell = (lenInBytes - 1) / 32 + 1;
-
-        // 2.  ABORT if ell > 255 or len_in_bytes > 65535 or len(DST) > 255
-        require(ell <= 255, "len_in_bytes too large for sha256");
-        // Not really needed because of parameter type
-        // require(lenInBytes <= 65535, "len_in_bytes too large");
-        // no length normalizing via hashing
-        require(dst.length <= 255, "dst too long");
-
-        bytes memory dstPrime = bytes.concat(dst, bytes1(uint8(dst.length)));
-
-        // 4.  Z_pad = I2OSP(0, s_in_bytes)
-        // this should be sha256 blocksize so 64 bytes
-        bytes memory zPad = new bytes(64);
-
-        // 5.  l_i_b_str = I2OSP(len_in_bytes, 2)
-        // length in byte string?
-        bytes2 libStr = bytes2(lenInBytes);
-
-        // 6.  msg_prime = Z_pad || msg || l_i_b_str || I2OSP(0, 1) || DST_prime
-        bytes memory msgPrime = bytes.concat(zPad, message, libStr, hex"00", dstPrime);
-
-        // 7.  b_0 = H(msg_prime)
-        bytes32 b_0 = sha256(msgPrime);
-
-        bytes32[] memory b = new bytes32[](ell);
-
-        // 8.  b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)
-        b[0] = sha256(bytes.concat(b_0, hex"01", dstPrime));
-
-        // 9.  for i in (2, ..., ell):
-        for (uint8 i = 2; i <= ell; i++) {
-            // 10.    b_i = H(strxor(b_0, b_(i - 1)) || I2OSP(i, 1) || DST_prime)
-            bytes memory tmp = abi.encodePacked(b_0 ^ b[i - 2], i, dstPrime);
-            b[i - 1] = sha256(tmp);
-        }
-        // 11. uniform_bytes = b_1 || ... || b_ell
-        // 12. return substr(uniform_bytes, 0, len_in_bytes)
-        // Here we don't need the uniform_bytes because b is already properly formed
-        return b;
-    }
-
-    // passing two bytes32 instead of bytes memory saves approx 700 gas per call
-    // Computes the mod against the bls12-381 field modulus
-    function _modfield(bytes32 _b1, bytes32 _b2) private view returns (BLS.Fp memory r) {
-        (bool success, bytes memory output) = address(0x5).staticcall(
-            abi.encode(
-                // arg[0] = base.length
-                0x40,
-                // arg[1] = exp.length
-                0x20,
-                // arg[2] = mod.length
-                0x40,
-                // arg[3] = base.bits
-                // places the first 32 bytes of _b1 and the last 32 bytes of _b2
-                _b1,
-                _b2,
-                // arg[4] = exp
-                // exponent always 1
-                1,
-                // arg[5] = mod
-                // this field_modulus as hex 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
-                // we add the 0 prefix so that the result will be exactly 64 bytes
-                // saves 300 gas per call instead of sending it along every time
-                // places the first 32 bytes and the last 32 bytes of the field modulus
-                0x000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd7,
-                0x64774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
-            )
-        );
-        require(success, "MODEXP failed");
-        return abi.decode(output, (BLS.Fp));
-    }
-
-    function _blsg1mul(BLS.G1Point memory g1, bytes32 scalar)
-        private
-        view
-        returns (BLS.G1Point memory)
-    {
-        BLS.G1Point[] memory points = new BLS.G1Point[](1);
-        bytes32[] memory scalars = new bytes32[](1);
-
-        points[0] = g1;
-        scalars[0] = scalar;
-
-        return BLS.msm(points, scalars);
-    }
-
-    function _blsg2mul(BLS.G2Point memory g2, bytes32 scalar)
-        private
-        view
-        returns (BLS.G2Point memory)
-    {
-        BLS.G2Point[] memory points = new BLS.G2Point[](1);
-        bytes32[] memory scalars = new bytes32[](1);
-
-        points[0] = g2;
-        scalars[0] = scalar;
-
-        return BLS.msm(points, scalars);
-    }
-}
diff --git a/test/ext/zksync/ERC1155.t.sol b/test/ext/zksync/ERC1155.t.sol
deleted file mode 100644
index a7dbbb6..0000000
--- a/test/ext/zksync/ERC1155.t.sol
+++ /dev/null
@@ -1,1221 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./../../utils/SoladyTest.sol";
-
-import {ERC1155, MockERC1155} from "./../../utils/mocks/ext/zksync/MockERC1155.sol";
-
-abstract contract ERC1155TokenReceiver {
-    function onERC1155Received(address, address, uint256, uint256, bytes calldata)
-        external
-        virtual
-        returns (bytes4)
-    {
-        return ERC1155TokenReceiver.onERC1155Received.selector;
-    }
-
-    function onERC1155BatchReceived(
-        address,
-        address,
-        uint256[] calldata,
-        uint256[] calldata,
-        bytes calldata
-    ) external virtual returns (bytes4) {
-        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
-    }
-}
-
-contract ERC1155Recipient is ERC1155TokenReceiver {
-    address public operator;
-    address public from;
-    uint256 public id;
-    uint256 public amount;
-    bytes public mintData;
-
-    function onERC1155Received(
-        address _operator,
-        address _from,
-        uint256 _id,
-        uint256 _amount,
-        bytes calldata _data
-    ) public override returns (bytes4) {
-        operator = _operator;
-        from = _from;
-        id = _id;
-        amount = _amount;
-        mintData = _data;
-
-        return ERC1155TokenReceiver.onERC1155Received.selector;
-    }
-
-    address public batchOperator;
-    address public batchFrom;
-    uint256[] internal _batchIds;
-    uint256[] internal _batchAmounts;
-    bytes public batchData;
-
-    function batchIds() external view returns (uint256[] memory) {
-        return _batchIds;
-    }
-
-    function batchAmounts() external view returns (uint256[] memory) {
-        return _batchAmounts;
-    }
-
-    function onERC1155BatchReceived(
-        address _operator,
-        address _from,
-        uint256[] calldata _ids,
-        uint256[] calldata _amounts,
-        bytes calldata _data
-    ) external override returns (bytes4) {
-        batchOperator = _operator;
-        batchFrom = _from;
-        _batchIds = _ids;
-        _batchAmounts = _amounts;
-        batchData = _data;
-
-        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
-    }
-}
-
-contract RevertingERC1155Recipient is ERC1155TokenReceiver {
-    function onERC1155Received(address, address, uint256, uint256, bytes calldata)
-        public
-        pure
-        override
-        returns (bytes4)
-    {
-        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
-    }
-
-    function onERC1155BatchReceived(
-        address,
-        address,
-        uint256[] calldata,
-        uint256[] calldata,
-        bytes calldata
-    ) external pure override returns (bytes4) {
-        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
-    }
-}
-
-contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
-    function onERC1155Received(address, address, uint256, uint256, bytes calldata)
-        public
-        pure
-        override
-        returns (bytes4)
-    {
-        return 0xCAFEBEEF;
-    }
-
-    function onERC1155BatchReceived(
-        address,
-        address,
-        uint256[] calldata,
-        uint256[] calldata,
-        bytes calldata
-    ) external pure override returns (bytes4) {
-        return 0xCAFEBEEF;
-    }
-}
-
-contract NonERC1155Recipient {}
-
-contract MockERC1155WithHooks is MockERC1155 {
-    uint256 public beforeCounter;
-    uint256 public afterCounter;
-
-    function _useBeforeTokenTransfer() internal view virtual override returns (bool) {
-        return true;
-    }
-
-    function _useAfterTokenTransfer() internal view virtual override returns (bool) {
-        return true;
-    }
-
-    function _beforeTokenTransfer(
-        address,
-        address,
-        uint256[] memory,
-        uint256[] memory,
-        bytes memory
-    ) internal virtual override {
-        beforeCounter++;
-    }
-
-    function _afterTokenTransfer(address, address, uint256[] memory, uint256[] memory, bytes memory)
-        internal
-        virtual
-        override
-    {
-        afterCounter++;
-    }
-}
-
-contract ERC1155HooksTest is SoladyTest, ERC1155TokenReceiver {
-    uint256 public expectedBeforeCounter;
-    uint256 public expectedAfterCounter;
-
-    function _checkCounters() internal view {
-        require(
-            expectedBeforeCounter == MockERC1155WithHooks(msg.sender).beforeCounter(),
-            "Before counter mismatch."
-        );
-        require(
-            expectedAfterCounter == MockERC1155WithHooks(msg.sender).afterCounter(),
-            "After counter mismatch."
-        );
-    }
-
-    function onERC1155Received(address, address, uint256, uint256, bytes calldata)
-        external
-        virtual
-        override
-        returns (bytes4)
-    {
-        _checkCounters();
-        return ERC1155TokenReceiver.onERC1155Received.selector;
-    }
-
-    function onERC1155BatchReceived(
-        address,
-        address,
-        uint256[] calldata,
-        uint256[] calldata,
-        bytes calldata
-    ) external virtual override returns (bytes4) {
-        _checkCounters();
-        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
-    }
-
-    function _testHooks(MockERC1155WithHooks token) internal {
-        address from = _randomNonZeroAddress();
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.mint(address(this), 1, 1000, "");
-
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.safeTransferFrom(address(this), from, 1, 1000, "");
-
-        vm.prank(from);
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.safeTransferFrom(from, address(this), 1, 1, "");
-
-        vm.prank(from);
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.directSafeTransferFrom(from, address(this), 1, 1, "");
-
-        uint256[] memory ids = new uint256[](1);
-        uint256[] memory amounts = new uint256[](1);
-        ids[0] = 1;
-        amounts[0] = 1;
-
-        vm.prank(from);
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.safeBatchTransferFrom(from, address(this), ids, amounts, "");
-
-        vm.prank(from);
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.directSafeBatchTransferFrom(from, address(this), ids, amounts, "");
-    }
-
-    function testERC1155Hooks() public {
-        MockERC1155WithHooks token = new MockERC1155WithHooks();
-
-        for (uint256 i; i < 32; ++i) {
-            _testHooks(token);
-        }
-    }
-}
-
-contract ERC1155Test is SoladyTest, ERC1155TokenReceiver {
-    MockERC1155 token;
-
-    event TransferSingle(
-        address indexed operator,
-        address indexed from,
-        address indexed to,
-        uint256 id,
-        uint256 amount
-    );
-
-    event TransferBatch(
-        address indexed operator,
-        address indexed from,
-        address indexed to,
-        uint256[] ids,
-        uint256[] amounts
-    );
-
-    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);
-
-    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
-    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;
-
-    struct _TestTemps {
-        address from;
-        address to;
-        uint256 n;
-        uint256[] ids;
-        uint256[] mintAmounts;
-        uint256[] transferAmounts;
-        uint256[] burnAmounts;
-        uint256 id;
-        uint256 mintAmount;
-        uint256 transferAmount;
-        uint256 burnAmount;
-        bytes mintData;
-        bytes burnData;
-        bytes transferData;
-    }
-
-    function _randomArray(uint256 n) internal returns (uint256[] memory a) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            a := mload(0x40)
-            mstore(a, n)
-            mstore(0x40, add(add(a, 0x20), shl(5, n)))
-        }
-        unchecked {
-            for (uint256 i; i != n; ++i) {
-                a[i] = _random();
-            }
-        }
-    }
-
-    function _testTemps() internal returns (_TestTemps memory t) {
-        unchecked {
-            t.from = _randomNonZeroAddress();
-            do {
-                t.to = _randomNonZeroAddress();
-            } while (t.from == t.to);
-            uint256 n = _random() % 4;
-            t.n = n;
-            t.ids = _randomArray(n);
-            t.mintAmounts = _randomArray(n);
-            t.transferAmounts = _randomArray(n);
-            t.burnAmounts = _randomArray(n);
-            t.mintData = _randomBytes();
-            t.burnData = _randomBytes();
-            t.transferData = _randomBytes();
-            t.id = _random();
-            t.transferAmount = _random();
-            t.burnAmount = _random();
-            t.mintAmount = _random();
-        }
-    }
-
-    function _safeTransferFrom(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes memory data
-    ) internal {
-        if (_randomChance(2)) {
-            token.safeTransferFrom(from, to, id, amount, data);
-        } else {
-            token.directSafeTransferFrom(from, to, id, amount, data);
-        }
-    }
-
-    function _safeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal {
-        if (_randomChance(2)) {
-            token.safeBatchTransferFrom(from, to, ids, amounts, data);
-        } else {
-            token.directSafeBatchTransferFrom(from, to, ids, amounts, data);
-        }
-    }
-
-    function _setApprovalForAll(address operator, bool approved) internal {
-        if (_randomChance(2)) {
-            token.setApprovalForAll(operator, approved);
-        } else {
-            token.directSetApprovalForAll(operator, approved);
-        }
-    }
-
-    function _expectMintEvent(address to, uint256 id, uint256 amount) internal {
-        _expectMintEvent(address(this), to, id, amount);
-    }
-
-    function _expectMintEvent(address operator, address to, uint256 id, uint256 amount) internal {
-        _expectTransferEvent(operator, address(0), to, id, amount);
-    }
-
-    function _expectBurnEvent(address from, uint256 id, uint256 amount) internal {
-        _expectBurnEvent(address(this), from, id, amount);
-    }
-
-    function _expectBurnEvent(address operator, address from, uint256 id, uint256 amount)
-        internal
-    {
-        _expectTransferEvent(operator, from, address(0), id, amount);
-    }
-
-    function _expectTransferEvent(address from, address to, uint256 id, uint256 amount) internal {
-        _expectTransferEvent(address(this), from, to, id, amount);
-    }
-
-    function _expectTransferEvent(
-        address operator,
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount
-    ) internal {
-        vm.expectEmit(true, true, true, true);
-        emit TransferSingle(operator, from, to, id, amount);
-    }
-
-    function _expectMintEvent(address to, uint256[] memory ids, uint256[] memory amounts)
-        internal
-    {
-        _expectMintEvent(address(this), to, ids, amounts);
-    }
-
-    function _expectMintEvent(
-        address operator,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts
-    ) internal {
-        _expectTransferEvent(operator, address(0), to, ids, amounts);
-    }
-
-    function _expectBurnEvent(address from, uint256[] memory ids, uint256[] memory amounts)
-        internal
-    {
-        _expectBurnEvent(address(this), from, ids, amounts);
-    }
-
-    function _expectBurnEvent(
-        address operator,
-        address from,
-        uint256[] memory ids,
-        uint256[] memory amounts
-    ) internal {
-        _expectTransferEvent(operator, from, address(0), ids, amounts);
-    }
-
-    function _expectTransferEvent(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts
-    ) internal {
-        _expectTransferEvent(address(this), from, to, ids, amounts);
-    }
-
-    function _expectTransferEvent(
-        address operator,
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts
-    ) internal {
-        vm.expectEmit(true, true, true, true);
-        emit TransferBatch(operator, from, to, ids, amounts);
-    }
-
-    function _expectApprovalForAllEvent(address operator, bool isApproved) internal {
-        _expectApprovalForAllEvent(address(this), operator, isApproved);
-    }
-
-    function _expectApprovalForAllEvent(address owner, address operator, bool isApproved)
-        internal
-    {
-        vm.expectEmit(true, true, true, true);
-        emit ApprovalForAll(owner, operator, isApproved);
-    }
-
-    function setUp() public {
-        token = new MockERC1155();
-    }
-
-    function testDirectSetApprovalForAll(address by, address operator, bool approved) public {
-        _expectApprovalForAllEvent(by, operator, approved);
-        vm.prank(by);
-        token.directSetApprovalForAll(operator, approved);
-    }
-
-    function testAuthorizedEquivalence(address by, address from, bool isApprovedAccount) public {
-        bool a = true;
-        bool b = true;
-        /// @solidity memory-safe-assembly
-        assembly {
-            if by { if iszero(eq(by, from)) { a := isApprovedAccount } }
-            if iszero(or(iszero(by), eq(by, from))) { b := isApprovedAccount }
-        }
-        assertEq(a, b);
-    }
-
-    function testMintToEOA(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        _expectMintEvent(t.to, t.id, t.mintAmount);
-        token.mint(t.to, t.id, t.mintAmount, t.mintData);
-
-        assertEq(token.balanceOf(t.to, t.id), t.mintAmount);
-    }
-
-    function testMintToERC1155Recipient(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        ERC1155Recipient to = new ERC1155Recipient();
-
-        _expectMintEvent(address(to), t.id, t.mintAmount);
-        token.mint(address(to), t.id, t.mintAmount, t.mintData);
-
-        assertEq(token.balanceOf(address(to), t.id), t.mintAmount);
-
-        assertEq(to.operator(), address(this));
-        assertEq(to.from(), address(0));
-        assertEq(to.id(), t.id);
-        assertEq(to.mintData(), t.mintData);
-    }
-
-    function testBatchMintToEOA(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[t.to][id] += mintAmount;
-        }
-
-        _expectMintEvent(t.to, t.ids, t.mintAmounts);
-        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            assertEq(token.balanceOf(t.to, id), userMintAmounts[t.to][id]);
-        }
-    }
-
-    function testBatchMintToERC1155Recipient(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        ERC1155Recipient to = new ERC1155Recipient();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[address(to)][id] += mintAmount;
-        }
-
-        _expectMintEvent(address(to), t.ids, t.mintAmounts);
-        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);
-
-        assertEq(to.batchOperator(), address(this));
-        assertEq(to.batchFrom(), address(0));
-        assertEq(to.batchIds(), t.ids);
-        assertEq(to.batchAmounts(), t.mintAmounts);
-        assertEq(to.batchData(), t.mintData);
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
-        }
-    }
-
-    function testBurn(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        t.burnAmount = _bound(t.burnAmount, 0, t.mintAmount);
-
-        _expectMintEvent(t.to, t.id, t.mintAmount);
-        token.mint(t.to, t.id, t.mintAmount, t.mintData);
-
-        if (_randomChance(2)) {
-            _expectBurnEvent(t.to, t.id, t.burnAmount);
-            token.uncheckedBurn(t.to, t.id, t.burnAmount);
-        } else if (_randomChance(8)) {
-            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);
-            token.burn(t.to, t.id, t.burnAmount);
-            return;
-        } else {
-            vm.prank(t.to);
-            _setApprovalForAll(address(this), true);
-
-            _expectBurnEvent(t.to, t.id, t.burnAmount);
-            token.burn(t.to, t.id, t.burnAmount);
-        }
-
-        assertEq(token.balanceOf(t.to, t.id), t.mintAmount - t.burnAmount);
-    }
-
-    function testBatchBurn(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];
-
-            t.mintAmounts[i] = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            t.burnAmounts[i] = _bound(t.burnAmounts[i], 0, t.mintAmounts[i]);
-
-            userMintAmounts[t.to][id] += t.mintAmounts[i];
-            userTransferOrBurnAmounts[t.to][id] += t.burnAmounts[i];
-        }
-
-        _expectMintEvent(t.to, t.ids, t.mintAmounts);
-        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);
-
-        if (_randomChance(2)) {
-            _expectBurnEvent(t.to, t.ids, t.burnAmounts);
-            token.uncheckedBatchBurn(t.to, t.ids, t.burnAmounts);
-        } else if (_randomChance(8)) {
-            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);
-            token.batchBurn(t.to, t.ids, t.burnAmounts);
-            return;
-        } else {
-            vm.prank(t.to);
-            _setApprovalForAll(address(this), true);
-
-            _expectBurnEvent(t.to, t.ids, t.burnAmounts);
-            token.batchBurn(t.to, t.ids, t.burnAmounts);
-        }
-
-        for (uint256 i = 0; i < t.ids.length; i++) {
-            uint256 id = t.ids[i];
-
-            assertEq(
-                token.balanceOf(t.to, id),
-                userMintAmounts[t.to][id] - userTransferOrBurnAmounts[t.to][id]
-            );
-        }
-    }
-
-    function testApproveAll(address to, bool approved) public {
-        _expectApprovalForAllEvent(to, approved);
-        _setApprovalForAll(to, approved);
-        assertEq(token.isApprovedForAll(address(this), to), approved);
-    }
-
-    function testSafeTransferFromToEOA(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        _expectMintEvent(t.from, t.id, t.mintAmount);
-        token.mint(t.from, t.id, t.mintAmount, t.mintData);
-
-        if (_randomChance(2)) {
-            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);
-            token.uncheckedSafeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);
-        } else if (_randomChance(8)) {
-            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);
-            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);
-            return;
-        } else {
-            vm.prank(t.from);
-            _setApprovalForAll(address(this), true);
-
-            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);
-            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);
-        }
-
-        if (t.to == t.from) {
-            assertEq(token.balanceOf(t.to, t.id), t.mintAmount);
-        } else {
-            assertEq(token.balanceOf(t.to, t.id), t.transferAmount);
-            assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);
-        }
-    }
-
-    function testSafeTransferFromToERC1155Recipient(uint256) public {
-        _TestTemps memory t = _testTemps();
-        ERC1155Recipient to = new ERC1155Recipient();
-
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        _expectMintEvent(t.from, t.id, t.mintAmount);
-        token.mint(t.from, t.id, t.mintAmount, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        _expectTransferEvent(t.from, address(to), t.id, t.transferAmount);
-        _safeTransferFrom(t.from, address(to), t.id, t.transferAmount, t.transferData);
-
-        assertEq(to.operator(), address(this));
-        assertEq(to.from(), t.from);
-        assertEq(to.id(), t.id);
-        assertEq(to.mintData(), t.transferData);
-
-        assertEq(token.balanceOf(address(to), t.id), t.transferAmount);
-        assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);
-    }
-
-    function testSafeTransferFromSelf(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        _expectMintEvent(address(this), t.id, t.mintAmount);
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-
-        _expectTransferEvent(address(this), t.to, t.id, t.transferAmount);
-        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);
-
-        assertEq(token.balanceOf(t.to, t.id), t.transferAmount);
-        assertEq(token.balanceOf(address(this), t.id), t.mintAmount - t.transferAmount);
-    }
-
-    function testSafeBatchTransfer() public {
-        for (uint256 i; i != 8; ++i) {
-            testSafeTransferFromToEOA(_random());
-            testSafeBatchTransferFromToERC1155Recipient(_random());
-        }
-    }
-
-    function testSafeBatchTransferFromToEOA(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-            userTransferOrBurnAmounts[t.from][id] += transferAmount;
-        }
-        _expectMintEvent(t.from, t.ids, t.mintAmounts);
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        if (_randomChance(2)) {
-            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);
-            token.uncheckedSafeBatchTransferFrom(
-                t.from, t.to, t.ids, t.transferAmounts, t.transferData
-            );
-        } else if (_randomChance(8)) {
-            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);
-            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-            return;
-        } else {
-            vm.prank(t.from);
-            _setApprovalForAll(address(this), true);
-
-            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);
-            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-        }
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            assertEq(token.balanceOf(t.to, id), userTransferOrBurnAmounts[t.from][id]);
-            assertEq(
-                token.balanceOf(t.from, id),
-                userMintAmounts[t.from][id] - userTransferOrBurnAmounts[t.from][id]
-            );
-        }
-    }
-
-    function testSafeBatchTransferFromToERC1155Recipient(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        ERC1155Recipient to = new ERC1155Recipient();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-            userTransferOrBurnAmounts[t.from][id] += transferAmount;
-        }
-
-        _expectMintEvent(t.from, t.ids, t.mintAmounts);
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        _expectTransferEvent(t.from, address(to), t.ids, t.transferAmounts);
-        _safeBatchTransferFrom(t.from, address(to), t.ids, t.transferAmounts, t.transferData);
-
-        assertEq(to.batchOperator(), address(this));
-        assertEq(to.batchFrom(), t.from);
-        assertEq(to.batchIds(), t.ids);
-        assertEq(to.batchAmounts(), t.transferAmounts);
-        assertEq(to.batchData(), t.transferData);
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-            uint256 transferAmount = userTransferOrBurnAmounts[t.from][id];
-
-            assertEq(token.balanceOf(address(to), id), transferAmount);
-            assertEq(token.balanceOf(t.from, id), userMintAmounts[t.from][id] - transferAmount);
-        }
-    }
-
-    function testBatchBalanceOf(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        address[] memory tos = new address[](t.n);
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-            address to = _randomNonZeroAddress();
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
-
-            tos[i] = to;
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            token.mint(to, id, mintAmount, t.mintData);
-
-            userMintAmounts[to][id] += mintAmount;
-        }
-
-        uint256[] memory balances = token.balanceOfBatch(tos, t.ids);
-
-        for (uint256 i = 0; i != t.n; i++) {
-            assertEq(balances[i], token.balanceOf(tos[i], t.ids[i]));
-        }
-    }
-
-    function testMintToZeroReverts(uint256) public {
-        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);
-        token.mint(address(0), _random(), _random(), _randomBytes());
-    }
-
-    function testMintToNonERC155RecipientReverts(uint256) public {
-        address to = address(new NonERC1155Recipient());
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        token.mint(to, _random(), _random(), _randomBytes());
-    }
-
-    function testMintToRevertingERC155RecipientReverts(uint256) public {
-        address to = address(new RevertingERC1155Recipient());
-        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector));
-        token.mint(to, _random(), _random(), _randomBytes());
-    }
-
-    function testMintToWrongReturnDataERC155RecipientReverts(uint256) public {
-        address to = address(new WrongReturnDataERC1155Recipient());
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        token.mint(to, _random(), _random(), _randomBytes());
-    }
-
-    function testBurnInsufficientBalanceReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();
-        t.burnAmount = _bound(t.burnAmount, t.mintAmount + 1, type(uint256).max);
-
-        token.mint(t.to, t.id, t.mintAmount, t.mintData);
-
-        vm.prank(t.to);
-        _setApprovalForAll(address(this), true);
-
-        vm.expectRevert(ERC1155.InsufficientBalance.selector);
-        token.burn(t.to, t.id, t.burnAmount);
-    }
-
-    function testSafeTransferFromInsufficientBalanceReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();
-
-        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);
-
-        token.mint(t.from, t.id, t.mintAmount, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        vm.expectRevert(ERC1155.InsufficientBalance.selector);
-        _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeTransferFromSelfInsufficientBalanceReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();
-
-        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);
-
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-
-        vm.expectRevert(ERC1155.InsufficientBalance.selector);
-        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeTransferFromToZeroReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-
-        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);
-        _safeTransferFrom(address(this), address(0), t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeTransferFromToNonERC155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-        t.to = address(new NonERC1155Recipient());
-
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeTransferFromToRevertingERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-        t.to = address(new RevertingERC1155Recipient());
-
-        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector));
-        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);
-
-        token.mint(address(this), t.id, t.mintAmount, t.mintData);
-        t.to = address(new WrongReturnDataERC1155Recipient());
-
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);
-    }
-
-    function testSafeBatchTransferInsufficientBalanceReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        while (t.n == 0) t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            if (mintAmount == type(uint256).max) return;
-            uint256 transferAmount = _bound(t.transferAmounts[i], mintAmount + 1, type(uint256).max);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-        }
-
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        vm.expectRevert(ERC1155.InsufficientBalance.selector);
-        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-    }
-
-    function testSafeBatchTransferFromToZeroReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-        }
-
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);
-        _safeBatchTransferFrom(t.from, address(0), t.ids, t.transferAmounts, t.transferData);
-    }
-
-    function testSafeBatchTransferFromToNonERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-        }
-
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        t.to = address(new NonERC1155Recipient());
-
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-    }
-
-    function testSafeBatchTransferFromToRevertingERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-        }
-
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        t.to = address(new RevertingERC1155Recipient());
-        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector));
-        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-    }
-
-    function testSafeBatchTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);
-
-            t.mintAmounts[i] = mintAmount;
-            t.transferAmounts[i] = transferAmount;
-
-            userMintAmounts[t.from][id] += mintAmount;
-        }
-
-        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.from);
-        _setApprovalForAll(address(this), true);
-
-        t.to = address(new WrongReturnDataERC1155Recipient());
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);
-    }
-
-    function testSafeBatchTransferFromWithArrayLengthMismatchReverts(uint256) public {
-        uint256[] memory ids = new uint256[](_random() % 4);
-        uint256[] memory mintAmounts = new uint256[](_random() % 4);
-
-        if (ids.length == mintAmounts.length) return;
-
-        address from = address(0xABCD);
-
-        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);
-        token.batchMint(from, ids, mintAmounts, _randomBytes());
-
-        uint256[] memory transferAmounts = new uint256[](_random() % 4);
-        if (ids.length == transferAmounts.length) return;
-
-        vm.prank(from);
-        _setApprovalForAll(address(this), true);
-
-        address to = _randomNonZeroAddress();
-
-        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);
-        _safeBatchTransferFrom(from, to, ids, transferAmounts, _randomBytes());
-    }
-
-    function testBatchMintToZeroReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[address(0)][id] += mintAmount;
-        }
-
-        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);
-        token.batchMint(address(0), t.ids, t.mintAmounts, t.mintData);
-    }
-
-    function testBatchMintToNonERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        NonERC1155Recipient to = new NonERC1155Recipient();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[address(to)][id] += mintAmount;
-        }
-
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);
-    }
-
-    function testBatchMintToRevertingERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        RevertingERC1155Recipient to = new RevertingERC1155Recipient();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[address(to)][id] += mintAmount;
-        }
-        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector));
-        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);
-    }
-
-    function testBatchMintToWrongReturnDataERC1155RecipientReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
-
-            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-
-            t.mintAmounts[i] = mintAmount;
-
-            userMintAmounts[address(to)][id] += mintAmount;
-        }
-        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);
-        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);
-    }
-
-    function testBatchMintWithArrayMismatchReverts(uint256) public {
-        uint256[] memory ids = new uint256[](_random() % 4);
-        uint256[] memory amounts = new uint256[](_random() % 4);
-
-        if (ids.length == amounts.length) return;
-
-        address to = _randomNonZeroAddress();
-
-        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);
-        token.batchMint(to, ids, amounts, _randomBytes());
-    }
-
-    function testBatchBurnInsufficientBalanceReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        while (t.n == 0) t = _testTemps();
-
-        for (uint256 i = 0; i != t.n; i++) {
-            uint256 id = t.ids[i];
-
-            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];
-
-            t.mintAmounts[i] = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);
-            if (t.mintAmounts[i] == type(uint256).max) return;
-            t.burnAmounts[i] = _bound(t.burnAmounts[i], t.mintAmounts[i] + 1, type(uint256).max);
-
-            userMintAmounts[t.to][id] += t.mintAmounts[i];
-        }
-
-        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);
-
-        vm.prank(t.to);
-        _setApprovalForAll(address(this), true);
-
-        vm.expectRevert(ERC1155.InsufficientBalance.selector);
-        token.batchBurn(t.to, t.ids, t.burnAmounts);
-    }
-
-    function testBatchBurnWithArrayLengthMismatchReverts(uint256) public {
-        _TestTemps memory t = _testTemps();
-
-        if (t.ids.length == t.burnAmounts.length) t.burnAmounts = _randomArray(t.n + 1);
-
-        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);
-        token.batchBurn(t.to, t.ids, t.burnAmounts);
-    }
-
-    function testBalanceOfBatchWithArrayMismatchReverts(uint256) public {
-        address[] memory tos = new address[](_random() % 4);
-        uint256[] memory ids = new uint256[](_random() % 4);
-        if (tos.length == ids.length) return;
-
-        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);
-        token.balanceOfBatch(tos, ids);
-    }
-}
diff --git a/test/ext/zksync/ERC1967Factory.t.sol b/test/ext/zksync/ERC1967Factory.t.sol
deleted file mode 100644
index 69a9217..0000000
--- a/test/ext/zksync/ERC1967Factory.t.sol
+++ /dev/null
@@ -1,104 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./../../utils/SoladyTest.sol";
-
-import "./../../../src/utils/ext/zksync/ERC1967Factory.sol";
-
-contract SampleImplementation {
-    uint256 public x;
-
-    bytes public constant NAME = "Implementation";
-
-    event Foo();
-
-    error Hehe();
-
-    function foo() public {
-        emit Foo();
-    }
-
-    function setX(uint256 newX) public {
-        x = newX;
-    }
-
-    function hehe() public pure {
-        revert Hehe();
-    }
-
-    function version() public pure virtual returns (uint256) {
-        return 1;
-    }
-}
-
-contract SampleImplementation2 is SampleImplementation {
-    function version() public pure virtual override returns (uint256) {
-        return 2;
-    }
-}
-
-contract ERC1967FactoryTest is SoladyTest {
-    ERC1967Factory public factory;
-    address public implementation;
-    address public implementation2;
-
-    function setUp() public {
-        factory = new ERC1967Factory();
-        implementation = address(new SampleImplementation());
-        implementation2 = address(new SampleImplementation2());
-    }
-
-    function testDeployDeterministicAndUpgrade() public {
-        bytes32 salt = 0x0000000000000000000000000000000000000000ff112233445566778899aabb;
-        address predicted = factory.predictDeterministicAddress(factory.proxyHash(), salt);
-        assertEq(factory.implementationOf(predicted), address(0));
-        address instance = factory.deployProxyDeterministic(implementation, address(this), salt);
-        assertEq(factory.implementationOf(predicted), implementation);
-        assertEq(predicted, instance);
-        SampleImplementation(instance).setX(123);
-        assertEq(SampleImplementation(instance).x(), 123);
-        assertEq(SampleImplementation(instance).version(), 1);
-        assertGt(instance.code.length, 0);
-
-        factory.upgradeAndCall(
-            instance, implementation2, abi.encodeWithSignature("setX(uint256)", uint256(456))
-        );
-        assertEq(SampleImplementation(instance).x(), 456);
-        assertEq(SampleImplementation(instance).version(), 2);
-
-        _checkBehavesLikeProxy(instance);
-    }
-
-    function testDeployBeaconProxyDeterministicAndUpgrade() public {
-        bytes32 salt = 0x0000000000000000000000000000000000000000ff112233445566778899aabb;
-        address predicted = factory.predictDeterministicAddress(factory.beaconHash(), salt);
-        assertEq(factory.implementationOf(predicted), address(0));
-        address beacon = factory.deployBeaconDeterministic(implementation, address(this), salt);
-        assertEq(UpgradeableBeacon(beacon).implementation(), implementation);
-        assertEq(factory.implementationOf(predicted), implementation);
-        assertEq(predicted, beacon);
-
-        predicted = factory.predictDeterministicAddress(factory.beaconProxyHash(), salt);
-        address beaconProxy = factory.deployBeaconProxyDeterministic(beacon, salt);
-        assertEq(predicted, beaconProxy);
-        assertEq(factory.implementationOf(beaconProxy), implementation);
-
-        SampleImplementation(beaconProxy).setX(123);
-        assertEq(SampleImplementation(beaconProxy).x(), 123);
-        assertEq(SampleImplementation(beaconProxy).version(), 1);
-
-        factory.upgrade(beacon, implementation2);
-        assertEq(SampleImplementation(beaconProxy).version(), 2);
-
-        _checkBehavesLikeProxy(beaconProxy);
-    }
-
-    function _checkBehavesLikeProxy(address instance) internal {
-        assertTrue(instance != address(0));
-        uint256 x = _random();
-        SampleImplementation(instance).setX(x);
-        assertEq(x, SampleImplementation(instance).x());
-        vm.expectRevert(SampleImplementation.Hehe.selector);
-        SampleImplementation(instance).hehe();
-    }
-}
diff --git a/test/ext/zksync/ERC721.t.sol b/test/ext/zksync/ERC721.t.sol
deleted file mode 100644
index a713b99..0000000
--- a/test/ext/zksync/ERC721.t.sol
+++ /dev/null
@@ -1,1005 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./../../utils/SoladyTest.sol";
-
-import {ERC721, MockERC721} from "./../../utils/mocks/ext/zksync/MockERC721.sol";
-
-abstract contract ERC721TokenReceiver {
-    function onERC721Received(address, address, uint256, bytes calldata)
-        external
-        virtual
-        returns (bytes4)
-    {
-        return ERC721TokenReceiver.onERC721Received.selector;
-    }
-}
-
-contract ERC721Recipient is ERC721TokenReceiver {
-    address public operator;
-    address public from;
-    uint256 public id;
-    bytes public data;
-
-    function onERC721Received(address _operator, address _from, uint256 _id, bytes calldata _data)
-        public
-        virtual
-        override
-        returns (bytes4)
-    {
-        operator = _operator;
-        from = _from;
-        id = _id;
-        data = _data;
-
-        return ERC721TokenReceiver.onERC721Received.selector;
-    }
-}
-
-contract RevertingERC721Recipient is ERC721TokenReceiver {
-    function onERC721Received(address, address, uint256, bytes calldata)
-        public
-        virtual
-        override
-        returns (bytes4)
-    {
-        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));
-    }
-}
-
-contract WrongReturnDataERC721Recipient is ERC721TokenReceiver {
-    function onERC721Received(address, address, uint256, bytes calldata)
-        public
-        virtual
-        override
-        returns (bytes4)
-    {
-        return 0xCAFEBEEF;
-    }
-}
-
-contract NonERC721Recipient {}
-
-contract MockERC721WithHooks is MockERC721 {
-    uint256 public beforeCounter;
-    uint256 public afterCounter;
-
-    function _beforeTokenTransfer(address, address, uint256) internal virtual override {
-        beforeCounter++;
-    }
-
-    function _afterTokenTransfer(address, address, uint256) internal virtual override {
-        afterCounter++;
-    }
-}
-
-contract ERC721HooksTest is SoladyTest, ERC721TokenReceiver {
-    uint256 public expectedBeforeCounter;
-    uint256 public expectedAfterCounter;
-    uint256 public ticker;
-
-    function _checkCounters() internal view {
-        require(
-            expectedBeforeCounter == MockERC721WithHooks(msg.sender).beforeCounter(),
-            "Before counter mismatch."
-        );
-        require(
-            expectedAfterCounter == MockERC721WithHooks(msg.sender).afterCounter(),
-            "After counter mismatch."
-        );
-    }
-
-    function onERC721Received(address, address, uint256, bytes calldata)
-        external
-        virtual
-        override
-        returns (bytes4)
-    {
-        _checkCounters();
-        return ERC721TokenReceiver.onERC721Received.selector;
-    }
-
-    function _testHooks(MockERC721WithHooks token) internal {
-        address from = _randomNonZeroAddress();
-        uint256 tokenId =
-            uint256(keccak256(abi.encode(expectedBeforeCounter, expectedAfterCounter)));
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.mint(address(this), tokenId);
-
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        token.transferFrom(address(this), from, tokenId);
-
-        expectedBeforeCounter++;
-        expectedAfterCounter++;
-        uint256 r = ticker < 4 ? ticker : _random() % 4;
-        vm.prank(from);
-        if (r == 0) {
-            token.safeTransferFrom(from, address(this), tokenId);
-        } else if (r == 1) {
-            token.safeTransferFrom(from, address(this), tokenId, "");
-        } else if (r == 2) {
-            token.directSafeTransferFrom(from, address(this), tokenId);
-        } else if (r == 3) {
-            token.directSafeTransferFrom(from, address(this), tokenId, "");
-        } else {
-            revert();
-        }
-    }
-
-    function testERC721Hooks() public {
-        MockERC721WithHooks token = new MockERC721WithHooks();
-
-        for (uint256 i; i < 32; ++i) {
-            _testHooks(token);
-        }
-    }
-}
-
-contract ERC721Test is SoladyTest {
-    MockERC721 token;
-
-    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;
-
-    event Transfer(address indexed from, address indexed to, uint256 indexed id);
-
-    event Approval(address indexed owner, address indexed approved, uint256 indexed id);
-
-    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
-
-    function setUp() public {
-        token = new MockERC721();
-    }
-
-    function _expectMintEvent(address to, uint256 id) internal {
-        _expectTransferEvent(address(0), to, id);
-    }
-
-    function _expectBurnEvent(address from, uint256 id) internal {
-        _expectTransferEvent(from, address(0), id);
-    }
-
-    function _expectTransferEvent(address from, address to, uint256 id) internal {
-        vm.expectEmit(true, true, true, true);
-        emit Transfer(_cleaned(from), _cleaned(to), id);
-    }
-
-    function _expectApprovalEvent(address owner, address approved, uint256 id) internal {
-        vm.expectEmit(true, true, true, true);
-        emit Approval(_cleaned(owner), _cleaned(approved), id);
-    }
-
-    function _expectApprovalForAllEvent(address owner, address operator, bool approved) internal {
-        vm.expectEmit(true, true, true, true);
-        emit ApprovalForAll(_cleaned(owner), _cleaned(operator), approved);
-    }
-
-    function _aux(address owner) internal pure returns (uint224 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, owner)
-            result := shr(32, shl(32, keccak256(0x0c, 0x14)))
-        }
-    }
-
-    function _extraData(uint256 id) internal pure returns (uint96 result) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id)
-            result := shr(160, shl(160, keccak256(0x00, 0x20)))
-        }
-    }
-
-    function _transferFrom(address from, address to, uint256 id) internal {
-        if (_randomChance(2)) {
-            token.transferFrom(from, to, id);
-        } else {
-            token.directTransferFrom(from, to, id);
-        }
-    }
-
-    function _safeTransferFrom(address from, address to, uint256 id) internal {
-        if (_randomChance(2)) {
-            token.safeTransferFrom(from, to, id);
-        } else {
-            token.directSafeTransferFrom(from, to, id);
-        }
-    }
-
-    function _safeTransferFrom(address from, address to, uint256 id, bytes memory data) internal {
-        if (_randomChance(2)) {
-            token.safeTransferFrom(from, to, id, data);
-        } else {
-            token.directSafeTransferFrom(from, to, id, data);
-        }
-    }
-
-    function _approve(address spender, uint256 id) internal {
-        if (_randomChance(2)) {
-            token.approve(spender, id);
-        } else {
-            token.directApprove(spender, id);
-        }
-    }
-
-    function _setApprovalForAll(address operator, bool approved) internal {
-        if (_randomChance(2)) {
-            token.setApprovalForAll(operator, approved);
-        } else {
-            token.directSetApprovalForAll(operator, approved);
-        }
-    }
-
-    function _ownerOf(uint256 id) internal returns (address) {
-        if (_randomChance(2)) {
-            return token.ownerOf(id);
-        } else {
-            return token.directOwnerOf(id);
-        }
-    }
-
-    function _getApproved(uint256 id) internal returns (address) {
-        if (_randomChance(2)) {
-            return token.getApproved(id);
-        } else {
-            return token.directGetApproved(id);
-        }
-    }
-
-    function _owners() internal returns (address a, address b) {
-        a = _randomNonZeroAddress();
-        b = _randomNonZeroAddress();
-        while (a == b) b = _randomNonZeroAddress();
-    }
-
-    function testSafetyOfCustomStorage(uint256 id0, uint256 id1) public {
-        bool safe;
-        while (id0 == id1) id1 = _random();
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x00, id0)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            let slot0 := add(id0, add(id0, keccak256(0x00, 0x20)))
-            let slot2 := add(1, slot0)
-            mstore(0x00, id1)
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            let slot1 := add(id1, add(id1, keccak256(0x00, 0x20)))
-            let slot3 := add(1, slot1)
-            safe := 1
-            if eq(slot0, slot1) { safe := 0 }
-            if eq(slot0, slot2) { safe := 0 }
-            if eq(slot0, slot3) { safe := 0 }
-            if eq(slot1, slot2) { safe := 0 }
-            if eq(slot1, slot3) { safe := 0 }
-            if eq(slot2, slot3) { safe := 0 }
-        }
-        require(safe, "Custom storage not safe");
-    }
-
-    function testAuthorizedEquivalence(address by, bool isOwnerOrOperator, bool isApprovedAccount)
-        public
-    {
-        bool a = true;
-        bool b = true;
-        /// @solidity memory-safe-assembly
-        assembly {
-            if by { if iszero(isOwnerOrOperator) { a := isApprovedAccount } }
-            if iszero(or(iszero(by), isOwnerOrOperator)) { b := isApprovedAccount }
-        }
-        assertEq(a, b);
-    }
-
-    function testCannotExceedMaxBalance() public {
-        bytes32 balanceSlot;
-        (address owner0, address owner1) = _owners();
-
-        /// @solidity memory-safe-assembly
-        assembly {
-            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)
-            mstore(0x00, owner0)
-            balanceSlot := keccak256(0x0c, 0x1c)
-        }
-
-        vm.store(address(token), balanceSlot, bytes32(uint256(0xfffffffe)));
-        token.setAux(owner0, type(uint224).max);
-        assertEq(token.balanceOf(owner0), 0xfffffffe);
-        assertEq(token.getAux(owner0), type(uint224).max);
-        token.mint(owner0, 0);
-        assertEq(token.balanceOf(owner0), 0xffffffff);
-
-        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);
-        token.mint(owner0, 1);
-
-        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);
-        token.mintWithExtraDataUnchecked(owner0, 1, _extraData(1));
-
-        token.uncheckedBurn(0);
-        assertEq(token.balanceOf(owner0), 0xfffffffe);
-
-        token.mint(owner1, 0);
-        vm.prank(owner1);
-        _transferFrom(owner1, owner0, 0);
-
-        token.mint(owner1, 1);
-        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);
-        vm.prank(owner1);
-        _transferFrom(owner1, owner0, 1);
-        assertEq(token.getAux(owner0), type(uint224).max);
-    }
-
-    function testMint(uint256 id) public {
-        address owner = _randomNonZeroAddress();
-
-        _expectMintEvent(owner, id);
-        token.mint(owner, id);
-
-        assertEq(token.balanceOf(owner), 1);
-        assertEq(_ownerOf(id), owner);
-    }
-
-    function testMintAndSetExtraDataUnchecked(uint256 id) public {
-        address owner = _randomNonZeroAddress();
-
-        _expectMintEvent(owner, id);
-        token.mintWithExtraDataUnchecked(owner, id, _extraData(id));
-
-        assertEq(token.balanceOf(owner), 1);
-        assertEq(_ownerOf(id), owner);
-        assertEq(token.getExtraData(id), _extraData(id));
-    }
-
-    function testMintAndSetExtraDataUncheckedWithOverwrite(uint256 id, uint96 random) public {
-        address owner = _randomNonZeroAddress();
-
-        token.setExtraData(id, random);
-        assertEq(token.getExtraData(id), random);
-
-        _expectMintEvent(owner, id);
-        token.mintWithExtraDataUnchecked(owner, id, _extraData(id));
-
-        assertEq(token.getExtraData(id), _extraData(id));
-    }
-
-    function testBurn(uint256 id) public {
-        address owner = _randomNonZeroAddress();
-
-        _expectMintEvent(owner, id);
-        token.mint(owner, id);
-
-        if (_randomChance(2)) {
-            _expectBurnEvent(owner, id);
-            token.uncheckedBurn(id);
-        } else {
-            vm.expectRevert(ERC721.NotOwnerNorApproved.selector);
-            token.burn(id);
-            uint256 r = _random() % 3;
-            if (r == 0) {
-                vm.prank(owner);
-                _transferFrom(owner, address(this), id);
-                _expectBurnEvent(address(this), id);
-                token.burn(id);
-            }
-            if (r == 1) {
-                vm.prank(owner);
-                _setApprovalForAll(address(this), true);
-                _expectBurnEvent(owner, id);
-                token.burn(id);
-            }
-            if (r == 2) {
-                vm.prank(owner);
-                _approve(address(this), id);
-                _expectBurnEvent(owner, id);
-                token.burn(id);
-            }
-        }
-
-        assertEq(token.balanceOf(owner), 0);
-
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _ownerOf(id);
-    }
-
-    function testTransferFrom() public {
-        address owner = _randomNonZeroAddress();
-        token.mint(owner, 0);
-        vm.prank(owner);
-        token.transferFrom(owner, address(this), 0);
-    }
-
-    function testEverything(uint256) public {
-        address[2] memory owners;
-        uint256[][2] memory tokens;
-
-        unchecked {
-            (owners[0], owners[1]) = _owners();
-            for (uint256 j; j != 2; ++j) {
-                tokens[j] = new uint256[](_random() % 3);
-            }
-
-            for (uint256 j; j != 2; ++j) {
-                token.setAux(owners[j], _aux(owners[j]));
-                for (uint256 i; i != tokens[j].length;) {
-                    uint256 id = _random();
-                    if (!token.exists(id)) {
-                        tokens[j][i++] = id;
-                        _expectMintEvent(owners[j], id);
-                        token.mint(owners[j], id);
-                        token.setExtraData(id, _extraData(id));
-                    }
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                assertEq(token.balanceOf(owners[j]), tokens[j].length);
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    vm.prank(owners[j]);
-                    _expectApprovalEvent(owners[j], address(this), tokens[j][i]);
-                    _approve(address(this), tokens[j][i]);
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    assertEq(_getApproved(tokens[j][i]), address(this));
-                    uint256 fromBalanceBefore = token.balanceOf(owners[j]);
-                    uint256 toBalanceBefore = token.balanceOf(owners[j ^ 1]);
-                    _expectTransferEvent(owners[j], owners[j ^ 1], tokens[j][i]);
-                    _transferFrom(owners[j], owners[j ^ 1], tokens[j][i]);
-                    assertEq(token.balanceOf(owners[j]), fromBalanceBefore - 1);
-                    assertEq(token.balanceOf(owners[j ^ 1]), toBalanceBefore + 1);
-                    assertEq(_getApproved(tokens[j][i]), address(0));
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    assertEq(_ownerOf(tokens[j][i]), owners[j ^ 1]);
-                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));
-                }
-            }
-            if (_randomChance(2)) {
-                for (uint256 j; j != 2; ++j) {
-                    for (uint256 i; i != tokens[j].length; ++i) {
-                        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);
-                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);
-                        vm.prank(owners[j ^ 1]);
-                        _expectApprovalEvent(owners[j ^ 1], address(this), tokens[j][i]);
-                        _approve(address(this), tokens[j][i]);
-                        _expectTransferEvent(owners[j ^ 1], owners[j], tokens[j][i]);
-                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);
-                    }
-                }
-            } else {
-                for (uint256 j; j != 2; ++j) {
-                    vm.prank(owners[j ^ 1]);
-                    _expectApprovalForAllEvent(owners[j ^ 1], address(this), true);
-                    token.setApprovalForAll(address(this), true);
-                    for (uint256 i; i != tokens[j].length; ++i) {
-                        _expectTransferEvent(owners[j ^ 1], owners[j], tokens[j][i]);
-                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);
-                    }
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                assertEq(token.getAux(owners[j]), _aux(owners[j]));
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    assertEq(_ownerOf(tokens[j][i]), owners[j]);
-                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    token.uncheckedBurn(tokens[j][i]);
-                }
-            }
-            for (uint256 j; j != 2; ++j) {
-                assertEq(token.balanceOf(owners[j]), 0);
-                for (uint256 i; i != tokens[j].length; ++i) {
-                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));
-                }
-            }
-        }
-    }
-
-    function testIsApprovedOrOwner(uint256 id) public {
-        (address owner0, address owner1) = _owners();
-
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        token.isApprovedOrOwner(owner0, id);
-
-        token.mint(owner0, id);
-        assertEq(token.isApprovedOrOwner(owner0, id), true);
-
-        vm.prank(owner0);
-        _transferFrom(owner0, owner1, id);
-        assertEq(token.isApprovedOrOwner(owner0, id), false);
-
-        vm.prank(owner1);
-        _setApprovalForAll(owner0, true);
-        assertEq(token.isApprovedOrOwner(owner0, id), true);
-
-        vm.prank(owner1);
-        _setApprovalForAll(owner0, false);
-        assertEq(token.isApprovedOrOwner(owner0, id), false);
-
-        vm.prank(owner1);
-        _approve(owner0, id);
-        assertEq(token.isApprovedOrOwner(owner0, id), true);
-    }
-
-    function testExtraData(uint256 id) public {
-        (address owner0, address owner1) = _owners();
-
-        bool setExtraData = _randomChance(2);
-        uint96 extraData = uint96(_bound(_random(), 0, type(uint96).max));
-        if (setExtraData) {
-            token.setExtraData(id, extraData);
-        }
-        _expectMintEvent(owner0, id);
-        token.mint(owner0, id);
-        if (setExtraData) {
-            assertEq(token.getExtraData(id), extraData);
-        } else {
-            assertEq(token.getExtraData(id), 0);
-        }
-
-        vm.prank(owner0);
-        _expectTransferEvent(owner0, owner1, id);
-        _transferFrom(owner0, owner1, id);
-        if (setExtraData) {
-            assertEq(token.getExtraData(id), extraData);
-        } else {
-            assertEq(token.getExtraData(id), 0);
-        }
-        assertEq(_ownerOf(id), owner1);
-
-        if (_randomChance(2)) {
-            extraData = uint96(_bound(_random(), 0, type(uint96).max));
-            token.setExtraData(id, extraData);
-            setExtraData = true;
-        }
-
-        _expectBurnEvent(owner1, id);
-        token.uncheckedBurn(id);
-        if (setExtraData) {
-            assertEq(token.getExtraData(id), extraData);
-        } else {
-            assertEq(token.getExtraData(id), 0);
-        }
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _ownerOf(id);
-    }
-
-    function testExtraData2(uint256 id0, uint256 id1) public {
-        while (id0 == id1) id1 = _random();
-        token.setExtraData(id0, _extraData(id0));
-        token.setExtraData(id1, _extraData(id1));
-        assertEq(token.getExtraData(id0), _extraData(id0));
-        assertEq(token.getExtraData(id1), _extraData(id1));
-    }
-
-    function testAux(uint256) public {
-        (address owner0, address owner1) = _owners();
-
-        bool setAux = _randomChance(2);
-        if (setAux) {
-            token.setAux(owner0, _aux(owner0));
-            token.setAux(owner1, _aux(owner1));
-        }
-
-        for (uint256 i; i < 2; ++i) {
-            _expectMintEvent(owner0, i * 2 + 0);
-            token.mint(owner0, i * 2 + 0);
-            assertEq(token.balanceOf(owner0), i + 1);
-
-            _expectMintEvent(owner1, i * 2 + 1);
-            token.mint(owner1, i * 2 + 1);
-            assertEq(token.balanceOf(owner1), i + 1);
-
-            if (setAux) {
-                assertEq(token.getAux(owner0), _aux(owner0));
-                assertEq(token.getAux(owner1), _aux(owner1));
-            } else {
-                assertEq(token.getAux(owner0), 0);
-                assertEq(token.getAux(owner1), 0);
-            }
-        }
-
-        for (uint256 i; i < 2; ++i) {
-            _expectBurnEvent(owner0, i * 2 + 0);
-            token.uncheckedBurn(i * 2 + 0);
-            assertEq(token.balanceOf(owner0), 1 - i);
-
-            _expectBurnEvent(owner1, i * 2 + 1);
-            token.uncheckedBurn(i * 2 + 1);
-            assertEq(token.balanceOf(owner1), 1 - i);
-
-            if (setAux) {
-                assertEq(token.getAux(owner0), _aux(owner0));
-                assertEq(token.getAux(owner1), _aux(owner1));
-            } else {
-                assertEq(token.getAux(owner0), 0);
-                assertEq(token.getAux(owner1), 0);
-            }
-        }
-    }
-
-    function testApprove(uint256 id) public {
-        (address spender,) = _randomSigner();
-
-        token.mint(address(this), id);
-
-        _expectApprovalEvent(address(this), spender, id);
-        _approve(spender, id);
-        assertEq(_getApproved(id), spender);
-    }
-
-    function testApproveBurn(uint256 id) public {
-        (address spender,) = _randomSigner();
-
-        token.mint(address(this), id);
-
-        _approve(spender, id);
-
-        token.uncheckedBurn(id);
-
-        assertEq(token.balanceOf(address(this)), 0);
-
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _getApproved(id);
-
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _ownerOf(id);
-    }
-
-    function testApproveAll(uint256) public {
-        (address operator,) = _randomSigner();
-        bool approved = _randomChance(2);
-        _expectApprovalForAllEvent(address(this), operator, approved);
-        _setApprovalForAll(operator, approved);
-        assertEq(token.isApprovedForAll(address(this), operator), approved);
-    }
-
-    function testTransferFrom(uint256 id) public {
-        (address from, address to) = _owners();
-
-        token.mint(from, id);
-
-        if (_randomChance(2)) {
-            uint256 r = _random() % 3;
-            if (r == 0) {
-                vm.prank(from);
-                _approve(address(this), id);
-                _expectTransferEvent(from, to, id);
-                _transferFrom(from, to, id);
-            }
-            if (r == 1) {
-                vm.prank(from);
-                _setApprovalForAll(address(this), true);
-                _expectTransferEvent(from, to, id);
-                _transferFrom(from, to, id);
-            }
-            if (r == 2) {
-                vm.prank(from);
-                _expectTransferEvent(from, address(this), id);
-                _transferFrom(from, address(this), id);
-                _expectTransferEvent(address(this), to, id);
-                _transferFrom(address(this), to, id);
-            }
-        } else {
-            (address temp,) = _randomSigner();
-            while (temp == from || temp == to) (temp,) = _randomSigner();
-            if (_randomChance(2)) {
-                _expectTransferEvent(from, temp, id);
-                token.uncheckedTransferFrom(from, temp, id);
-            } else {
-                vm.prank(from);
-                _expectTransferEvent(from, temp, id);
-                _transferFrom(from, temp, id);
-            }
-            _expectTransferEvent(temp, to, id);
-            token.uncheckedTransferFrom(temp, to, id);
-        }
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), to);
-        assertEq(token.balanceOf(to), 1);
-        assertEq(token.balanceOf(from), 0);
-    }
-
-    function testTransferFromSelf(uint256 id) public {
-        (address to,) = _randomSigner();
-
-        token.mint(address(this), id);
-
-        _transferFrom(address(this), to, id);
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), to);
-        assertEq(token.balanceOf(to), 1);
-        assertEq(token.balanceOf(address(this)), 0);
-    }
-
-    function testTransferFromApproveAll(uint256 id) public {
-        (address from, address to) = _owners();
-
-        token.mint(from, id);
-
-        vm.prank(from);
-        _setApprovalForAll(address(this), true);
-
-        _transferFrom(from, to, id);
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), to);
-        assertEq(token.balanceOf(to), 1);
-        assertEq(token.balanceOf(from), 0);
-    }
-
-    function testSafeTransferFromToEOA(uint256 id) public {
-        (address from, address to) = _owners();
-
-        token.mint(from, id);
-
-        vm.prank(from);
-        _setApprovalForAll(address(this), true);
-
-        _safeTransferFrom(from, to, id);
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), to);
-        assertEq(token.balanceOf(to), 1);
-        assertEq(token.balanceOf(from), 0);
-    }
-
-    function testSafeTransferFromToERC721Recipient(uint256 id) public {
-        (address from,) = _randomSigner();
-
-        ERC721Recipient recipient = new ERC721Recipient();
-
-        token.mint(from, id);
-
-        vm.prank(from);
-        _setApprovalForAll(address(this), true);
-
-        _safeTransferFrom(from, address(recipient), id);
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), address(recipient));
-        assertEq(token.balanceOf(address(recipient)), 1);
-        assertEq(token.balanceOf(from), 0);
-
-        assertEq(recipient.operator(), address(this));
-        assertEq(recipient.from(), from);
-        assertEq(recipient.id(), id);
-        assertEq(recipient.data(), "");
-    }
-
-    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes memory data) public {
-        (address from,) = _randomSigner();
-
-        ERC721Recipient recipient = new ERC721Recipient();
-
-        token.mint(from, id);
-
-        vm.prank(from);
-        _setApprovalForAll(address(this), true);
-
-        _safeTransferFrom(from, address(recipient), id, data);
-
-        assertEq(recipient.data(), data);
-        assertEq(recipient.id(), id);
-        assertEq(recipient.operator(), address(this));
-        assertEq(recipient.from(), from);
-
-        assertEq(_getApproved(id), address(0));
-        assertEq(_ownerOf(id), address(recipient));
-        assertEq(token.balanceOf(address(recipient)), 1);
-        assertEq(token.balanceOf(from), 0);
-    }
-
-    function testSafeMintToEOA(uint256 id) public {
-        (address to,) = _randomSigner();
-
-        token.safeMint(to, id);
-
-        assertEq(_ownerOf(id), address(to));
-        assertEq(token.balanceOf(address(to)), 1);
-    }
-
-    function testSafeMintToERC721Recipient(uint256 id) public {
-        ERC721Recipient to = new ERC721Recipient();
-
-        token.safeMint(address(to), id);
-
-        assertEq(_ownerOf(id), address(to));
-        assertEq(token.balanceOf(address(to)), 1);
-
-        assertEq(to.operator(), address(this));
-        assertEq(to.from(), address(0));
-        assertEq(to.id(), id);
-        assertEq(to.data(), "");
-    }
-
-    function testSafeMintToERC721RecipientWithData(uint256 id, bytes memory data) public {
-        ERC721Recipient to = new ERC721Recipient();
-
-        token.safeMint(address(to), id, data);
-
-        assertEq(_ownerOf(id), address(to));
-        assertEq(token.balanceOf(address(to)), 1);
-
-        assertEq(to.operator(), address(this));
-        assertEq(to.from(), address(0));
-        assertEq(to.id(), id);
-        assertEq(to.data(), data);
-    }
-
-    function testMintToZeroReverts(uint256 id) public {
-        vm.expectRevert(ERC721.TransferToZeroAddress.selector);
-        token.mint(address(0), id);
-
-        vm.expectRevert(ERC721.TransferToZeroAddress.selector);
-        token.mintWithExtraDataUnchecked(address(0), id, _extraData(id));
-    }
-
-    function testDoubleMintReverts(uint256 id) public {
-        (address to,) = _randomSigner();
-
-        token.mint(to, id);
-        vm.expectRevert(ERC721.TokenAlreadyExists.selector);
-        token.mint(to, id);
-    }
-
-    function testBurnNonExistentReverts(uint256 id) public {
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        token.uncheckedBurn(id);
-    }
-
-    function testDoubleBurnReverts(uint256 id) public {
-        (address to,) = _randomSigner();
-
-        token.mint(to, id);
-
-        token.uncheckedBurn(id);
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        token.uncheckedBurn(id);
-    }
-
-    function testApproveNonExistentReverts(uint256 id, address to) public {
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _approve(to, id);
-    }
-
-    function testApproveUnauthorizedReverts(uint256 id) public {
-        (address owner, address to) = _owners();
-
-        token.mint(owner, id);
-        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);
-        _approve(to, id);
-    }
-
-    function testTransferFromNotExistentReverts(address from, address to, uint256 id) public {
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _transferFrom(from, to, id);
-    }
-
-    function testTransferFromWrongFromReverts(address to, uint256 id) public {
-        (address owner, address from) = _owners();
-
-        token.mint(owner, id);
-        vm.expectRevert(ERC721.TransferFromIncorrectOwner.selector);
-        _transferFrom(from, to, id);
-    }
-
-    function testTransferFromToZeroReverts(uint256 id) public {
-        token.mint(address(this), id);
-
-        vm.expectRevert(ERC721.TransferToZeroAddress.selector);
-        _transferFrom(address(this), address(0), id);
-    }
-
-    function testTransferFromNotOwner(uint256 id) public {
-        (address from, address to) = _owners();
-
-        token.mint(from, id);
-
-        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);
-        _transferFrom(from, to, id);
-    }
-
-    function testSafeTransferFromToNonERC721RecipientReverts(uint256 id) public {
-        token.mint(address(this), id);
-        address to = address(new NonERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), address(to), id);
-    }
-
-    function testSafeTransferFromToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)
-        public
-    {
-        token.mint(address(this), id);
-        address to = address(new NonERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), to, id, data);
-    }
-
-    function testSafeTransferFromToRevertingERC721RecipientReverts(uint256 id) public {
-        token.mint(address(this), id);
-        address to = address(new RevertingERC721Recipient());
-        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));
-        _safeTransferFrom(address(this), to, id);
-    }
-
-    function testSafeTransferFromToRevertingERC721RecipientWithDataReverts(
-        uint256 id,
-        bytes memory data
-    ) public {
-        token.mint(address(this), id);
-        address to = address(new RevertingERC721Recipient());
-        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));
-        _safeTransferFrom(address(this), to, id, data);
-    }
-
-    function testSafeTransferFromToERC721RecipientWithWrongReturnDataReverts(uint256 id) public {
-        token.mint(address(this), id);
-        address to = address(new WrongReturnDataERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), to, id);
-    }
-
-    function testSafeTransferFromToERC721RecipientWithWrongReturnDataWithDataReverts(
-        uint256 id,
-        bytes memory data
-    ) public {
-        token.mint(address(this), id);
-        address to = address(new WrongReturnDataERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        _safeTransferFrom(address(this), to, id, data);
-    }
-
-    function testSafeMintToNonERC721RecipientReverts(uint256 id) public {
-        address to = address(new NonERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        token.safeMint(to, id);
-    }
-
-    function testSafeMintToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)
-        public
-    {
-        address to = address(new NonERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        token.safeMint(to, id, data);
-    }
-
-    function testSafeMintToRevertingERC721RecipientReverts(uint256 id) public {
-        address to = address(new RevertingERC721Recipient());
-        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));
-        token.safeMint(to, id);
-    }
-
-    function testSafeMintToRevertingERC721RecipientWithDataReverts(uint256 id, bytes memory data)
-        public
-    {
-        address to = address(new RevertingERC721Recipient());
-        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));
-        token.safeMint(to, id, data);
-    }
-
-    function testSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {
-        address to = address(new WrongReturnDataERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        token.safeMint(to, id);
-    }
-
-    function testSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes memory data)
-        public
-    {
-        address to = address(new WrongReturnDataERC721Recipient());
-        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);
-        token.safeMint(to, id, data);
-    }
-
-    function testOwnerOfNonExistent(uint256 id) public {
-        vm.expectRevert(ERC721.TokenDoesNotExist.selector);
-        _ownerOf(id);
-    }
-}
diff --git a/test/ext/zksync/SafeTransferLib.t.sol b/test/ext/zksync/SafeTransferLib.t.sol
deleted file mode 100644
index 7f9e80b..0000000
--- a/test/ext/zksync/SafeTransferLib.t.sol
+++ /dev/null
@@ -1,799 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import {MockERC20} from "./../../utils/mocks/MockERC20.sol";
-import {MockERC20LikeUSDT} from "./../../utils/mocks/MockERC20LikeUSDT.sol";
-import {MockETHRecipient} from "./../../utils/mocks/MockETHRecipient.sol";
-import {RevertingToken} from "./../../utils/weird-tokens/RevertingToken.sol";
-import {ReturnsTwoToken} from "./../../utils/weird-tokens/ReturnsTwoToken.sol";
-import {ReturnsFalseToken} from "./../../utils/weird-tokens/ReturnsFalseToken.sol";
-import {MissingReturnToken} from "./../../utils/weird-tokens/MissingReturnToken.sol";
-import {ReturnsTooMuchToken} from "./../../utils/weird-tokens/ReturnsTooMuchToken.sol";
-import {ReturnsRawBytesToken} from "./../../utils/weird-tokens/ReturnsRawBytesToken.sol";
-import {ReturnsTooLittleToken} from "./../../utils/weird-tokens/ReturnsTooLittleToken.sol";
-
-import "./../../utils/SoladyTest.sol";
-
-import {ERC20} from "../../../src/tokens/ERC20.sol";
-import {SafeTransferLib} from "../../../src/utils/ext/zksync/SafeTransferLib.sol";
-
-contract Griefer {
-    uint256 public receiveNumLoops;
-
-    uint256[] internal _junk;
-
-    event Junk(uint256 indexed i);
-
-    function setReceiveNumLoops(uint256 amount) public {
-        receiveNumLoops = amount;
-    }
-
-    function execute(address to, bytes memory data) public {
-        (bool success,) = to.call(data);
-        require(success);
-    }
-
-    function doStuff() public payable {
-        unchecked {
-            uint256 n = receiveNumLoops;
-            if (n > 0xffffffff) revert();
-            for (uint256 i; i < n; ++i) {
-                _junk.push(i);
-            }
-        }
-    }
-
-    receive() external payable {
-        doStuff();
-    }
-
-    fallback() external payable {
-        doStuff();
-    }
-}
-
-contract SafeTransferLibTest is SoladyTest {
-    uint256 internal constant _SUCCESS = 1;
-    uint256 internal constant _REVERTS_WITH_SELECTOR = 2;
-    uint256 internal constant _REVERTS_WITH_ANY = 3;
-
-    address internal constant _REGULAR_EVM_PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;
-
-    RevertingToken reverting;
-    ReturnsTwoToken returnsTwo;
-    ReturnsFalseToken returnsFalse;
-    MissingReturnToken missingReturn;
-    ReturnsTooMuchToken returnsTooMuch;
-    ReturnsRawBytesToken returnsRawBytes;
-    ReturnsTooLittleToken returnsTooLittle;
-
-    MockERC20 erc20;
-
-    Griefer griefer;
-
-    function setUp() public {
-        vm.chainId(1);
-        reverting = new RevertingToken();
-        returnsTwo = new ReturnsTwoToken();
-        returnsFalse = new ReturnsFalseToken();
-        missingReturn = new MissingReturnToken();
-        returnsTooMuch = new ReturnsTooMuchToken();
-        returnsRawBytes = new ReturnsRawBytesToken();
-        returnsTooLittle = new ReturnsTooLittleToken();
-
-        erc20 = new MockERC20("StandardToken", "ST", 18);
-        erc20.mint(address(this), type(uint256).max);
-
-        griefer = new Griefer();
-    }
-
-    function testTransferWithMissingReturn() public {
-        verifySafeTransfer(address(missingReturn), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testTransferWithStandardERC20() public {
-        verifySafeTransfer(address(erc20), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testTransferWithReturnsTooMuch() public {
-        verifySafeTransfer(address(returnsTooMuch), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testTransferWithNonContractReverts() public {
-        vm.expectRevert(SafeTransferLib.TransferFailed.selector);
-        this.safeTransfer(address(0xBADBEEF), address(0xBEEF), 1e18);
-    }
-
-    function testTransferFromWithMissingReturn() public {
-        verifySafeTransferFrom(
-            address(missingReturn), address(0xFEED), address(0xBEEF), 1e18, _SUCCESS
-        );
-    }
-
-    function testTransferFromWithStandardERC20() public {
-        verifySafeTransferFrom(address(erc20), address(0xFEED), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testTransferFromWithReturnsTooMuch() public {
-        verifySafeTransferFrom(
-            address(returnsTooMuch), address(0xFEED), address(0xBEEF), 1e18, _SUCCESS
-        );
-    }
-
-    function testTransferFromWithNonContractReverts() public {
-        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);
-        this.safeTransferFrom(address(0xBADBEEF), address(0xFEED), address(0xBEEF), 1e18);
-    }
-
-    function safeTransferFrom(address token, address from, address to, uint256 amount) public {
-        SafeTransferLib.safeTransferFrom(
-            _brutalized(token), _brutalized(from), _brutalized(to), amount
-        );
-    }
-
-    function testApproveWithMissingReturn() public {
-        verifySafeApprove(address(missingReturn), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testApproveWithStandardERC20() public {
-        verifySafeApprove(address(erc20), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testApproveWithReturnsTooMuch() public {
-        verifySafeApprove(address(returnsTooMuch), address(0xBEEF), 1e18, _SUCCESS);
-    }
-
-    function testApproveWithNonContractReverts() public {
-        vm.expectRevert(SafeTransferLib.ApproveFailed.selector);
-        this.safeApprove(address(0xBADBEEF), address(0xBEEF), 1e18);
-    }
-
-    function safeApprove(address token, address to, uint256 amount) public {
-        SafeTransferLib.safeApprove(token, to, amount);
-    }
-
-    function testApproveWithRetryWithNonContractReverts() public {
-        vm.expectRevert(SafeTransferLib.ApproveFailed.selector);
-        this.safeApproveWithRetry(address(0xBADBEEF), address(0xBEEF), 1e18);
-    }
-
-    function safeApproveWithRetry(address token, address to, uint256 amount) public {
-        SafeTransferLib.safeApproveWithRetry(token, to, amount);
-    }
-
-    function testTransferETH() public {
-        SafeTransferLib.safeTransferETH(address(0xBEEF), 1e18);
-    }
-
-    function testTransferAllETH() public {
-        SafeTransferLib.safeTransferAllETH(address(0xBEEF));
-    }
-
-    function testTryTransferETH() public {
-        MockETHRecipient recipient = new MockETHRecipient(false, false);
-        bool success = SafeTransferLib.trySafeTransferETH(address(recipient), 1e18, gasleft());
-        assertTrue(success);
-    }
-
-    function testTryTransferAllETH() public {
-        MockETHRecipient recipient = new MockETHRecipient(false, false);
-        bool success = SafeTransferLib.trySafeTransferAllETH(address(recipient), gasleft());
-        assertTrue(success);
-    }
-
-    function testTransferWithReturnsFalseReverts() public {
-        verifySafeTransfer(address(returnsFalse), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithRevertingReverts() public {
-        verifySafeTransfer(address(reverting), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithReturnsTooLittleReverts() public {
-        verifySafeTransfer(address(returnsTooLittle), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferFromWithReturnsFalseReverts() public {
-        verifySafeTransferFrom(
-            address(returnsFalse), address(0xFEED), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR
-        );
-    }
-
-    function testTransferFromWithRevertingReverts() public {
-        verifySafeTransferFrom(
-            address(reverting), address(0xFEED), address(0xBEEF), 1e18, _REVERTS_WITH_ANY
-        );
-    }
-
-    function testTransferFromWithReturnsTooLittleReverts() public {
-        verifySafeTransferFrom(
-            address(returnsTooLittle),
-            address(0xFEED),
-            address(0xBEEF),
-            1e18,
-            _REVERTS_WITH_SELECTOR
-        );
-    }
-
-    function testApproveWithReturnsFalseReverts() public {
-        verifySafeApprove(address(returnsFalse), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithRevertingReverts() public {
-        verifySafeApprove(address(reverting), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithReturnsTooLittleReverts() public {
-        verifySafeApprove(address(returnsTooLittle), address(0xBEEF), 1e18, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testBalanceOfStandardERC20() public view {
-        erc20.balanceOf(address(this));
-    }
-
-    function testBalanceOfStandardERC20(address to, uint256 amount) public {
-        uint256 originalBalance = erc20.balanceOf(address(this));
-        while (originalBalance < amount) amount = _random();
-        while (to == address(this)) to = _randomHashedAddress();
-
-        SafeTransferLib.safeTransfer(address(erc20), _brutalized(to), originalBalance - amount);
-        assertEq(SafeTransferLib.balanceOf(address(erc20), _brutalized(address(this))), amount);
-    }
-
-    function testTransferAllWithStandardERC20() public {
-        SafeTransferLib.safeTransferAll(address(erc20), address(1));
-    }
-
-    function testTransferAllWithStandardERC20(address to, uint256 amount) public {
-        uint256 originalBalance = erc20.balanceOf(address(this));
-        while (originalBalance < amount) amount = _random();
-        while (to == address(this)) to = _randomHashedAddress();
-
-        SafeTransferLib.safeTransfer(address(erc20), _brutalized(to), originalBalance - amount);
-        assertEq(erc20.balanceOf(address(this)), amount);
-
-        assertEq(SafeTransferLib.safeTransferAll(address(erc20), _brutalized(to)), amount);
-
-        assertEq(erc20.balanceOf(address(this)), 0);
-        assertEq(erc20.balanceOf(to), originalBalance);
-    }
-
-    function testTrySafeTransferFrom(address from, address to, uint256 amount) public {
-        uint256 balance = _random();
-        while (from == address(this) || to == address(this) || from == to) {
-            from = _randomNonZeroAddress();
-            to = _randomNonZeroAddress();
-        }
-        erc20.transfer(from, balance);
-        vm.prank(from);
-        erc20.approve(address(this), type(uint256).max);
-        bool result = SafeTransferLib.trySafeTransferFrom(address(erc20), from, to, amount);
-        assertEq(result, amount <= balance);
-    }
-
-    function testTransferAllFromWithStandardERC20() public {
-        forceApprove(address(erc20), address(this), address(this), type(uint256).max);
-        SafeTransferLib.safeTransferAllFrom(address(erc20), address(this), address(1));
-    }
-
-    function testTransferAllFromWithStandardERC20(address from, address to, uint256 amount)
-        public
-    {
-        while (!(to != from && to != address(this) && from != address(this))) {
-            to = _randomNonZeroAddress();
-            from = _randomNonZeroAddress();
-        }
-
-        SafeTransferLib.safeTransferAll(address(erc20), _brutalized(from));
-
-        uint256 originalBalance = erc20.balanceOf(from);
-        while (originalBalance < amount) amount = _random();
-
-        forceApprove(address(erc20), from, address(this), type(uint256).max);
-
-        SafeTransferLib.safeTransferFrom(
-            address(erc20), _brutalized(from), _brutalized(to), originalBalance - amount
-        );
-        assertEq(erc20.balanceOf(from), amount);
-
-        assertEq(
-            SafeTransferLib.safeTransferAllFrom(address(erc20), _brutalized(from), _brutalized(to)),
-            amount
-        );
-
-        assertEq(erc20.balanceOf(address(this)), 0);
-        assertEq(erc20.balanceOf(to), originalBalance);
-    }
-
-    function testTransferWithMissingReturn(address to, uint256 amount) public {
-        verifySafeTransfer(address(missingReturn), to, amount, _SUCCESS);
-    }
-
-    function testTransferWithStandardERC20(address to, uint256 amount) public {
-        verifySafeTransfer(address(erc20), to, amount, _SUCCESS);
-    }
-
-    function testTransferWithReturnsTooMuch(address to, uint256 amount) public {
-        verifySafeTransfer(address(returnsTooMuch), to, amount, _SUCCESS);
-    }
-
-    function testTransferWithNonGarbage(address to, uint256 amount) public {
-        returnsRawBytes.setRawBytes(_generateNonGarbage());
-
-        verifySafeTransfer(address(returnsRawBytes), to, amount, _SUCCESS);
-    }
-
-    function testTransferWithNonContractReverts(bytes32, address to, uint256 amount) public {
-        vm.expectRevert(SafeTransferLib.TransferFailed.selector);
-        this.safeTransfer(_randomHashedAddress(), to, amount);
-    }
-
-    function safeTransfer(address token, address to, uint256 amount) public {
-        SafeTransferLib.safeTransfer(token, to, amount);
-    }
-
-    function testTransferETHToContractWithoutFallbackReverts() public {
-        vm.expectRevert(SafeTransferLib.ETHTransferFailed.selector);
-        this.safeTransferETH(address(this), 1e18);
-    }
-
-    function testTransferAllETHToContractWithoutFallbackReverts() public {
-        vm.expectRevert(SafeTransferLib.ETHTransferFailed.selector);
-        this.safeTransferAllETH(address(this));
-    }
-
-    function testTransferFromWithMissingReturn(address from, address to, uint256 amount) public {
-        verifySafeTransferFrom(address(missingReturn), from, to, amount, _SUCCESS);
-    }
-
-    function testTransferFromWithStandardERC20(address from, address to, uint256 amount) public {
-        verifySafeTransferFrom(address(erc20), from, to, amount, _SUCCESS);
-    }
-
-    function testTransferFromWithReturnsTooMuch(address from, address to, uint256 amount) public {
-        verifySafeTransferFrom(address(returnsTooMuch), from, to, amount, _SUCCESS);
-    }
-
-    function testTransferFromWithNonGarbage(address from, address to, uint256 amount) public {
-        returnsRawBytes.setRawBytes(_generateNonGarbage());
-
-        verifySafeTransferFrom(address(returnsRawBytes), from, to, amount, _SUCCESS);
-    }
-
-    function testTransferFromWithNonContractReverts(
-        address nonContract,
-        address from,
-        address to,
-        uint256 amount
-    ) public {
-        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) {
-            return;
-        }
-        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);
-        this.safeTransferFrom(nonContract, from, to, amount);
-    }
-
-    function testApproveWithMissingReturn(address to, uint256 amount) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        verifySafeApprove(address(missingReturn), to, amount, _SUCCESS);
-    }
-
-    function testApproveWithStandardERC20(address to, uint256 amount) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        verifySafeApprove(address(erc20), to, amount, _SUCCESS);
-    }
-
-    function testApproveWithReturnsTooMuch(address to, uint256 amount) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        verifySafeApprove(address(returnsTooMuch), to, amount, _SUCCESS);
-    }
-
-    function testApproveWithNonGarbage(address to, uint256 amount) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        returnsRawBytes.setRawBytes(_generateNonGarbage());
-
-        verifySafeApprove(address(returnsRawBytes), to, amount, _SUCCESS);
-    }
-
-    function testApproveWithNonContractReverts(address nonContract, address to, uint256 amount)
-        public
-    {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) {
-            return;
-        }
-        vm.expectRevert(SafeTransferLib.ApproveFailed.selector);
-        this.safeApprove(nonContract, to, amount);
-    }
-
-    function testApproveWithRetryWithNonContractReverts(
-        address nonContract,
-        address to,
-        uint256 amount
-    ) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) {
-            return;
-        }
-        vm.expectRevert(SafeTransferLib.ApproveFailed.selector);
-        this.safeApproveWithRetry(nonContract, to, amount);
-    }
-
-    function testApproveWithRetry(address to, uint256 amount0, uint256 amount1) public {
-        if (to == _REGULAR_EVM_PERMIT2) return;
-        MockERC20LikeUSDT usdt = new MockERC20LikeUSDT();
-        assertEq(usdt.allowance(address(this), to), 0);
-        SafeTransferLib.safeApproveWithRetry(address(usdt), _brutalized(to), amount0);
-        assertEq(usdt.allowance(address(this), to), amount0);
-        if (amount0 != 0 && amount1 != 0) {
-            verifySafeApprove(address(usdt), to, amount1, _REVERTS_WITH_SELECTOR);
-        }
-        SafeTransferLib.safeApproveWithRetry(address(usdt), _brutalized(to), amount1);
-        assertEq(usdt.allowance(address(this), to), amount1);
-    }
-
-    function testApproveWithRetry() public {
-        testApproveWithRetry(address(1), 123, 456);
-    }
-
-    function testTransferETH(bytes32, uint256 amount) public {
-        amount = _bound(amount, 0, address(this).balance);
-        SafeTransferLib.safeTransferETH(_randomHashedAddress(), amount);
-    }
-
-    function testTransferAllETH(bytes32) public {
-        SafeTransferLib.safeTransferAllETH(_randomHashedAddress());
-    }
-
-    function testTransferWithReturnsFalseReverts(address to, uint256 amount) public {
-        verifySafeTransfer(address(returnsFalse), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithRevertingReverts(address to, uint256 amount) public {
-        verifySafeTransfer(address(reverting), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithReturnsTooLittleReverts(address to, uint256 amount) public {
-        verifySafeTransfer(address(returnsTooLittle), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithReturnsTwoReverts(address to, uint256 amount) public {
-        verifySafeTransfer(address(returnsTwo), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferWithGarbageReverts(address to, uint256 amount) public {
-        returnsRawBytes.setRawBytes(_generateGarbage());
-
-        verifySafeTransfer(address(returnsRawBytes), to, amount, _REVERTS_WITH_ANY);
-    }
-
-    function testTransferFromWithReturnsFalseReverts(address from, address to, uint256 amount)
-        public
-    {
-        verifySafeTransferFrom(address(returnsFalse), from, to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferFromWithRevertingReverts(address from, address to, uint256 amount)
-        public
-    {
-        verifySafeTransferFrom(address(reverting), from, to, amount, _REVERTS_WITH_ANY);
-    }
-
-    function testTransferFromWithReturnsTooLittleReverts(address from, address to, uint256 amount)
-        public
-    {
-        verifySafeTransferFrom(address(returnsTooLittle), from, to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferFromWithReturnsTwoReverts(address from, address to, uint256 amount)
-        public
-    {
-        verifySafeTransferFrom(address(returnsTwo), from, to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testTransferFromWithGarbageReverts(address from, address to, uint256 amount) public {
-        returnsRawBytes.setRawBytes(_generateGarbage());
-
-        verifySafeTransferFrom(address(returnsRawBytes), from, to, amount, _REVERTS_WITH_ANY);
-    }
-
-    function testApproveWithReturnsFalseReverts(address to, uint256 amount) public {
-        verifySafeApprove(address(returnsFalse), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithRevertingReverts(address to, uint256 amount) public {
-        verifySafeApprove(address(reverting), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithReturnsTooLittleReverts(address to, uint256 amount) public {
-        verifySafeApprove(address(returnsTooLittle), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithReturnsTwoReverts(address to, uint256 amount) public {
-        verifySafeApprove(address(returnsTwo), to, amount, _REVERTS_WITH_SELECTOR);
-    }
-
-    function testApproveWithGarbageReverts(address to, uint256 amount) public {
-        returnsRawBytes.setRawBytes(_generateGarbage());
-
-        verifySafeApprove(address(returnsRawBytes), to, amount, _REVERTS_WITH_ANY);
-    }
-
-    function testTransferETHToContractWithoutFallbackReverts(uint256 amount) public {
-        vm.expectRevert(SafeTransferLib.ETHTransferFailed.selector);
-        this.safeTransferETH(address(this), amount);
-    }
-
-    function testTransferAllETHToContractWithoutFallbackReverts(uint256) public {
-        vm.expectRevert(SafeTransferLib.ETHTransferFailed.selector);
-        this.safeTransferAllETH(address(this));
-    }
-
-    function verifySafeTransfer(address token, address to, uint256 amount, uint256 mode) public {
-        if (mode == _REVERTS_WITH_SELECTOR) {
-            vm.expectRevert(SafeTransferLib.TransferFailed.selector);
-        } else if (mode == _REVERTS_WITH_ANY) {
-            (bool success,) = address(this).call(
-                abi.encodeWithSignature(
-                    "verifySafeTransfer(address,address,uint256)", token, to, amount
-                )
-            );
-            assertFalse(success);
-            return;
-        }
-        this.verifySafeTransfer(token, to, amount);
-    }
-
-    function verifySafeTransfer(address token, address to, uint256 amount) public brutalizeMemory {
-        uint256 preBal = ERC20(token).balanceOf(to);
-        if (amount == ERC20(token).balanceOf(address(this)) && _randomChance(2)) {
-            SafeTransferLib.safeTransferAll(address(token), _brutalized(to));
-        } else {
-            SafeTransferLib.safeTransfer(address(token), _brutalized(to), amount);
-        }
-
-        uint256 postBal = ERC20(token).balanceOf(to);
-
-        if (to == address(this)) {
-            assertEq(preBal, postBal);
-        } else {
-            assertEq(postBal - preBal, amount);
-        }
-    }
-
-    function verifySafeTransferFrom(
-        address token,
-        address from,
-        address to,
-        uint256 amount,
-        uint256 mode
-    ) public {
-        if (mode == _REVERTS_WITH_SELECTOR) {
-            vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);
-        } else if (mode == _REVERTS_WITH_ANY) {
-            (bool success,) = address(this).call(
-                abi.encodeWithSignature(
-                    "verifySafeTransferFrom(address,address,address,uint256)",
-                    token,
-                    from,
-                    to,
-                    amount
-                )
-            );
-            assertFalse(success);
-            return;
-        }
-        this.verifySafeTransferFrom(token, from, to, amount);
-    }
-
-    function verifySafeTransferFrom(address token, address from, address to, uint256 amount)
-        public
-        brutalizeMemory
-    {
-        forceApprove(token, from, address(this), amount);
-
-        // We cast to MissingReturnToken here because it won't check
-        // that there was return data, which accommodates all tokens.
-        MissingReturnToken(token).transfer(from, amount);
-
-        uint256 preBal = ERC20(token).balanceOf(to);
-        if (amount == ERC20(token).balanceOf(from) && _randomChance(2)) {
-            SafeTransferLib.safeTransferAllFrom(address(token), _brutalized(from), _brutalized(to));
-        } else {
-            SafeTransferLib.safeTransferFrom(token, _brutalized(from), _brutalized(to), amount);
-        }
-        uint256 postBal = ERC20(token).balanceOf(to);
-
-        if (from == to) {
-            assertEq(preBal, postBal);
-        } else {
-            assertEq(postBal - preBal, amount);
-        }
-    }
-
-    function verifySafeApprove(address token, address to, uint256 amount, uint256 mode) public {
-        if (mode == _REVERTS_WITH_SELECTOR) {
-            vm.expectRevert(SafeTransferLib.ApproveFailed.selector);
-        } else if (mode == _REVERTS_WITH_ANY) {
-            (bool success,) = address(this).call(
-                abi.encodeWithSignature(
-                    "verifySafeApprove(address,address,uint256)", token, to, amount
-                )
-            );
-            assertFalse(success);
-            return;
-        }
-        this.verifySafeApprove(token, to, amount);
-    }
-
-    function verifySafeApprove(address token, address to, uint256 amount) public {
-        SafeTransferLib.safeApprove(_brutalized(address(token)), _brutalized(to), amount);
-
-        assertEq(ERC20(token).allowance(address(this), to), amount);
-    }
-
-    function forceApprove(address token, address from, address to, uint256 amount) public {
-        if (token == address(erc20)) {
-            bytes32 allowanceSlot;
-            /// @solidity memory-safe-assembly
-            assembly {
-                mstore(0x20, to)
-                mstore(0x0c, 0x7f5e9f20) // `_ALLOWANCE_SLOT_SEED`.
-                mstore(0x00, from)
-                allowanceSlot := keccak256(0x0c, 0x34)
-            }
-            vm.store(token, allowanceSlot, bytes32(uint256(amount)));
-        } else {
-            vm.store(
-                token,
-                keccak256(abi.encode(to, keccak256(abi.encode(from, uint256(2))))),
-                bytes32(uint256(amount))
-            );
-        }
-
-        assertEq(ERC20(token).allowance(from, to), amount, "wrong allowance");
-    }
-
-    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) public {
-        SafeTransferLib.forceSafeTransferETH(to, amount, gasStipend);
-    }
-
-    function forceSafeTransferETH(address to, uint256 amount) public {
-        SafeTransferLib.forceSafeTransferETH(to, amount);
-    }
-
-    function safeTransferETH(address to, uint256 amount) public {
-        SafeTransferLib.safeTransferETH(to, amount);
-    }
-
-    function safeTransferAllETH(address to) public {
-        SafeTransferLib.safeTransferAllETH(to);
-    }
-
-    function _generateGarbage() internal returns (bytes memory result) {
-        uint256 r = _random();
-        /// @solidity memory-safe-assembly
-        assembly {
-            for {} 1 {} {
-                mstore(0x00, r)
-                result := mload(0x40)
-                let n := and(r, 0x7f)
-                mstore(result, n)
-                r := keccak256(0x00, 0x40)
-                mstore(add(result, 0x20), r)
-                mstore(0x40, add(result, 0x100))
-                if and(or(lt(n, 0x20), iszero(eq(r, 1))), gt(n, 0)) { break }
-            }
-        }
-    }
-
-    function _generateNonGarbage() internal returns (bytes memory result) {
-        uint256 r = _random();
-        /// @solidity memory-safe-assembly
-        assembly {
-            if iszero(and(r, 1)) {
-                result := mload(0x40)
-                mstore(result, 0x20)
-                mstore(add(result, 0x20), 1)
-                mstore(0x40, add(result, 0x40))
-            }
-        }
-    }
-
-    function testTotalSupplyQuery() public {
-        uint256 totalSupplyBefore = this.totalSupplyQuery(address(erc20));
-        erc20.burn(address(this), 123);
-        assertEq(this.totalSupplyQuery(address(erc20)), totalSupplyBefore - 123);
-        vm.expectRevert(SafeTransferLib.TotalSupplyQueryFailed.selector);
-        this.totalSupplyQuery(address(0));
-    }
-
-    function totalSupplyQuery(address token) public view returns (uint256) {
-        return SafeTransferLib.totalSupply(token);
-    }
-
-    function testForceSafeTransferETH(uint256 amount) public {
-        address vault;
-        amount = _bound(amount, 0, 1 ether);
-        vm.deal(address(this), 1 ether);
-        griefer.setReceiveNumLoops(1 << 128);
-
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 1 ether);
-        assertNotEq(vault, address(0));
-        assertEq(vault.balance, 1 ether);
-
-        griefer.setReceiveNumLoops(0);
-
-        if (_randomChance(2)) {
-            vm.prank(address(griefer));
-            (bool success,) = vault.call("");
-            assertTrue(success);
-            assertEq(address(griefer).balance, 1 ether);
-        } else {
-            (address to, bytes memory data) = _sampleToAndVaultCalldata();
-            if (uint160(to) < 0xffff) return;
-            vm.prank(address(griefer));
-            (bool success,) = vault.call(data);
-            assertTrue(success);
-            assertEq(to.balance, 1 ether);
-        }
-    }
-
-    function _sampleToAndVaultCalldata() internal returns (address to, bytes memory data) {
-        if (_randomChance(2)) {
-            to = _randomHashedAddress();
-            data = abi.encodePacked(abi.encode(to), new bytes(_randomUniform() % 64));
-            return (to, data);
-        }
-        uint256 r = _randomUniform();
-        uint256 n = _bound(_randomUniform(), 1, 32);
-        /// @solidity memory-safe-assembly
-        assembly {
-            data := mload(0x40)
-            mstore(add(data, 0x20), r)
-            mstore(data, n)
-            mstore(0x40, add(n, add(0x20, data)))
-            mstore(0x00, 0)
-            mstore(sub(0x20, n), r)
-            to := mload(0x00)
-        }
-    }
-
-    function testForceSafeTransferETH() public {
-        address vault;
-        vm.deal(address(this), 1 ether);
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 0.1 ether);
-        assertEq(address(griefer).balance, 0.1 ether);
-
-        griefer.setReceiveNumLoops(1 << 128);
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 0.1 ether);
-        assertEq(address(griefer).balance, 0.1 ether);
-
-        griefer.setReceiveNumLoops(0);
-        griefer.execute(vault, abi.encode(address(griefer)));
-        assertEq(address(griefer).balance, 0.2 ether);
-
-        griefer.setReceiveNumLoops(1 << 128);
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 0.1 ether);
-
-        griefer.setReceiveNumLoops(0);
-        griefer.execute(vault, "");
-        assertEq(address(griefer).balance, 0.3 ether);
-
-        griefer.setReceiveNumLoops(1 << 128);
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 0.1 ether);
-
-        griefer.setReceiveNumLoops(0);
-        griefer.execute(vault, abi.encodePacked(address(griefer)));
-        assertEq(address(griefer).balance, 0.4 ether);
-
-        address anotherRecipient = address(new Griefer());
-
-        griefer.setReceiveNumLoops(1 << 128);
-        vault = SafeTransferLib.forceSafeTransferETH(address(griefer), 0.1 ether);
-
-        griefer.setReceiveNumLoops(0);
-        griefer.execute(vault, abi.encodePacked(address(anotherRecipient)));
-        assertEq(address(anotherRecipient).balance, 0.1 ether);
-    }
-}
diff --git a/test/ext/zksync/SignatureCheckerLib.t.sol b/test/ext/zksync/SignatureCheckerLib.t.sol
deleted file mode 100644
index aa4647a..0000000
--- a/test/ext/zksync/SignatureCheckerLib.t.sol
+++ /dev/null
@@ -1,387 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import "./../../utils/SoladyTest.sol";
-import {SignatureCheckerLib} from "../../../src/utils/ext/zksync/SignatureCheckerLib.sol";
-import {ECDSA} from "../../../src/utils/ECDSA.sol";
-import {MockERC1271Wallet} from "./../../utils/mocks/MockERC1271Wallet.sol";
-import {MockERC1271Malicious} from "./../../utils/mocks/MockERC1271Malicious.sol";
-
-contract SignatureCheckerLibTest is SoladyTest {
-    bytes32 constant TEST_MESSAGE =
-        0x7dbaf558b0a1a5dc7a67202117ab143c1d8605a983e4a743bc06fcc03162dc0d;
-
-    bytes32 constant WRONG_MESSAGE =
-        0x2d0828dd7c97cff316356da3c16c68ba2316886a0e05ebafb8291939310d51a3;
-
-    address constant SIGNER = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;
-
-    address constant OTHER = address(uint160(1));
-
-    bytes32 constant TEST_SIGNED_MESSAGE_HASH =
-        0x7d768af957ef8cbf6219a37e743d5546d911dae3e46449d8a5810522db2ef65e;
-
-    bytes32 constant WRONG_SIGNED_MESSAGE_HASH =
-        0x8cd3e659093d21364c6330514aff328218aa29c2693c5b0e96602df075561952;
-
-    bytes constant SIGNATURE =
-        hex"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
-
-    bytes constant INVALID_SIGNATURE =
-        hex"7688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
-
-    MockERC1271Wallet mockERC1271Wallet;
-
-    MockERC1271Malicious mockERC1271Malicious;
-
-    function setUp() public {
-        mockERC1271Wallet = new MockERC1271Wallet(SIGNER);
-        mockERC1271Malicious = new MockERC1271Malicious();
-    }
-
-    function testSignatureCheckerOnEOAWithMatchingSignerAndSignature() public {
-        _checkSignature(SIGNER, TEST_SIGNED_MESSAGE_HASH, SIGNATURE, true);
-    }
-
-    function testSignatureCheckerOnEOAWithInvalidSigner() public {
-        _checkSignature(OTHER, TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);
-    }
-
-    function testSignatureCheckerOnEOAWithWrongSignedMessageHash() public {
-        _checkSignature(SIGNER, WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false);
-    }
-
-    function testSignatureCheckerOnEOAWithInvalidSignature() public {
-        _checkSignature(SIGNER, TEST_SIGNED_MESSAGE_HASH, INVALID_SIGNATURE, false);
-    }
-
-    function testSignatureCheckerOnWalletWithMatchingSignerAndSignature() public {
-        address signer = address(mockERC1271Wallet);
-        bytes32 hash = TEST_SIGNED_MESSAGE_HASH;
-        bytes memory signature = SIGNATURE;
-        _checkSignature(true, signer, hash, signature, true);
-        _checkSignature(false, signer, hash, signature, true);
-        vm.etch(signer, "");
-        _checkSignature(false, signer, hash, signature, false);
-    }
-
-    function testSignatureCheckerOnWalletWithInvalidSigner() public {
-        _checkSignatureBothModes(address(this), TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);
-    }
-
-    function testSignatureCheckerOnWalletWithZeroAddressSigner() public {
-        _checkSignatureBothModes(address(0), TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);
-    }
-
-    function testSignatureCheckerOnWalletWithWrongSignedMessageHash() public {
-        _checkSignatureBothModes(
-            address(mockERC1271Wallet), WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false
-        );
-    }
-
-    function testSignatureCheckerOnWalletWithInvalidSignature() public {
-        _checkSignatureBothModes(
-            address(mockERC1271Wallet), TEST_SIGNED_MESSAGE_HASH, INVALID_SIGNATURE, false
-        );
-    }
-
-    function testSignatureCheckerOnMaliciousWallet() public {
-        _checkSignatureBothModes(
-            address(mockERC1271Malicious), WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false
-        );
-    }
-
-    function testSignatureChecker(bytes32 digest) public {
-        (address signer, uint256 privateKey) = _randomSigner();
-
-        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);
-        _checkSignature(signer, digest, abi.encodePacked(r, s, v), true);
-
-        if (_randomChance(8)) {
-            assertEq(
-                this.isValidSignatureNowCalldata(signer, digest, abi.encodePacked(r, s, v)), true
-            );
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encodePacked(r, s, v)),
-                true
-            );
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(
-                    signer, digest, abi.encodePacked(r, s, v + 1)
-                ),
-                false
-            );
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(
-                    signer, digest, abi.encodePacked(r, s, v - 1)
-                ),
-                false
-            );
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, v, r, s), true);
-        }
-
-        if (_randomChance(8)) {
-            bytes32 vs;
-            /// @solidity memory-safe-assembly
-            assembly {
-                vs := or(shl(255, sub(v, 27)), s)
-            }
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, r, vs), true);
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encode(r, vs)), true
-            );
-            assertEq(this.isValidSignatureNowCalldata(signer, digest, abi.encode(r, vs)), true);
-        }
-
-        if (_randomChance(8)) {
-            bytes32 vsc; // Corrupted `vs`.
-            /// @solidity memory-safe-assembly
-            assembly {
-                vsc := or(shl(255, xor(1, sub(v, 27))), s)
-            }
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, r, vsc), false);
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encode(r, vsc)), false
-            );
-            assertEq(this.isValidSignatureNowCalldata(signer, digest, abi.encode(r, vsc)), false);
-        }
-
-        if (_randomChance(8) && r != bytes32(0) && s != bytes32(0)) {
-            bytes32 rc = bytes32(uint256(r) - (_random() & 1)); // Corrupted `r`.
-            bytes32 sc = bytes32(uint256(s) - (_random() & 1)); // Corrupted `s`.
-            bool anyCorrupted = rc != r || sc != s;
-            _checkSignature(signer, digest, abi.encodePacked(rc, sc, v), !anyCorrupted);
-        }
-
-        if (_randomChance(8)) {
-            uint8 vc = uint8(_random()); // Corrupted `v`.
-            while (vc == 28 || vc == 27) vc = uint8(_random());
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, vc, r, s), false);
-            assertEq(
-                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encodePacked(r, s, vc)),
-                false
-            );
-            assertEq(
-                this.isValidSignatureNowCalldata(signer, digest, abi.encodePacked(r, s, vc)), false
-            );
-        }
-    }
-
-    function _checkSignatureBothModes(
-        address signer,
-        bytes32 hash,
-        bytes memory signature,
-        bool expectedResult
-    ) internal {
-        _checkSignature(false, signer, hash, signature, expectedResult);
-        _checkSignature(true, signer, hash, signature, expectedResult);
-    }
-
-    function _checkSignature(
-        address signer,
-        bytes32 hash,
-        bytes memory signature,
-        bool expectedResult
-    ) internal {
-        _checkSignature(false, signer, hash, signature, expectedResult);
-    }
-
-    function _checkSignature(
-        bool onlyERC1271,
-        address signer,
-        bytes32 hash,
-        bytes memory signature,
-        bool expectedResult
-    ) internal {
-        bool callResult;
-        /// @solidity memory-safe-assembly
-        assembly {
-            let m := mload(0x40)
-
-            // `bytes4(keccak256("isValidSignatureNow(address,bytes32,bytes)"))`.
-            mstore(m, shl(224, 0x6ccea652))
-            if onlyERC1271 {
-                // `bytes4(keccak256("isValidERC1271SignatureNow(address,bytes32,bytes)"))`.
-                mstore(m, shl(224, 0x3ae5d83c))
-            }
-            // We'll still clean the upper 96 bits of signer,
-            // so that it will pass the implicit calldata check added by Solidity.
-            mstore(add(m, 0x04), shr(96, shl(96, signer)))
-            mstore(add(m, 0x24), hash)
-            mstore(add(m, 0x44), 0x60) // Offset of signature in calldata.
-            mstore(add(m, 0x64), mload(signature))
-            mstore(add(m, 0x84), mload(add(signature, 0x20)))
-            mstore(add(m, 0xa4), mload(add(signature, 0x40)))
-            mstore(add(m, 0xc4), mload(add(signature, 0x60)))
-            // Brutalize the bytes following the 8-bit `v`. All ones will do.
-            mstore(add(m, 0xc5), not(0))
-
-            // We have to do the call in assembly to ensure that Solidity does not
-            // clean up the brutalized bits.
-            callResult :=
-                and(
-                    and(
-                        // Whether the returndata is equal to 1.
-                        eq(mload(0x00), 1),
-                        // Whether the returndata is exactly 0x20 bytes (1 word) long .
-                        eq(returndatasize(), 0x20)
-                    ),
-                    // Whether the staticcall does not revert.
-                    // This must be placed at the end of the `and` clause,
-                    // as the arguments are evaluated from right to left.
-                    staticcall(
-                        gas(), // Remaining gas.
-                        address(), // The current contract's address.
-                        m, // Offset of calldata in memory.
-                        0xe4, // Length of calldata in memory.
-                        0x00, // Offset of returndata.
-                        0x20 // Length of returndata to write.
-                    )
-                )
-        }
-        assertEq(callResult, expectedResult);
-
-        uint8 v;
-        bytes32 r;
-        bytes32 s;
-        bytes32 vs;
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Contaminate the upper 96 bits.
-            signer := or(shl(160, 1), signer)
-            // Extract `r`, `s`, `v`.
-            r := mload(add(signature, 0x20))
-            s := mload(add(signature, 0x40))
-            v := byte(0, mload(add(signature, 0x60)))
-            // Pack `vs`.
-            vs := or(shl(255, sub(v, 27)), s)
-
-            // Brutalize the memory. Just all ones will do.
-            let m := mload(0x40)
-            for { let i := 0 } lt(i, 30) { i := add(i, 1) } { mstore(add(m, shl(5, i)), not(0)) }
-        }
-
-        if (onlyERC1271) {
-            assertEq(
-                SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, r, vs), expectedResult
-            );
-            assertEq(
-                SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, v, r, s),
-                expectedResult
-            );
-        } else {
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, r, vs), expectedResult);
-            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, v, r, s), expectedResult);
-        }
-    }
-
-    function isValidSignatureNow(address signer, bytes32 hash, bytes calldata signature)
-        external
-        returns (bool result)
-    {
-        bool signatureIsBrutalized;
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Contaminate the upper 96 bits.
-            signer := or(shl(160, 1), signer)
-            // Ensure that the bytes right after the signature is brutalized.
-            signatureIsBrutalized := calldataload(add(signature.offset, signature.length))
-        }
-        if (!signatureIsBrutalized) revert("Signature is not brutalized.");
-
-        result = SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature);
-        assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, signature), result);
-    }
-
-    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes calldata signature)
-        external
-        returns (bool result)
-    {
-        bool signatureIsBrutalized;
-        /// @solidity memory-safe-assembly
-        assembly {
-            // Contaminate the upper 96 bits.
-            signer := or(shl(160, 1), signer)
-            // Ensure that the bytes right after the signature is brutalized.
-            signatureIsBrutalized := calldataload(add(signature.offset, signature.length))
-        }
-        if (!signatureIsBrutalized) revert("Signature is not brutalized.");
-
-        result = SignatureCheckerLib.isValidERC1271SignatureNowCalldata(signer, hash, signature);
-        assertEq(SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, signature), result);
-    }
-
-    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)
-        external
-        view
-        returns (bool result)
-    {
-        result = SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature);
-    }
-
-    function isValidERC1271SignatureNowCalldata(
-        address signer,
-        bytes32 hash,
-        bytes calldata signature
-    ) external view returns (bool result) {
-        result = SignatureCheckerLib.isValidERC1271SignatureNowCalldata(signer, hash, signature);
-    }
-
-    function testEmptyCalldataHelpers() public {
-        assertFalse(
-            SignatureCheckerLib.isValidSignatureNow(
-                address(1), bytes32(0), SignatureCheckerLib.emptySignature()
-            )
-        );
-    }
-
-    function testToEthSignedMessageHashDifferential(bytes32 hash) public {
-        assertEq(
-            SignatureCheckerLib.toEthSignedMessageHash(hash), ECDSA.toEthSignedMessageHash(hash)
-        );
-    }
-
-    function testToEthSignedMessageHashDifferential(bytes memory s) public {
-        assertEq(SignatureCheckerLib.toEthSignedMessageHash(s), ECDSA.toEthSignedMessageHash(s));
-    }
-
-    function testSignatureCheckerPassthrough(bytes calldata signature) public {
-        bytes32 hash = keccak256(signature);
-        mockERC1271Wallet.setUseSignaturePassthrough(true);
-        if (_randomChance(8)) {
-            _misalignFreeMemoryPointer();
-            _brutalizeMemory();
-        }
-        address signer = address(mockERC1271Wallet);
-        assertEq(SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature), true);
-        assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, signature), true);
-
-        hash = bytes32(uint256(hash) ^ 1);
-        assertEq(SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature), false);
-        assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, signature), false);
-    }
-
-    function _makeShortSignature(bytes memory signature)
-        internal
-        pure
-        returns (bytes memory result)
-    {
-        require(signature.length == 65);
-        /// @solidity memory-safe-assembly
-        assembly {
-            result := mload(0x40)
-            let r := mload(add(signature, 0x20))
-            let s := mload(add(signature, 0x40))
-            let v := byte(0, mload(add(signature, 0x60)))
-            let vs := 0
-            switch v
-            case 27 { vs := shr(1, shl(1, s)) }
-            case 28 { vs := or(shl(255, 1), shr(1, shl(1, s))) }
-            default { invalid() }
-            mstore(result, 0x40) // Length.
-            mstore(add(result, 0x20), r)
-            mstore(add(result, 0x40), vs)
-            mstore(0x40, add(result, 0x60)) // Allocate memory.
-        }
-    }
-}
diff --git a/test/utils/mocks/MockReentrancyGuardTransient.sol b/test/utils/mocks/MockReentrancyGuardTransient.sol
deleted file mode 100644
index 18d6430..0000000
--- a/test/utils/mocks/MockReentrancyGuardTransient.sol
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
-
-import {ReentrancyGuardTransient} from "../../../src/utils/ReentrancyGuardTransient.sol";
-
-/// @dev WARNING! This mock is strictly intended for testing purposes only.
-/// Do NOT copy anything here into production code unless you really know what you are doing.
-contract MockReentrancyGuardTransient is ReentrancyGuardTransient {
-    /// @dev SEE: `ReentrancyGuardTransient`.
-    uint256 public constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;
-
-    uint256 public enterTimes;
-
-    bool public transientOnlyOnMainnet;
-
-    // Mocks
-
-    function isReentrancyGuardLocked() public view returns (bool locked) {
-        /// @solidity memory-safe-assembly
-        assembly {
-            if tload(_REENTRANCY_GUARD_SLOT) { locked := true }
-        }
-    }
-
-    function callUnguardedToGuarded() public {
-        callbackTargetGuarded();
-    }
-
-    function callUnguardedToUnguarded() public {
-        callbackTargetUnguarded();
-    }
-
-    function callGuardedToGuarded() public nonReentrant {
-        callbackTargetGuarded();
-    }
-
-    function callGuardedToUnguarded() public nonReentrant {
-        callbackTargetUnguarded();
-    }
-
-    function callGuardedToReadGuarded() public nonReentrant {
-        readCallbackTargetGuarded();
-    }
-
-    function callUnguardedToReadGuarded() public {
-        readCallbackTargetGuarded();
-    }
-
-    function setTransientOnlyOnMainnet(bool value) public {
-        transientOnlyOnMainnet = value;
-    }
-
-    function _useTransientReentrancyGuardOnlyOnMainnet() internal view override returns (bool) {
-        return transientOnlyOnMainnet;
-    }
-
-    // Targets
-
-    /// @dev Callback target without a reentrancy guard.
-    function callbackTargetUnguarded() public {
-        enterTimes++;
-    }
-
-    /// @dev Callback target with a reentrancy guard.
-    function callbackTargetGuarded() public nonReentrant {
-        enterTimes++;
-    }
-
-    /// @dev Callback target with a non-read reentrancy guard.
-    function readCallbackTargetGuarded() public nonReadReentrant {
-        enterTimes++;
-    }
-
-    // Recursion
-
-    function countUnguardedDirectRecursive(uint256 recursion) public {
-        _recurseDirect(false, recursion);
-    }
-
-    function countGuardedDirectRecursive(uint256 recursion) public nonReentrant {
-        _recurseDirect(true, recursion);
-    }
-
-    function countUnguardedIndirectRecursive(uint256 recursion) public {
-        _recurseIndirect(false, recursion);
-    }
-
-    function countGuardedIndirectRecursive(uint256 recursion) public nonReentrant {
-        _recurseIndirect(true, recursion);
-    }
-
-    function countAndCall(ReentrancyAttack attacker) public nonReentrant {
-        enterTimes++;
-        attacker.callSender(bytes4(keccak256("callbackTargetGuarded()")));
-    }
-
-    // Helpers
-
-    function _recurseDirect(bool guarded, uint256 recursion) private {
-        if (recursion > 0) {
-            enterTimes++;
-
-            if (guarded) {
-                countGuardedDirectRecursive(recursion - 1);
-            } else {
-                countUnguardedDirectRecursive(recursion - 1);
-            }
-        }
-    }
-
-    function _recurseIndirect(bool guarded, uint256 recursion) private {
-        if (recursion > 0) {
-            enterTimes++;
-
-            (bool success, bytes memory data) = address(this).call(
-                abi.encodeWithSignature(
-                    guarded
-                        ? "countGuardedIndirectRecursive(uint256)"
-                        : "countUnguardedIndirectRecursive(uint256)",
-                    recursion - 1
-                )
-            );
-
-            if (!success) {
-                /// @solidity memory-safe-assembly
-                assembly {
-                    revert(add(32, data), mload(data))
-                }
-            }
-        }
-    }
-}
-
-/// @dev WARNING! This mock is strictly intended for testing purposes only.
-/// Do NOT copy anything here into production code unless you really know what you are doing.
-contract ReentrancyAttack {
-    /// @dev Reverts on a failed reentrancy attack.
-    error ReentrancyAttackFailed();
-
-    /// @dev Call the msg.sender with the given data to perform a reentrancy attack.
-    function callSender(bytes4 data) external {
-        (bool success,) = msg.sender.call(abi.encodeWithSelector(data));
-
-        if (!success) revert ReentrancyAttackFailed();
-    }
-}
diff --git a/test/utils/mocks/ext/zksync/MockERC1155.sol b/test/utils/mocks/ext/zksync/MockERC1155.sol
deleted file mode 100644
index a90ce6e..0000000
--- a/test/utils/mocks/ext/zksync/MockERC1155.sol
+++ /dev/null
@@ -1,124 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import {ERC1155} from "../../../../../src/tokens/ext/zksync/ERC1155.sol";
-import {Brutalizer} from "../../../Brutalizer.sol";
-
-/// @dev WARNING! This mock is strictly intended for testing purposes only.
-/// Do NOT copy anything here into production code unless you really know what you are doing.
-contract MockERC1155 is ERC1155, Brutalizer {
-    bytes32 public lastDataHash;
-
-    function uri(uint256) public pure virtual override returns (string memory) {}
-
-    function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {
-        _mint(_brutalized(to), id, amount, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function batchMint(
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) public virtual {
-        _batchMint(_brutalized(to), ids, amounts, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function burn(address from, uint256 id, uint256 amount) public virtual {
-        _burn(_brutalized(msg.sender), _brutalized(from), id, amount);
-    }
-
-    function uncheckedBurn(address from, uint256 id, uint256 amount) public virtual {
-        _burn(_brutalized(from), id, amount);
-    }
-
-    function batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)
-        public
-        virtual
-    {
-        _batchBurn(_brutalized(msg.sender), _brutalized(from), ids, amounts);
-    }
-
-    function uncheckedBatchBurn(address from, uint256[] memory ids, uint256[] memory amounts)
-        public
-        virtual
-    {
-        _batchBurn(_brutalized(from), ids, amounts);
-    }
-
-    function safeTransferFrom(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes calldata data
-    ) public virtual override {
-        super.safeTransferFrom(_brutalized(from), _brutalized(to), id, amount, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function directSafeTransferFrom(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes memory data
-    ) public virtual {
-        _safeTransfer(_brutalized(msg.sender), _brutalized(from), _brutalized(to), id, amount, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function uncheckedSafeTransferFrom(
-        address from,
-        address to,
-        uint256 id,
-        uint256 amount,
-        bytes memory data
-    ) public virtual {
-        _safeTransfer(_brutalized(address(0)), _brutalized(from), _brutalized(to), id, amount, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function safeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] calldata ids,
-        uint256[] calldata amounts,
-        bytes calldata data
-    ) public virtual override {
-        super.safeBatchTransferFrom(_brutalized(from), _brutalized(to), ids, amounts, data);
-        lastDataHash = keccak256(data);
-    }
-
-    function directSafeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) public virtual {
-        _safeBatchTransfer(
-            _brutalized(msg.sender), _brutalized(from), _brutalized(to), ids, amounts, data
-        );
-        lastDataHash = keccak256(data);
-    }
-
-    function uncheckedSafeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) public virtual {
-        _safeBatchTransfer(
-            _brutalized(address(0)), _brutalized(from), _brutalized(to), ids, amounts, data
-        );
-        lastDataHash = keccak256(data);
-    }
-
-    function directSetApprovalForAll(address operator, bool approved) public virtual {
-        _setApprovalForAll(_brutalized(msg.sender), _brutalized(operator), approved);
-    }
-}
diff --git a/test/utils/mocks/ext/zksync/MockERC721.sol b/test/utils/mocks/ext/zksync/MockERC721.sol
deleted file mode 100644
index 610534f..0000000
--- a/test/utils/mocks/ext/zksync/MockERC721.sol
+++ /dev/null
@@ -1,139 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.4;
-
-import {ERC721} from "../../../../../src/tokens/ext/zksync/ERC721.sol";
-import {LibString} from "../../../../../src/utils/LibString.sol";
-import {Brutalizer} from "../../../Brutalizer.sol";
-
-/// @dev WARNING! This mock is strictly intended for testing purposes only.
-/// Do NOT copy anything here into production code unless you really know what you are doing.
-contract MockERC721 is ERC721, Brutalizer {
-    function name() public view virtual override returns (string memory) {
-        return "TEST NFT";
-    }
-
-    function symbol() public view virtual override returns (string memory) {
-        return "TEST";
-    }
-
-    function tokenURI(uint256 id) public view virtual override returns (string memory) {
-        if (!_exists(id)) revert TokenDoesNotExist();
-        return string(abi.encodePacked("https://remilio.org/remilio/json/", LibString.toString(id)));
-    }
-
-    function exists(uint256 id) public view virtual returns (bool) {
-        return _exists(id);
-    }
-
-    function mint(address to, uint256 id) public virtual {
-        _mint(_brutalized(to), id);
-    }
-
-    function mintWithExtraDataUnchecked(address to, uint256 id, uint96 value) public virtual {
-        _mintAndSetExtraDataUnchecked(_brutalized(to), id, _brutalizedUint96(value));
-    }
-
-    function burn(uint256 id) public virtual {
-        _burn(msg.sender, id);
-    }
-
-    function uncheckedBurn(uint256 id) public virtual {
-        _burn(id);
-    }
-
-    function safeMint(address to, uint256 id) public virtual {
-        _safeMint(_brutalized(to), id);
-    }
-
-    function safeMint(address to, uint256 id, bytes calldata data) public virtual {
-        _safeMint(_brutalized(to), id, data);
-    }
-
-    function getExtraData(uint256 id) public view virtual returns (uint96) {
-        return _getExtraData(id);
-    }
-
-    function setExtraData(uint256 id, uint96 value) public virtual {
-        _setExtraData(id, value);
-    }
-
-    function getAux(address owner) public view virtual returns (uint224) {
-        return _getAux(_brutalized(owner));
-    }
-
-    function setAux(address owner, uint224 value) public virtual {
-        _setAux(_brutalized(owner), value);
-    }
-
-    function approve(address account, uint256 id) public payable virtual override {
-        super.approve(_brutalized(account), id);
-    }
-
-    function directApprove(address account, uint256 id) public virtual {
-        if (!_isApprovedOrOwner(_brutalized(msg.sender), id)) revert NotOwnerNorApproved();
-        _approve(_brutalized(account), id);
-    }
-
-    function setApprovalForAll(address operator, bool approved) public virtual override {
-        super.setApprovalForAll(_brutalized(operator), approved);
-    }
-
-    function directSetApprovalForAll(address operator, bool approved) public virtual {
-        _setApprovalForAll(_brutalized(msg.sender), _brutalized(operator), approved);
-    }
-
-    function transferFrom(address from, address to, uint256 id) public payable virtual override {
-        super.transferFrom(_brutalized(from), _brutalized(to), id);
-    }
-
-    function uncheckedTransferFrom(address from, address to, uint256 id) public payable virtual {
-        _transfer(_brutalized(address(0)), _brutalized(from), _brutalized(to), id);
-    }
-
-    function directTransferFrom(address from, address to, uint256 id) public virtual {
-        _transfer(_brutalized(msg.sender), _brutalized(from), _brutalized(to), id);
-    }
-
-    function safeTransferFrom(address from, address to, uint256 id)
-        public
-        payable
-        virtual
-        override
-    {
-        super.safeTransferFrom(_brutalized(from), _brutalized(to), id);
-    }
-
-    function directSafeTransferFrom(address from, address to, uint256 id) public virtual {
-        _safeTransfer(_brutalized(msg.sender), _brutalized(from), _brutalized(to), id);
-    }
-
-    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)
-        public
-        payable
-        virtual
-        override
-    {
-        super.safeTransferFrom(_brutalized(from), _brutalized(to), id, data);
-    }
-
-    function directSafeTransferFrom(address from, address to, uint256 id, bytes calldata data)
-        public
-        virtual
-    {
-        _safeTransfer(_brutalized(msg.sender), _brutalized(from), _brutalized(to), id, data);
-    }
-
-    function isApprovedOrOwner(address account, uint256 id) public view virtual returns (bool) {
-        return _isApprovedOrOwner(_brutalized(account), id);
-    }
-
-    function directOwnerOf(uint256 id) public view virtual returns (address) {
-        if (!_exists(id)) revert TokenDoesNotExist();
-        return _ownerOf(id);
-    }
-
-    function directGetApproved(uint256 id) public view virtual returns (address) {
-        if (!_exists(id)) revert TokenDoesNotExist();
-        return _getApproved(id);
-    }
-}
